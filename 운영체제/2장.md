* ## 2.1 프로세스
	* 프로세스: 실행중인 프로그램을 추상화 한 것. , 논리적으로 작성된 프로그램을, 데이터를 가져와 행하는 것
	* 의사병렬성(pseudoparrallelism): 
		* 한 cpu가 한 프로세스에서 다른 프로세스로 빠르게 넘어가면서 각 프로세스를 짧은 시간동안 번갈아 가면서 수행해, 병렬 수행하는 거 처럼 보이게 하는 것.
		* 이는 실제 cpu가 여러개인 다중처리기 시스템과 구분된다.
	* \# 다른 fault와 다르게 page fault는 수정가능하기에 blocked 되지 않고 os로 제어권이 넘어가게 된다.
	* 
	* #### 2.1.1 프로세스 모델
		* 모든 소프트웨어는 순차 프로세스(=sequential process == process)로 구성되어 있고,
		* 각 프로세스는 pc(program counter), 레지스터, 변수들을 포함한다.
		* 한 cpu는 한 프로세스만을 처리하지만 ,빠르게 왔다갔다해서 동시에 처리하는 것처럼 보이는 것.
		* 다중프로그래밍(multi programming)
			* 프로그램 사이를 빨리 전환하는 것.
		* 특정 프로세스가 시작될 떄 논리적인 프로그램 카운터는 실제(물리적인) 프로그램 카운터에 적재 되어야 한다.
		* 프로세스는 프로그램, 입력, 출력, 상태를 가진다.
		* 또한 하나의 processor(처리기)에 여러 프로세스가 들어올 수 있다.
		* processor에 무엇이 들어올 지는 스케줄링 알고리즘을 따른다.
	* #### 2.1.2 프로세스 생성
		* 매우 간단한 시스템은 시스템이 기동할 때 모든 프로세스를 만들어지도록 하나,
		* 복잡한 시스템은 운영 도중에 필요한 프로세스를 생성하고 종료 해야한다.
		* ##### 프로세스 생성을 유발하는 네 가지 이벤트
			* 1. 시스템 초기화
			* 2. 실행중인 프로세스가 프로세스 생성 시스템 콜을 호출했을 경우
			* 배치 작업의 시작, 즉 순차적으로 프로세스를 생성하고 종료
			* 사용자가 프로세스 생성 요청
		* ##### 전위 프로세스와 백그라운드 프로세스
			* 전위(foreground) 프로세스란 사용자와 소통하고, 이들을 위해 작업을 수행하는 프로세스
			* 백그라운드 프로세스(=demon)은 사용자와 연관되어 있지 않고, 미리 정해진 일을 하는 프로세스, 혹은 대기하다가 외부에서 요청이 들어오면 일을 하는 프로세스
		* 프로세스가 프로세스를 생성하려면 시스템 콜을 해야한다. 왜냐면 생성은 운영체제가 하는 일인데, 프로세스가 운영체제 내부에서 돌아가는 게 아니니까
		* 마이크로 소프트 windows의 경우 프로세스가 시작할 때 윈도우를 갖게 된다. 윈도우는 프로세스를 수행한다.
		* 모든 새로운 프로세스는 기존의 프로세스가 프로세스 생성 시스템 콜을 불러서 생성한다.
		* 호출되는 프로세스는 1. 기존 프로세스 2. 키보드등의 시스템 프로세스, 3. 배치 관리자 프로세스 중 하나가 호출한다.
		* UNIX의 경우 새로운 프로세스는 fork를 통해 기존의 프로세스를 그대로 복사하면서 시작된다. 그럼 동일한 메모리 내용, 같은 환경 문자열, 동일한 열린 파일들을 가진다.
		* 이후 execve를 통해 생성된 프로세스를 변경하고 프로그램을 수행한다.
		* 이는 결국 fork, execve라는 두가지 단계를 거치는 데, 이 중간에 자신의 파일 디스크럽터를 조작하여, 표준입력, 표준출력, 표준오류의 io방향을 변경할 수 있다.
		* ##### 파일 디스크럽터(fd)
			* 프로세스에서 열린 파일의 목록을 관리하는 테이블의 인덱스
			* 유닉스에서 모든 것은 파일이라고 한다. 이런 파일들을 접근할 때 파일 디스크럽터를 이용한다.
		* 이렇게 생성된 부모와 자식 프로세스는 다른 주소를 갖는다. 즉 한쪽이 변경되어도 다른 쪽에 영향을 주지 않는다.
		* ##### 부모와 자식 프로세스
			* 1. 주소는 동일하지 않다.
			* 2. 파일은 동일한 자원들을 공유한다.
			* 3. 자식의 초기 주소 공간(프로그램, 데이터, 스택)은 부모 프로세스를 복사, 하지만 분명히 다른 주소 공간
			* 4. 읽기만 가능한 메모리는 공유될 수 있지만, 쓰기가능한 메모리는 공유되지 않는다.
			* 5. 프로그램 내용은 동일하다.
	* #### 2.1.3 프로세스 종료
		* 종료의 조건
			* 1. 정상적인 종료(자발적)
				* 예로 컴파일러가 컴파일 완료하고 exit 등으로 끝났음을 알림
			* 2. 오류종료(자발적)
				* 컴파일 하기로 한 프로그램 파일이 없을 경우
			* 3. 치명적인 오류(비자발적)
				* 프로세스에 의해 유발된 오류, 예로 0으로 나누기, 존재하지 않은 메모리 접근등
			* 4. 다른 프로세스에 의해 종료(비자발적)
				* kill 명령어(한 프로세스가 다른 프로세스 종료할 때 사용, 단 권한 필요)
	* #### 2.1.4 프로세스 계층 구조
		* 부모, 자식 프로세스에서 
		* 자식 프로세스는 단 하나의 부모 프로세스만 가지고
		* 부모 프로세스는 여러 자식 프로세스를 가질 수 있다.
		* unix
			* unix에서는 init이라는 특별 프로세스가 자신에게 전달된 터미널 수 만큼 프로세스를 생성한다. 이 프로세스들은 로그인을 기다리며, 로그인 되면, 각자 명령을 받아들이는 쉘을 실행하면서 여러 프로세스를 생성하게 된다.
			* 즉 모든 프로세스는 init에 뿌리를 둔다.
		* windows
			* windows에서는 계층 구조가 없다.
	* #### 2.1.5 프로세스 상태
		* ![[Pasted image 20231009104728.png]]
			* running은 프로세스가 진행중이다.
			* ready는 프로세스가 실행가능하지만 사용할 수 없는 cpu가 없어서 일시적 대기
			* blocked은 cpu가 있어도 프로세스를 수행할 수 없는 상태.
			* 상태 전이
				* 1은 프로세스가 수행을 지속할 수 없음을 운영체제가 발견할 경우 혹은 프로세스 스스로 pause할 수도 있다
				* 2,3은 프로세스 스케쥴러에 의하여 발생한다. 2는 프로세스가 충분히 오래동안 수행했다 판단될 떄, 스케줄러가 다른 프로세스에게 cpu를 할당. 3은 다른 프로세스들이 충분히 할당되었고 다시 cpu를 할당해야겠다 판단되었을떄
				* 4는 프로세스가 기다리던 외부 이벤트가 발생했을 경우, 일단 ready상태로 가며, 만약 cpu가 비어있으면 바로 3으로 동작한다.
		* ![[Pasted image 20231009112040.png]]
			* 프로세스의 가장 하위 계층은 스케쥴러이다. 그 위에 다른 프로세스들이 존재한다.
			* 스케줄러는 모든 인터럽트 처리와 프로세스를 시작하고 중단하는 일을 한다.
	* #### 2.1.6 프로세스의 구현
		* ##### 프로세스 테이블,=프로세스 제어블록(=PCB)
			* ![[Pasted image 20231009112654.png]]
			* 프로세스 모델을 구현하기 위해(주소공간, 자원 집합등) 운영체제는 프로세스마다 프로세스테이블을 운영한다.
			* pcb에는 프로그램 카운터, 스택 포인터, 메모리할당, 열린 파일들의 상태, 스케줄링 정보, 프로세스가 준비 혹은 대기상태로 들어갈 때 저장되어야할 모든 정보 등을 저장한다.
		* ##### 하나의 cpu에서 다수의 순차 프로세스들이 유지되는 과정
			* 각각의 io마다 인터럽트 벡터(인터럽트 서비스 루틴(프로시져)을 가리키는 인터럽트 벡터 테이블에서 한 열)와 연관되어 있다.
			* 프로세스3이 수행중일때 디스크 인터럽트가 발생한다면
				* 인터럽트 하드웨어가 프로세스3의 pc,psw, 레지스터등을 스택에 저장한다.
				* 이후 인터럽트 벡터가 지시하는 인터럽트 서비스 루틴(소프트웨어)가 작동
				* 서비스 루틴에 의하여, 스택에 저장된 프로세스 정보를 프로세스의 pcb에 저장하고, 스택을 제거한다. 
				* 이떄 스택 포인터는 프로세스 핸들러에 이해 사용되는 임시 스택을 가리키도록 설정.
				* 위의 동작들은 어셈블리 언어로 처리되며, 저장같은 행동은 모든 인터럽트에 공통적을 사용된다.
				* 이후 인터럽트 나머지 작업(저장 이후의 작업, 보통 c언어로 작성됨)을 수행하는 프로시듀어를 호출한다. 
				* 이 프로시듀어는 몇몇 프로세스(인터럽트가 원하는 프로세스)를 준비 상태로 만들 수 있으며,
				* 이 후 스케줄러가 호출되어 어떤 프로세스를 수행할지 결정
				* 결정을 마치면 새로운 프로세스의 레지스터와 메모리를 적재하고 실행
		* ![[Pasted image 20231009203427.png]]
		* 왜 save state가 startio 사이에서 발생? 이는 정확하지 않다.
		* 일단 확실한 것은 os로 시스템 호출되었을 때,  꼭 모두 io에 접근하는 것은 아니고, 일부 처리만 os에서 하고 끝날 수 있다. 그럼 context switch(다른 프로세스로 전환)이 안 일어나므로, 기존 프로세스를 저장할 필요가 없다. 따라서 일부 처리하고 인터럽트 핸들러가 io에 접근해야 한다 판단하면 그때서야 pcb에 저장하는 것.
		* read도 context switch발생 안 할 수 있다.
	* #### 2.1.7 다중프로그래밍 모델