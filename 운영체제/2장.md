* \# 운영체제로 제어권이 넘어가는 세가지 경우
	* 1. 인터럽트 발생
	* 2. page fault 발생
	* 3. 시스템콜 호출출
  
* ## 2.1 프로세스
	* 프로세스: 
		* 실행중인 프로그램을 추상화 한 것. , 논리적으로 작성된 프로그램을, 데이터를 가져와 행하는 것
		* 프로세스는 job, task, sequencial process와 동일어이다.
	* 프로그램:
		* 실행 파일 그 자체이고
		* 정적이다.
		  
	* 병렬적인 활동을 다루기 위한 모델
		* 의사병렬성(pseudoparrallelism): 
			* 한 cpu가 한 프로세스에서 다른 프로세스로 빠르게 넘어가면서 각 프로세스를 짧은 시간동안 번갈아 가면서 수행해, 병렬 수행하는 거 처럼 보이게 하는 것.
			* 이는 실제 cpu가 여러개인 다중처리기 시스템과 구분된다.
		* 다중처리기(multiprocessor)
			* 실제 cpu가 여러개라서 한 번에 여러 프로세스르 다룬다.
			  
	* \# 다른 fault와 다르게 page fault는 수정가능하기에 blocked 되지 않고 os로 제어권이 넘어가게 된다.
	  
	* page fault
		* 메인 메모리의 용량으로 인해 모든 프로세스를 메모리에 두지 않고, 디스크에 보관하였다가 필요한 것을 꺼내쓰는데, 이 떄 메모리에서 사용하려는 프로세스가 존재하지 않는 상황이 page fault이다.
	* PID(process id)
		* 프로세스를 식별하는 고유 id로 부모와 자식은 다른 PID를 갖는다.
		  
	* #### 주소공간
		* ![[Pasted image 20231017162151.png]]
		* 이를 보면 한 주소 공간 안에 코드, stack, 데이터가 들어가 있다.
		* 스택은 동적할당을 위한 공간
		  
	* ### 용어 정리
		* #### PID
			* process id는 프로세스를 식별한다. 
		* #### PT(process table)
			* 프로세스는 process table의 entries들로 나타나 진다.
				* 즉 여기서 entries는 프로세스에 대한 모든 정보를 포함한다.
			* PT는 PCB(Process Control Block)과 동일어이다.
		  
		  
	* #### 2.1.1 프로세스 모델
		* 모든 소프트웨어는 순차 프로세스(=sequential process == process)로 구성되어 있고,
		* 각 프로세스는 pc(program counter), 레지스터, 변수들을 포함한다.
			* 프로세스가 포함하는 것은
				* 주소공간
				* 실행 코드
				* 데이터
				* 스택포인터(sp)
				* 프로그램 카운터(pc)
				* 레지스터
				* 시스템 소스(파일)
		* 한 cpu는 한 프로세스만을 처리하지만 ,빠르게 왔다갔다해서 동시에 처리하는 것처럼 보이는 것.
		* 다중프로그래밍(multi programming)
			* 프로그램 사이를 빨리 전환하는 것.
		* 특정 프로세스가 시작될 떄 논리적인 프로그램 카운터는 실제(물리적인) 프로그램 카운터에 적재 되어야 한다.
		* 프로세스는 프로그램, 입력, 출력, 상태를 가진다.
		* 또한 하나의 processor(처리기)에 여러 프로세스가 들어올 수 있다.
		* processor에 무엇이 들어올 지는 스케줄링 알고리즘을 따른다.
		  
		  
		  
	* #### 2.1.2 프로세스 생성
		* 매우 간단한 시스템은 시스템이 기동할 때 모든 프로세스를 만들어지도록 하나,
		* 복잡한 시스템은 운영 도중에 필요한 프로세스를 생성하고 종료 해야한다.
		  
		* ##### 프로세스 생성을 유발하는 네 가지 이벤트
			* 1. 시스템 초기화
			* 2. 실행중인 프로세스가 프로세스 생성 시스템 콜을 호출했을 경우
			* 3. 배치 작업의 시작, 즉 순차적으로 프로세스를 생성하고 종료
			* 4. 사용자가 프로세스 생성 요청
			  
		* ##### 전위 프로세스와 백그라운드 프로세스
			* 전위(foreground) 프로세스란 사용자와 소통하고, 이들을 위해 작업을 수행하는 프로세스
			* 백그라운드 프로세스(=demon)은 사용자와 연관되어 있지 않고, 미리 정해진 일을 하는 프로세스, 혹은 대기하다가 외부에서 요청이 들어오면 일을 하는 프로세스
			  
		* 프로세스가 프로세스를 생성하려면 시스템 콜을 해야한다. 왜냐면 생성은 운영체제가 하는 일인데, 프로세스가 운영체제 내부에서 돌아가는 게 아니니까
		* 마이크로 소프트 windows의 경우 프로세스가 시작할 때 윈도우를 갖게 된다. 윈도우는 프로세스를 수행한다.
		* 모든 새로운 프로세스는 기존의 프로세스가 프로세스 생성 시스템 콜을 불러서 생성한다.
		* 호출되는 프로세스는 1. 기존 프로세스 2. 키보드등의 시스템 프로세스, 3. 배치 관리자 프로세스 중 하나가 호출한다.
		* UNIX의 경우 새로운 프로세스는 fork를 통해 기존의 프로세스를 그대로 복사하면서 시작된다. 그럼 동일한 메모리 내용, 같은 환경 문자열, 동일한 열린 파일들을 가진다.
		* 이후 execve를 통해 생성된 프로세스를 변경하고 프로그램을 수행한다.
		* 이는 결국 fork, execve라는 두가지 단계를 거치는 데, 이 중간에 자신의 파일 디스크럽터를 조작하여, 표준입력, 표준출력, 표준오류의 io방향을 변경할 수 있다.
		  
		  * ### UNIX process creation
			  * 유닉스에서는 fork() 명령어를 통해 프로세스를 만든다.
			    
			  * #### fork()시스템 과정
				  * PCB를 새로 만들고 부모의 것으로 초기화 한다.
				  * 주소공간을 새로 만들고 부모의 것으로 초기화한다.
				  * 커널 소스를 부모의 것으로 초기화한다.
				  * 이 PCB를 ready queue에 넣어 실행되기를 기다린다.
				  * ![[Pasted image 20231017163530.png]]
				  * fork 명령어는 자식이 부모의 코드도 그대로 배끼므로 두 번 실행된다.
				  * 부모의 fork에서는 자식 pid가 리턴되고
				  * 자식프로세스 코드 안의 fork에서는 0이 리턴된다.
				  * 이를 이용해 if, else문으로 부모와 자식에서 각각 실행될 코드를 구별할 수 있다.
				    
			* 이렇게 fork를 하면 자식 프로세스는 exec() 시스템 콜을 통해 자식 프로세스가 실행할 프로그램을 가져온다.
			  
			* #### exec()
				* ![[Pasted image 20231017164820.png]]
				* 과정
					* exec 시스템 콜이 발생하면 현재 진행하던 프로세스를 멈춘다.
					* 새로 생긴 주소공간에 prog(프로그램)의 주소공간을 가져온다.
					* 이외의 값들을 초기화한다.
					* PCB를 ready queue에 넣는다.
		  
		* ##### 파일 디스크럽터(fd)
			* 프로세스에서 열린 파일의 목록을 관리하는 테이블의 인덱스
			* 유닉스에서 모든 것은 파일이라고 한다. 이런 파일들을 접근할 때 파일 디스크럽터를 이용한다.
		* 이렇게 생성된 부모와 자식 프로세스는 다른 주소를 갖는다. 즉 한쪽이 변경되어도 다른 쪽에 영향을 주지 않는다.
		  
		* ##### 부모와 자식 프로세스
			* 1. 주소는 동일하지 않다.
			* 2. 파일은 동일한 자원들을 공유한다.
			* 3. 자식의 초기 주소 공간(프로그램, 데이터, 스택)은 부모 프로세스를 복사, 하지만 분명히 다른 주소 공간
			* 4. 읽기만 가능한 메모리는 공유될 수 있지만, 쓰기가능한 메모리는 공유되지 않는다.
			* 5. 프로그램 내용은 동일하다.
			  
			  
			  
	* #### 2.1.3 프로세스 종료
		* 종료의 조건
			* 1. 정상적인 종료(자발적)
				* 예로 컴파일러가 컴파일 완료하고 exit 등으로 끝났음을 알림
			* 2. 오류종료(자발적)
				* 컴파일 하기로 한 프로그램 파일이 없을 경우
			* 3. 치명적인 오류(비자발적)
				* 프로세스에 의해 유발된 오류, 예로 0으로 나누기, 존재하지 않은 메모리 접근등
			* 4. 다른 프로세스에 의해 종료(비자발적)
				* kill 명령어(한 프로세스가 다른 프로세스 종료할 때 사용, 단 권한 필요)
				  
		* ##### Process Termination
			* 정상적인 종료
				* exit() 시스템 콜을 호출시킨다.
				* 프로세스의 마지막 statement 수행 후, 자발적으로 exit() 호출하여 프로세스를 종료시킨다.
				* 혹은 main함수가 리턴되면, 이 때도 exit()가 호출된다.
			* 비정상적인 종료
				* abort() 시스템 콜을 호출시킨다.
				* 부모프로세스가 종료되면, 자식도 exit()
				* 부모프로세스에서 자식 프로세스를 강제 종료 시킨다
				* 사용자가 kill 명령어를  통해 프로세스를 종료 시킨다.
			* 어떻게 종료되었던 무관하게 결국 모든 open된 descriptor를 close하고, 메모리를 비운다.
				  
				  
	* #### 2.1.4 프로세스 계층 구조
		* 부모, 자식 프로세스에서  자식 프로세스는 단 하나의 부모 프로세스만 가지고 부모 프로세스는 여러 자식 프로세스를 가질 수 있다.
		* unix
			* unix에서는 init이라는 특별 프로세스가 자신에게 전달된 터미널 수 만큼 프로세스를 생성한다. 이 프로세스들은 로그인을 기다리며, 로그인 되면, 각자 명령을 받아들이는 쉘을 실행하면서 여러 프로세스를 생성하게 된다.
			* 즉 모든 프로세스는 init에 뿌리를 둔다.
		* windows
			* windows에서는 계층 구조가 없다.
			  
			  
	* #### 2.1.5 프로세스 상태
		* ![[Pasted image 20231009104728.png]]
			* running은 프로세스가 진행중이다.
			* ready는 프로세스가 실행가능하지만 사용할 수 없는 cpu가 없어서 일시적 대기
			* blocked은 cpu가 있어도 프로세스를 수행할 수 없는 상태.
			* 상태 전이
				* 1은 프로세스가 수행을 지속할 수 없음을 운영체제가 발견할 경우 혹은 프로세스 스스로 pause할 수도 있다
				* 2,3은 프로세스 스케쥴러에 의하여 발생한다. 2는 프로세스가 충분히 오래동안 수행했다 판단될 떄, 스케줄러가 다른 프로세스에게 cpu를 할당. 3은 다른 프로세스들이 충분히 할당되었고 다시 cpu를 할당해야겠다 판단되었을떄
				* 4는 프로세스가 기다리던 외부 이벤트가 발생했을 경우, 일단 ready상태로 가며, 만약 cpu가 비어있으면 바로 3으로 동작한다.
		* ![[Pasted image 20231009112040.png]]
			* 프로세스의 가장 하위 계층은 스케쥴러이다. 그 위에 다른 프로세스들이 존재한다.
			* 스케줄러는 모든 인터럽트 처리와 프로세스를 시작하고 중단하는 일을 한다.
			  
		* ![[Pasted image 20231018165051.png]]
			* create
				* 이건 fork 등으로 생긴 프로세스가 exec을 통해 pcb를 ready queue로 넣은 상태
			* I/O, page fault, etc
				* 이러한 경우로 운영체제로 제어권이 넘어가, 프로세스가 block되며,
				* 이 때 io는  read 시스템 콜을 호출해 io컨트롤러를 동작시킨다.
			* 만약 한 프로세스가 무한루프를 돌면 cpu를 독점하게 된다. 근데 os는 이게 무한루프인 줄 모르므로, 주기적으로 interrupt를 통해 프로세스를 끌어 내린다. 
			  
			  
	* #### 2.1.6 프로세스의 구현
		* ##### 프로세스 테이블,=프로세스 제어블록(=PCB)
			* ![[Pasted image 20231009112654.png]]
			* 프로세스 모델을 구현하기 위해(주소공간, 자원 집합등) 운영체제는 프로세스마다 프로세스테이블을 운영한다.
			* pcb에는 프로그램 카운터, 스택 포인터, 메모리할당, 열린 파일들의 상태, 스케줄링 정보, 프로세스가 준비 혹은 대기상태로 들어갈 때 저장되어야할 모든 정보 등을 저장한다.
		* ##### 하나의 cpu에서 다수의 순차 프로세스들이 유지되는 과정
			* 각각의 io마다 인터럽트 벡터(인터럽트 서비스 루틴(프로시져)을 가리키는 인터럽트 벡터 테이블에서 한 열)와 연관되어 있다.
			* 프로세스3이 수행중일때 디스크 인터럽트가 발생한다면
				* 인터럽트 하드웨어가 프로세스3의 pc,psw, 레지스터등을 스택에 저장한다.
				* 이후 인터럽트 벡터가 지시하는 인터럽트 서비스 루틴(소프트웨어)가 작동
				* 서비스 루틴에 의하여, 스택에 저장된 프로세스 정보를 프로세스의 pcb에 저장하고, 스택을 제거한다. 
				* 이떄 스택 포인터는 프로세스 핸들러에 의해 사용되는 임시 스택을 가리키도록 설정.
				* 위의 동작들은 어셈블리 언어로 처리되며, 저장같은 행동은 모든 인터럽트에 공통적을 사용된다.
				* 이후 인터럽트 나머지 작업(저장 이후의 작업, 보통 c언어로 작성됨)을 수행하는 프로시듀어를 호출한다. 
				* 이 프로시듀어는 몇몇 프로세스(인터럽트가 원하는 프로세스)를 준비 상태로 만들 수 있으며,
				* 이 후 스케줄러가 호출되어 어떤 프로세스를 수행할지 결정
				* 결정을 마치면 새로운 프로세스의 레지스터와 메모리를 적재하고 실행
				  
		* ##### Context switch
			* 한 프로세스에서 다른 프로세스로 바뀌는 것은 context switch라고 한다.
		* ![[Pasted image 20231009203427.png]]
		* 왜 save state가 startio 사이에서 발생? 이는 정확하지 않다.
		* 일단 확실한 것은 os로 시스템 호출되었을 때,  꼭 모두 io에 접근하는 것은 아니고, 일부 처리만 os에서 하고 끝날 수 있다. 그럼 context switch(다른 프로세스로 전환)이 안 일어나므로, 기존 프로세스를 저장할 필요가 없다. 따라서 일부 처리하고 인터럽트 핸들러가 io에 접근해야 한다 판단하면 그때서야 pcb에 저장하는 것.
		* read도 context switch발생 안 할 수 있다.
		* read일 때도 main에서 돌아가던 프로세스는 running 상태이다. io 발생하는 게 확실시 되면 그 때서야 block 된다.
		* io 끝나면 interrupt 발생하여 A프로세스가 ready queue로 들어가고, 이 때 스케쥴링한다.
		  
		  
	* #### 2.2 스레드(thread, = lightweightprocess)
		* 스레드의 장점
			* 1. 다수의 프로세스를 사용하여 해결할 수 없는 문제를 해결해준다.
				* 한 프로세스 내에서 다수의 프로세스인 척 병렬적으로 제어 흐름을 가지는 것
				* 스레드들은 주소공간과, 프로세스 실행동안 모든 데이터를 공유한다.
				* 이는 다수의 프로세스를 사용하여 해결할 수 없는 문제를 해결 해준다.
			* 2.스레드는 프로세스 생성 제거보다 훨 빠르다.
			* 3.많은 연산 많은 io가 동시 존재하는 경우 스레드는 이러한 동작들을 겹치도록(유사병렬적으로) 수행할 수 있어 응용속도를 향상시킬 수 있다.
			* 4.병렬성을 제공하는 다수의 CPU를 가진 시스템에서 유용하다.
		* 예로 한 워드 프로그램(프로세스)를 사용하면서, 날라가지 않도록 스레드를 운영해 주기적으로 저장하게 할 수도 있다. 
		* 여기서 왜 다른 프로세스로 안하고 스레드로 하냐면, 공통의 데이터를 대상을 하기에
		  
		* ##### Finite-state marchine(유한 상태 기계)
			* 이는 각 연산마다 , 저장된 상태, 그리고 이 저장된 상태를 변경할 수 있는 이벤트가 존재하는 설계
			* 예로 병렬이 아닌 단일 스레드를 사용한다면, 차례차례 수행할 수 도 있지만, 사용하려는 데이터가 메모리에 없고 디스크에 있다면 기다려야한다.
			* 이를 해결하고자, 현재 disk에서 데이터를 가져오려는 스레드 상태를 저장하고, 다른 스레드를 처리하다가, 디스크에서 정보를 가져왔으면 스레드 재개, 이는 blocking이다.
		* 참고: blocking과 nonblocking
			* blocking
				* 이는 한 작업이 수행되는 동안에는 다른 작업은 진행하지 못하고 대기
			* nonblocking
				* 특정 작업이 수행중이더라도 이와 무관하게 바로 다음 작업 수행시키는 방식
				  
		* 스레드
			* 스레드는 cpu에서 실행되도록 스케쥴되는 객체고, 프로세스는 정보를  한 군데로 모은 것이다.
			* 스레드는 다음에 실행할 명령을 가리키는 프로그램  카운터를 가진다.
			* 작업변수를 저장하는 레지스터를 가진다.
			* 스택을 가진다.
			* 스레드는 다른 스레드와 주소공간과, 데이터를 공유한다.
			* 한 프로세스 내에서 스레드들은 동일한 주소 공간 전역 변수를 가지며, 즉 주소 공간 내 모든 메모리 주소를 접근할 수 있기에, 다른 스레드의 스택을 읽고, 기록하고 지울 수 있다.
			* 이를 막지않은 이유는 스레드들은 서로 협력하는 존재이기에, 서로를 막는 것은 불필요하기 때문이다.
			* 스레드는 프로세스와 동일하게 실행, 대기, 준비, 종료 상태를 가질 수 있다.
			* 프로세스 내에서 스레드가 작동하는 것이므로, 스레드가 실행되면 마찬가지로 이는 cpu를 점유하는 것
			* 각 스레드들은 다른 스택을 가져야한다.
				* ![[Pasted image 20231018191857.png]]
				* 스택에는 프로시듀어의 지역변수, 복귀주소를 저장해 놓는데, 이를 공유한다면 꼬일 수 있다.
				
			  
		* 다중 스레딩(multithreading)
			* 다수의 스레드가 하나의 프로세스에서 수행되는 것이 가능한 상황
			  
		* 스레드 명령어
			* thread_create
				* 이는 라이브러리 프로시듀어이고, 스레드를 생성한다. 매개변수로는 스레드 이름이 있다.
				* 스레드는 같은 공간에서 실행되므로, 스레드만의 주소공간을 갖는 일은 불필요하다.
				* 스레드는 계층관계(부모,자식)을 가질 수 있으며, 이 때 부모스레드는 자식 스레드의 스레드 식별자(thread identifier)를 갖게 된다.
			* thread_exit
				* 스레드를 종료시켜, 더 이상 스케줄 되지 않도록한다.
			* thread_join
				* 이 프로시듀어는 한 스레드가 끝날 때까지 호출한 스레드는 호출되지 않도록 한다.
				* 즉 특정 프로시듀어가 종료될 때까지 스레드는 블록된다.
			* thread_yield
				* 스레드가 자발적으로 cpu를 포기하여 다른 스레드가 실행될 수 있도록한다.
				* 스레드에는 clock interrupt가 없기에 매우 중요한 프로시듀어이다.
				  
		  * #### Posix 스레드
			  * 이를 Pthread라고 불리며, 스레드를 위한 표준이다.
			  * ![[Pasted image 20231018192836.png]]
			  * Pthread_craete는 함수의 리턴 값으로 스레드id가 리턴된다.
			  * Pthread_join은 스레드가 종료될 때까지 기다리는 데, 매개변수로 기다릴 스레드를 적어준다.
			  * Pthread_attr_init은  속성 구조체(스레드에 대한 정보를 가진 것)를 생성하고 필드들의 값을 설정한다.
		* ## 스레드를 구현하는 세가지 방법
			* 1. 사용자 공간  스레드(user level thread)
				* ![[Pasted image 20231018195541.png]]
				* 스레드를 사용자 공간에서 구현하여, 커널에서는 이를 모르게 한다.
				* 즉 커널 입장에서는 단일 스레드가 프로세스 내에서 진행하고 있는 거처럼 보인다.
				* 즉 스레드를 지원하지 않는 운영체제에서도 구현할 수 있다.
				* 런타임 시스템이 스레드를 관리한다. 런타임 시스템은 스레드 관리 프로시듀어(pthread등)의 모음이다.
				* 런타임 시스템 과정
					* 스레드가 다른 스레드의 종료를 기다리는 거와 같이, 스레드를 대기 상태로 만들지도 모르면 런타임 시스템을 호출한다.
					* 그럼 런타임 시스템은 반드시 스레드를 대기 상태가 되어야 하는 지 체크하고 그렇다하면, 스레드 테이블에 레지스터등을 저장한다.
					* 그 다음 스레드 스케줄러로 다음 스레드를 찾고, 새 스레드의 레지스터를 적재하고 돌린다.
				* Thread Table
					* 프로세스는 각 스레드를 위한 스레드 테이블을 가져야한다.
					* 스레드 테이블에는 스레드의 스택포인터, 프로그램 카운터,레지스터등 스레드를 위한 여러 속성을 갖고 있다.
				* 단점
					* 한 스레드가 시스템 콜을 하면, 프로세스 전체가 blocked 되므로, 다른 스레드들도 중단될 수 있다.
					* 스레드에 대한 클록 인터럽트가 없어서, 무한히 동작하는 스레드를 컨트롤할 수 가 없다.
					* 커널 스레드의 경우 cpu가 두개고, 비어있다면, 한 프로세스에 대한 두 스레드를, 두 cpu에서 동시에 돌릴 수 있지만, 유저레벨 스레드에서는 그게 불가능하다.
				* ##### jacket = wrapper
					* blocked 되면 안되므로, 시스템 콜이 호출될 지 미리 알 수 있으면 대응이 가능하다.
					* 이를 select 시스템 호출이 확인하여 있는 줄 알려준다.
					* read가 존재할 경우, 다른 스레드가 block되지 않을 경우에만 실행하고, 아니면 다른 스레드를 우선적으로 실행한다.
					* 이렇게 시스템 콜 주위에서 검사를 수행하는 코드를 자켓(래퍼)라고 한다.
			* 2. Os가 관리하는 스레드(kernel thread)
				* ![[Pasted image 20231018195608.png]]
				* 커널이 스레드에 대해서 알고 스레드를 관리한다.
				* 따라서 user level thread와 달리, 스레드 테이블이 프로세스에 존재하지 않고 커널에 존재한다.
				* 또한 런타임 시스템이 존재하지 않는다.
				* 스레드 생성 삭제는 커널이 관리하므로 시스템 콜을 통해 작동한다.
				* 만약 스레드가 블록되면 커널은 그 프로세스의 다른 스레드를 수행하거나, 혹은 다른 프로세스의 스레드를 수행할 수 있다.
					* user level 스레드는 무조건 같은 프로세스 내의 스레드만 수행했다.
				* 장점
					* 스레드가 시스템 콜을 하더라도 프로세스가 블록되지 않고, 커널이 다른 실행가능한 스레드를 실행시켜준다.
				* 단점
					* 스레드 연산(생성, 종료)이 빈번하다면 오버헤드가 크다.
	