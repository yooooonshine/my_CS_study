프로세스에 모든 정보를 저장하는 것은 매우 불편하다.
### 문제점
* 프로세스는 주소 공간이 제한적이어서 매우 큰 규모의 정보를 저장하지 못한다.
* 프로세스는 종료되면 데이터가 사라진다.
* 프로세스에 있는 정보는 동시에 다른 프로세스가 접급하지 못한다.
이러한 문제점을 해결하기 위하여 데이터를 디스크, 테이프, 광디스크에 저장하기도 하나 성능이 매우 낮다.

따라서 우리는 파일이라는 새로운 추상화를 사용하여 이러한 문제들을 해결한다.
## 파일
파일이란 프로세스에 의하여 생성된 정보의 논리적인 단위이다. 또한 디스크는 수백만 개의 파일을 가지고 있으며, 이는 서로 독립적이다.
프로세스는 기존의 파일을 읽을 수 있을 뿐만 아니라, 새로운 파일을 생성할 수 있으며, 이렇게 저장된 파일들은 영속적이어야 한다.

파일은 추상화된 메커니즘이다. 따라서 파일이 어디에 저장되고, 어떻게 실행하는 지에 대한 정보는 사용자가 알 필요 없다.
# 4.1.1 파일 명칭 부여
---
파일의 이름은 보통 한글자에서 여덟글자로 구성되며, 최대 255글자까지 가능하다.
Unix의 경우 이름의 대소문자를 구별하지만, MS-DOS의 경우는 구별하지 않는다.

a.html 등과 같이 마침표 다음에 나오는 부분을 파일 확장자(extension)이라고 부르며 파일의 종류를 가리킨다. Unix의 경우 파일확장자를 구분하지 않으며, 윈도우는 파일 확장자를 구분하므로 그에 대한 의미를 알아야 한다.
# 4.1.2 파일 구조
---
![[Pasted image 20231203151507.png]]
(a)의 경우 파일은 바이트의 모음이며, 운영체제는 파일의 내부 내용에는 관심이 없다. 이는 바이트 연속이므로 가장 높은 수준의 유연성을 제공하며, 사용자가 원하는 무엇이든 파일에 기록할 수 있다.
(b)의 경우 파일은 고정된 크기의 레코드의 연속이며, 특별한 내부 구조를 갖는다. 또한 읽기 연산은 하나의 레코드를 읽고, 쓰기 연산은 하나의 레코드를 변경하거나 추가함을 의미한다.
(c)의 경우 파일은 트리 구조로 구성된 레코드들을 가지며,각 레코드는 key 필드를 가져, 접근할 때 key를 통해 접근 가능하다.

하지만 우리는 주로 바이트의 모음으로 본다.
# 4.1.3 파일 유형
---
* 정규 파일(regular file): 사용자 정보를 가지고 있는 파일
* 디렉터리: 파일 시스템의 구조를 유지하기 위해 사용되는 시스템 파일
* 문자 특수 파일(Character special file): io장치와 연관되어 문자 io장치를 모델링하기 위해 사용된다.
* 블록 특수 파일(block special file): 디스크를 모델링하기 위해 사용된다.
### 정규 파일
정규파일은 주로 ASKII파일이나 이진 파일이다. 
### ASKII 파일
ASKII파일은 텍스트 행들로 구성되며 캐리지 반환이나 라인피드 마지막에 붙는다. 
많은 수의 프로그램이 ASKII 파일로 IO를 실행하면, 한 프로그램의 출력을 다른 프로그램의 입력을 쉽게 사용할 수 있다.

즉 쉽게 말하면 text file이다.
### 이진 파일
이진파일은 이해하기 어려운 무의미한 정보로 보이나, 적절한 포맷을 가지고 있어 운영체제가 실행한다.

즉 어플리케이션에 따라 동일한 글자를 a로 읽을 수도, b로 읽을 수도 있다.
# 4.1.4 파일 접근
---
초기 운영체제는 순차 접근으로 파일 접근을 지원했다. 순차 접근은 특정 지점을 읽으려면 파일 앞부분부터 순차적으로 읽어야 하며, 건너띄기가 불가능한 것이다.
하지만 파일을 저장하기 위해 디스크를 사용하면서, 파일의 레코드나 바이트의 순서를 바꿔서 읽거나, key값을 따라 레코드에 접근하는 것이 가능해졌다. 이를 임의 접근 파일(random access file)이라고 한다.

임의 파일 접근에는 두가지 기법이 존재한다.
1. 모든 읽기 연산마다 파일 내에서 읽을 위치를 지정하는 방법
2. seek라는 특별 연산을 통해, 위치를 지정하고, 거기부터 순차적으로 읽는 방법


# 4 디렉터리
---
파일을 관리하고 추적하기 위하여, 파일 시스템은 디렉터리 혹은 폴더를 가지고 있고, 많은 시스템에서 이들 역시 파일의 일종이다.
# 4.2.1 단일 레벨 디렉터리 시스템
---
![[Pasted image 20231203155028.png]]
이건 하나의 디렉터리에 모든 파일을 담는 것이며 이러한 디렉터리를 루트디렉터리라고 한다.

이러한 방법은 단순하고, 파일을 빨리 찾을 수 있다는 점이다.
# 4.2.2 계층적 디렉터리 시스템
---
서로 연관된 파일들을 하나로 묶을 수 있는 기법이 필요하며, 이럴 때 계층구조를 사용한다.
# 4.2.3 경로 이름
---
## 절대 이름 경로(absolute path name)
루트 디렉토리부터 파일까지의 경로들로 구성되어 있다.
예를 들어 /user/ast라면 루트 디렉토리에 존재하는 user 디렉토리 안의 ast를 의미한다.

여기서 /는 분리 기호라고 하며
윈도우에서는 \\로 구분하며, 리눅스에서는 /, MULTICS에서는 >로 구분한다.

또한 경로 이름의 첫 번째 글자가 분리 기호라면 이는 절대 경로를 의미한다.
## 상대 이름 경로(relative path name)
이것은 작업 디렉터리(현재 디렉터리)라는 개념과 같이 사용된다. 
즉 사용자는 한 디렉터리를 현재 디렉터리로 지정할 수 있다.
루트 디렉터리부터 시작하지 않는 모든 경로 이름은 상대로 간주한다.

예로 user가 작업 디렉터리라면
단순히 cd ast

위와 같이 상대 이름 경로는 시작이 분리 기호가 아니다.

* .(dot)는 현재 디렉터리를 가리킨다.
* ..(dotdot)는 부모 디렉터리를 가리킨다.

참고로 같은 레벨에서는 두 디렉터리가 같은 이름을 사용할 수 없다.

디렉터리는 일반적으로 다음과 같은 메타데이터를 갖는다.
* 디렉터리는 파일의 이름과, 파일의 속성들을 리스트로 갖는다.
* 속성들은 크기, protection, 디스크에서의 위치, 만들어진 시간 등을 포함한다.
디렉터리 리스트는 sorting되어 있지 않다. 

# 4.3.1 파일 시스템 배치
---
파일 시스템은 디스크 상에 존재한다. 디스크는 하나이상의 파이션으로 분할되어 사용되며, 각 파티션에는 독립적인 파일 시스템이 존재한다.
디스크 섹터 0번은 MBR(Master Boot Record)라 불리며 컴퓨터를 부팅하는 용도로 사용된다.
MBR끝에는 파티션 테이블이 존재하며, 여기에는 각 파티션의 시작과 끝 주소를 가지고 있다.
이 파티션 테이블에는 하나의 파티션이 활성(active)로 설정된다.

컴퓨터가 켜지면 BIOS가 MBR을 읽어 실행하며, 부트 블록이라고 불리는 활성 파티션의 첫 번째 블록을 읽은 후 실행한다.
부트 블록에 있는 프로그램은  해당 파티션에 존재하는 운영체제의 부트 프로그램을 메모리에 적재한다.
참고로 모든 파티션은 부트 블록부터 시작한다.

![[Pasted image 20231203163719.png]]
위와 같이 파일 시스템은 몇개의 항목을 가지고 있다.
* 슈퍼 블록(super block): 슈퍼 블록이란 파일 시스템에서 가장 중요한 정보들을 가지고 있다. 에를 들어 파일시스템 유형, 파일 시스템 내의 블록 개수등이 있다.
* Free space management: 여기에는 bit맵처럼 가용 블록에 대한 정보가 있다.
* i-node: 자료 구조의 배열로써, 파일에 대한 모든 것을 가진다.
* files and directoriesa:  기타 다른 디렉터리나 파일이 존재

# 4.3.2 파일의 구현
---
파일 저장 공간을 구현할 때 가장 중요한 것은 어느 블록이 어느 파일에 속하는 지 추적하고 관리하는 것이다.
## 연속할당
파일을 연속된 디스크 블록에 저장하는 것이다. 
즉 파일 A가 2.5개의 블록을 사용한다고 하면 앞에서부터 차례로 저장되며, 다음 파일은 4번째 블록부터 저장된다. 즉 3번째의 절반은 낭비된다.(internal fragmentation)

장점
* 파일의 시작 블록 위치와, 블록의 개수만 기억하면 되기에 구현하기가 매우 쉽다.
* 이 기법은 읽기 성능이 매우 뛰어나다. 왜냐하면 한 번의 동작으로 전체 파일을 디스크에서 읽을 수 있기 때문이다. 즉 한번 위치를 찾으면 계속 읽기만 하면 된다.
단점
* external fragmentation이 생긴다는 것이다. 예를 들어 파일들이 저장되어 있는 상태에서 중간의 몇 개의 파일이 제거된다면, 이 공간은 가용공간으로 남는다. 당장 디스크가 널널한 상태에서는 문제되지 않지만 디스크가 꽉 차면 가용 공간을 사용해야 한다. 이 떄 디스크 공간을 통합(재배치)하거나, 가용 공간을 재사용해야 하는데. 통합하는 것은 비용이 비싸고, 재사용하려면 공간에 파일 크기를 맞춰야 하며, 또한 파일 크기를 미리 알아야 한다는 단점이 있다.

이러한 단점 떄문에, 연속할당은 파일의 크기가 불변할 경우에 사용하면 좋은데 대표적으로 CD-ROM이 있다.
## 연결 리스트 할당
![[Pasted image 20231203171518.png]]
연결리스트를 이용해 블록을 할당하는 방법이다. 각 블록의 첫 번째 워드는 다음 블록을 가리키는 포인터로 사용되고 블록의 나머지 부분에 데이터를 저정한다.

장점
* 모든 디스크 블록을 사용 가능하다.(다만 여전히 파일의 마지막 블록에서는 internal fragmentation이 발생한다.)
* 디렉터리 엔터리는 파일의 첫번째 디스크 블록의 주소만 기억하면 되고, 블록의 포인터를 따라가면서 원하는 정보를 찾는다.
단점
* 디스크 읽기는 매우 느리며, 이러한 디스크를 포인터로 따라면서 찾는 것 또한 매우 느리다.
* 또한 대부분의 데이터는 2의 지수배로 읽거나 쓰도록 작성되어 있는데, 포인터가 블록의 어느정도를 차지 하므로, 2의 지수배를 알맞게 저장할 수 없다.

## 메모리에 존재하는 테이블을 이용한 연결 리스트 할당
기존에 블록에 있던 포인터 정보를 메모리로 빼서 FAT(파일 할당 테이블, File Allocation Table)을 구성하는 것이다.
![[Pasted image 20231203172512.png]]
위에서 파일 A는 4,7,2,10,12라는 5개의 블록에 저장되어 있고, 12에는 -1이 저장되어 있음을 통해 다음 블록이 없음을 인지한다.

장점
* 블록에 2의 지수배의 데이터를 저장할 수 있다.
* 블록의 포인터가 메모리에 존재하기에 접근이 매우 빠르다.
* 즉 dir entry는 하나의 블록 시작 number만 보유하면 된다.
단점
* FAT가 날라가면 디스크 전체 공간이 날라간다.
* FAT가 반드시 메모리에 전체 존재해야 하는데, 때로는 너무 많은 정보를 저장해야할 수도 있다.
예를 들어 디스크의 크기가 200GB이고 블록의 크기가 1KB이라면,
200GB / 1KB인 2억개의 블럭이 존재하고, 즉 이를 가리키는 2억개의 블럭 엔트리가 필요하다는 것이다. 한 엔트리가 4바이트라면 800MB의 FAT를 필요로 한다는 것이다.

위 문제를 해결하기 위하여 클러스트링을 사용할 수도 있다.
클러스트링이란 블록을 묶어 하나로 나타내는 것이다.
다만 할당 단위를 클러스트링으로 하면 빈 공간은 그대로 internal fragmentation이 된다.

## I-nodes(index-node)
각 파일마다 i-node라고 불리는 자료구조를 갖고,  이 inode는 파일의 속성들과 파일의 디스크 블록 주소를 갖는다.
![[Pasted image 20231203174047.png]]
이 그림과 같이 어레이가 존재하며, 어레이 안에는 Address of disk block이라고 해당하는 블록의 주소를 저장하는 것이다.
위의 FAT와 다른 점은 FAT는 전체 파일들에 대해 하나의 FAT만 가지고 있지만, 이는 각 파일이 각자의 inode를 가지고 있다는 것이다.
장점
* 모든 블록의 정보를 가지고 있을 필요 없이, 파일을 열면 해당 파일에 대한 inode만 메모리에 가져오면 이 파일의 모든 block에 접근할 수 있다는 것이다.
단점
* inode가 디스크 블록 주소를 저장할 수 있는 공간은 유한하며, 파일이 이 공간보다 많은 블록을 필요로 한다면 곤란.
해결책으로 inode 마지막 주소가 가리키는 블록에 데이터를 저장하지 않고 다른 디스크 블록들의 주소를 저장하는 것

### inode의 구조
![[Pasted image 20231203174833.png]]
위와 같이 inode에는 file information과 block에 대한 포인터가 저장되어 있다.
여기서 single indirect ptr이란 이 ptr이 가리키는 것이 데이터가 아니라, 다른 블록들의 ptr을 가지고 있는 리스트
한 블럭에 256개의 block pointer를 담을 수 있다면, doublce indirect ptr은
256 \* 256 개의 블럭에 대한 pointer를 가질 수 있다.
![[Pasted image 20231203175339.png]]
위 그림을 보면 inode는 data block을 가리키기도 하며, directory block을 가리키기도 한다.
또한 file a에 대한 inode 100은 내부에 여러 블록들에 대한 index를 가지고 있는 것을 볼 수 있다.
directory를 가리키는 inode를 따라가면 내부 구조가 나와 있다.
참고로 여기서 파일 a와 파일 b는 동일한 inode를 가리키고 있고 이를 통해, 둘은 같은 파일임을 알 수 있다.

참고로 여기서 inode 100의 link counter는 2이다. 이를 가리키는 포인터가 2개 있기에
![[Pasted image 20231203175830.png]]
이 그림은 위의 버전의 좀 더 섬세한 버전이다.
directory block을 보면 .과 ..이 존재하고 .은 현재 디렉토리를 가리키는 inode에 대한 위치를 갖고 있으며, ..은 상위 디렉토리의 inode 위치를 담고 있다.

여기서 mkdir 하면 디렉토리랑 inode가 하나씩 만들어지며, inode는 directory를 가리킨다.

참고로 lc는 기본이 2개이다.
예를들어 usr/dir의 경우, dir에 있는 .이 가리키는 것 하나와, usr에 있는 dir이 가리키는 inode가 있다.
여기서 dir에 하위 폴더가 추가될 때 마다 link counter는 1씩 증가한다.
# 4.3.3 디렉터리의 구현
---
파일을 읽기 전에 파일은 먼저 개방(open)해야 한다. 파일을 열 때 운영체제는 경로 이름을 이용하여 디렉터리 엔트리를 찾는다. 이 디렉터리 엔트리에는 디스크 블럭을 접근하는데 필요한 정보를 갖고 있다

디렉터리 엔트리는 다음 3가지 중 하나를 갖는다.
* 연속 할당 기법일 경우, 첫번째 블럭의 주소
* 연결 리스트 기법의 경우, 첫번째 블록의 주소
* 혹은 inode 번호

디렉터리의 주 기능은 ASKII 이름을 데이터를 찾기 위한 정보로 매핑하는 것이다.

그럼 파일의 속성(파일의 소유자, 생성 시간)은 어디에 저장할까?
### 디렉터리 엔트리에 저장
![[Pasted image 20231203193613.png]]
가장 간단한 방법은 디렉토리 엔트리에 직접 저장하는 것이다.
즉 디렉터리는 고정된 크기의 엔트리 리스트를 가지며, 각 엔트리에는 파일 이름, 파일 속성 구조체, 하나 이상의 디스크 블록 주소등을 갖는다.
### Inode에 저장
![[Pasted image 20231203193621.png]]
즉 디렉터리 엔트리에는 파일 이름하고 inode 번호만을 저장하고 있고, inode에 파일의 속성을 저장하는 것이다.

## Handling Long Flie Names
기본적으로 MS-DOS의 경우 파일은 1-8글자, 확장자는 1-3글자를 가질 수 있으나, 사용자는 원하는 경우 255글자까지 파일명을 지을 수 있다.
이를 위해서는 파일 속성에 따로 이름을 위한 공간을 만들 수 있지만, 대부분이 짧은 이름인 상황에서 특정 몇 개의 긴 이름을 위해 따로 공간을 만드는 것은 비효율적이다.

이를 위해 긴 파일 이름을 다루는 두 가지 방법이 있다.
* 정렬
* 힙

기본적으로 이 두 기법에서는 디렉터리 엔트리는 엔트리의 길이, 소유자, 생성 시간등의 기타 속성들로 구성된 정해진 포맷의 데이터가 있고,
이 헤더 뒤에 파일 이름들이 나온다.
### 정렬
![[Pasted image 20231203194336.png]]
정렬에서는 필요한 길이만큼 파일이름이 나오며, 마지막은 보통 0(여기선 x박스로 표현)으로 끝난다. 또한 음영을 가지 사각형처럼 워드 경계에 맞도록 정렬되어 있다.

단점
* 만약 파일이 제거되면 디렉터리에 가변 크기에 공간이 생긴다. 다만 이 디렉터리는 메모리에 있기 때문에 compacting이 비교적 쉽다.
### 힙
![[Pasted image 20231203194344.png]]
이는 디렉터리 엔트리 자체는 고정된 길이를 가지며, 파일 이름들은 힙 영역에 배치하는 것이다. 따라서 다른 파일 이름의 크기를 걱정할 필요 없다.
또한 워드 경계에서 시작할 필요가 없고, 따라서 음영처리된 빈 공간도 필요 없다.

## Speeding up the File Name Search
한 디렉터리에 수천개의 파일이 존재하면다면, 기존처럼 순차적으로 찾는 것은 시간이 오래 걸린다.
이를 위하여 
* 해시 테이블
* 캐시
두가지 방법을 사용할 수 있다.
### 해시 테이블
이건 각 디렉터리마다 해시테이블을 만들어, 파일을 해시 함수에 넣어 나온 결과 주소에 찾아가 연결리스트를 따라가며 파일을 찾아가는 방식이다.

매우 빠르게 검색할 수 있다는 장점이 있지만, 관리가 훨씬 복잡하다는 단점이 있다
## 캐시
검색 결과를 캐시에 남겨놓아서, 검색을 시작하기전에 파일 이름이 캐시에 존재하는 지 검색한다.


# 4.3.4 공유 파일
---
![[Pasted image 20231203195940.png]]
하나의 파일에 대해 B,C가 파일을 공유할 필요가 있을 수 있다. 
이를 위해 링크(link)라 불리는 자업을 통해 B의 디렉터리와 공유되는 파일이 연결된다. (이때부터는 Tree가 아닌  DAG(DIrected Acyclic Graph)이다.) 이 기법이 하드링크 기법이다.
이때 lc는 1증가한다.

만약 디렉터리에 디스크 블록 주소를 기록하는 방식이라면 문제가 발생할 수 있다.
* B가 C의 파일을 링크시킨다면 B에도 c파일에 대한 디스크 블록 주소를 기록하는 것이다. 여기서 B나 C중 하나에서 파일 뒤에 데이터를 추가시킨다면 새로운 블록을 필요로 하며, 이에 대해 B나 C중 자신의 디렉터리에 새로운 블록 주소를 추가할 것이다. 그럼 파일이 동일하지 않게 된다

이에 대한 해결책
### 방법 1
디스크 블록주소를 디렉토리에 저장하지 않고 inode라는 새로운 자료구조에 저장하는 것이다.

단점
* 만약 C가 파일을 제거한다면 B의 링크 파일은 빈 공간을 계속 가리키고 있고, 만약 이 공간에 다른 파일이 들어온다면, 추후 B가 파일을 열었을 때 다른 파일을 열게 된다. 그렇다고 이를 가리키는 디렉터리 엔트리를 모두 찾아내 제거하기는 쉽지 않다.
### 방법2
위의 링크기법을 하드링크라고 하면, 이건 심볼릭 링크기법이라 하는 것이다. 이는 B에 LINK 유형의 새로운 파일을 만들어, 이 안에 C파일 경로를 넣는 것. 운영체제가 이를 읽을 떄는 LINK 파일임을 인지하여, 내용의 경로 이름으로 검색을 하여 파일을 읽는다.
* 심볼릭 링크에서는 위와 같은 문제가 발생하지 않는다. 왜냐하면 심볼링 링크는 inode 포인터가 아닌, 경로 이름만을 갖고 있기에 파일이 삭제되면, 파일을 찾는 시도는 단순히 실패하기에 문제가 되지 않는다.
* 다만 심볼링 링크는 이를 위한 디스크 블록과 inode를 할당해야 하며, 또 다시 경로를 찾아가야 하므로 오버헤드가 발생하게 된다.


# 4.3.5 로그-구조 파일 시스템
---
메모리의 성능은 매우 좋아진 반면에 디스크의 성능은 그만큼 좋아지지 못해, 파일시스템이 병목현상의 원인이 되었다.
이에 대한 해결책으로 로그 구조 파일 시스템이 나왔다.

이는 디스크를 로그 형태로 사용하는 것이다.
즉 디스크 쓰기 요청은 버퍼에 모아 놓았다가, 하나의 세그먼트(메모리)로 구성해 디스크 끝에 기록한다.
이 세그먼트에는 i-node, 디렉토리 블록들, 데이터블록들을 포함한다.
각 세그먼트 시작 부분에는 세그먼트 요약이 존재한다.

이러한 파일에 access하기 위하여 inode-map을 사용한다. 즉 inode map에서 inode의 위치를 찾고, 이를 따라가서 블록을 찾아낸다.

# 저널링 파일 시스템(journaling file system)
이는 파일 시스템이 어떤 작업을 실행하기 전에 로그를 기록하고, 만약 작업을 하는 도중 시스템 크래쉬가 발생한다면, 로그를 보고 어떤 작업을 실행중인지 파악 후 다시 실행하는 것이다.

단계
1. 작업하는 단계를 나열한 로그 엔트리를 디스크에 기록한다.
2. 로그를 기록한 후 연산을 실행한다.
3. 연산이 끝나면 로그 엔트리를 지운다.
다만 이러한 저널링이 제대로 작동하려면 모든 연산은 멱등적(idempotent)이어야 한다. 즉 어떤 작업이 문제를 일으키지 않고 여러번 실행될 수 있어야 한다는 의미이다.

혹은 원자적 연산(atomic transaction)을 도입하여, 연산들이 완전 실행되거나, 전혀 실행되지 않게 해야 한다.

그럼 저널링 파일 시스템의 장점이 뭘까?

예를 들어 파일 삭제 과정을 보자
1. 파일을 디렉터리에서 삭제
2. I-node를 가용 I-node 풀로 반환
3. 파일이 차지한던 디스크 블록을 가용 디스크 블록 풀로 반환

만약 1을 실행 후 시스템 크래쉬가 난다면 i-node와 파일은 여전히 할당되어 있고 이들은 재사용이 되지 않고 다른 파일을 위해 할당될 수 없다. 왜냐하면 가용 풀에 없기 떄문이다. 이럴 경우 가용 자원이 줄어들 뿐 큰 문제가 생기지 않는다.

만약 순서를 바꿔 2->1->3으로 실행한다 하였을 때, 2만 실행되고 시스템 크러쉬가 난다면 다른 파일에서 이 i-node에 할당을 하게 되며, 그럼 두 파일이 동일한 i-node를 갖게 되므로, 즉 엉뚱한 파일을 가리키게 된다.

마약 순서를 바꿔 3->1->2순으로 실행되는데 3만 실행되고 시스템 크러쉬가 났다면, 다른 파일에서 이 블록을 사용하게 되며, 그럼 두 파일이 동일한 디스크 블록을 공유하게 된다.

즉 첫번째 상황이 아닌 경우에는 모두 심각한 문제를 일으킨다. 따라서 로깅을 이용하여 문제를 해결하는 것이다.

# 4.3.7 가상 파일 시스템
---
운영체제에서 서로 다른 파일 시스템을 다룰 때 문제가 있을 수 있다.
윈도우는 아예 서로 다른 파일 시스템을 통합시키지 않고 구분하여 사용하며
유닉스는 서로 다른 파일시스템을 합쳐서 사용한다.

UNIX에서는 다수의 파일 시스템을 하나의 정돈된 구조로 통합하기 위해 VFS(Virtual File System)을 사용한다.

가상 파일 시스템의 핵심 아이디어는 모든 파일 시스템의 공통적인 추상화된 부분을 추려 하위 계층을 만들고, 이 하위 계층에서 파일 시스템의 실재 부분을 호출하도록 하는 것이다.
이렇게 실제 파일 시스템과 접촉하는 부분을 VFS 인터페이스라고 한다.
VFS 인터페이스는 많은 함수를 가지고 있으며, 이에 대해 파일 시스템은 이 함수들을 구현해야 한다.



# 4.4.1 디스크 공간관리
---
파일을 한번에 연속적으로 저장하면, 접근은 빠를 수 있으나, 파일이 커졌을 경우 디스크 공간을 재할당해야 한다. 
따라서 파일을 절단하여 블록들에 나누어 저장한다.
## 블록의 크기
블록의 크기가 커지면 internal fragmentation문제가 발생한다.
블록의 크기가 작으면, 여러 블록들이 흩어져 저장되며, 그럼 탐색과 회전 지연 시간이 커진다.

## 가용 블록들의 관리
---
사용할 수 있는 블럭, 즉 가용 블럭들을 관리하기 위해서 두가지 방법이 존재한다.
1. 연결리스트
2. 비트맵
### 연결리스트
연결리스트 방법은 하나의 블록에는, 여러 가용 블록에 대한 리스트를 담고 있다.
예를 들어 하나의 블록 크기가 1KB이고 가용 블록 번호가 32bit인 경우,
둘을 나누면 256이 나오므로 즉 256개의 공간이 있다.  이중 255개의 공간에 가용 블록 번호를 넣고 마지막 하나의 공간에는 다음 블록을 가리키는 포인터로 사용한다.
### 비트맵
N개의 블록을 가진 디스크는 n비트로 구성된 비트맵을 사용하여 가용블록을 표현할 수있다.
즉 비트가 1이면 사용가능하다는 것이며, 0이면 사용중이라는 뜻이다.

위 두방법을 비교하였을 떄, 연결리스트는 많은 공간을 차지한다. 거의 대부분의 블록들이 사용되었을때, 연결리스트가 작아지며 이떄서야 비트맵과 크기가 비슷하다.
또한 연결리스트의 경우 사용하지 않는 블럭에 저장하기 때문에 추가  스페이스를 요구하지 않는다.


# 4.4.2 파일 시스템 백업
---
재앙이나, 실수로 인해 파일이 삭제될 경우를 대비하여 백업을 한다.
하지만 전체르 백업하는 것은 불필요하다, 백업이 필요없는 파일들도 존재하기에, 따라서 선택된 디렉토리 내에 있는 것만 백업하는 것이 바람직하다.

## 백업 방법
* incremental dumps: 처음에만 저장하고, 추후에는 변하는 것만 저장하는 것
* compressed format: 데이터를 압축해서 저장하면 용량은 줄어들지만, 압축파일이 조금만 손상되어도 전체를 읽을 수 없는 단점이 있다.
## 물리적인 덤프
이는 0번 블록부터 시작하며 마지막 블록까지 테이프에 전체를 기록하는 것

장점
* 단순하고 빠르다.

단점
* 사용하지 않는 블록을 백업하는 것은 의미가 없으나 이러한 블록들을 건너 뛰면, 디스크의 k번 블록과, 테이프의 k번 블록이 일치하지 않으므로, 블록의 번호까지 기록해야 한다.
* 만약 배드 블록이 os에 보이게 된다면 이에 접근할 경우 무한한 읽기 오류가 발생하게 된다.
* 특정 파일만 저장할 수 없다. 오로지 전체 저장만 가능하다.
## 논리적인 덤프
이는 특정 디렉토리를 시작으로, 트리구조를 따라가면서 백업을 하는 것.
지정된 날짜 이후에 변경된 모든 파일들과 디렉터리들을 덤프한다.

이 알고리즘은 변경된 파일이나 디렉터리를 가리키는 경로상의 모든 다른 디렉토리도 덤프한다.
왜냐하면 
1. a/b/c 경로를 삭제했을 경우, a/b/c/d인 d파일을 복원하려 하여도 경로가 없기에 복원할 수 없기 때문이다.
2. 이런 방식을 사용하면 복원 프로그램을 사용하여 한 컴퓨터에서 다른 컴퓨터로 파일 시스템 전부를 옮길 수 있기 때문이다.

덤프 알고리즘
![[Pasted image 20231205205906.png]]
이는 그림과 같이 inode를 담고 있는 비트맵을 사용한다.
1. 모든 변경된 파일을 표시하고, 변경과 무관하게 디렉토리도 표시한다.
2. 다시 순회하면서 어떤 디렉토리의 내부와 그 하위 디렉토리에서 변경이 없는 경우 디렉토리 표시를 지운다.(즉 파일을 지우는게 아니라 디렉토리!)
3. 이렇게 남은 디렉터리들을 덤프한다.
4. 파일들을 덤프한다.


# 4.4.3 파일 시스템 일관성
---
블록이 디스크에 다 기록되기 전에 시스템 크래쉬가 발생하면 이는 일관성을 상실한 모순된 상태를 갖게 된다.
만약 기록되지 않은 블록이 inode, 디렉터리블록, 가용리시트를 가진 블록인 경우 심각한 문제를 갖게 된다.

따라서 컴퓨터는 크래쉬가 난 이후 부팅되면 fsck 혹은 scandisk라는 유틸리티 프로그램을 실행하여 일관성을 검사한다.

일관성 검사에는 Block consistency check와 file consistency check라는 두 종류의 일관성 검사가 존재한다.
## Block Consistency Check
![[Pasted image 20231205211240.png]]
블록 일관성을 검사하기 위해 프로그램은 두 개의 테이블을 생성한다.
하나는 전체 파일을 순회하면서 각 블록들이 몇번이나 사용되었는지 카운트하기 위해 사용되며
하나는 가용리스트(혹은 비트맵)을 확인하여 각 블록이 가용 리스트에  몇 번 존재하는 지 세기 위한 것이다.

프로그램은 raw 장치를 통해 모든 inode를 읽고, 각 inode에는 파일이 사용하는 모든 블록 번호들의 리스트를 구할 수 있다.
또한 프로그램은 비트맵을 검사하여 미사용 블록을 조사한다.

이러한 결과로 정상정인 경우에는 두 테이블이 반대되는 결과가 나오며, 모두 0 아니면 1을 갖고 있어야 한다.

![[Pasted image 20231205211640.png]]
만약 크래쉬로 인하여 디렉토리에서 파일은 삭제했는데, 블럭을 가용블록풀에 넣지 않았다면  위와같이 사라진 블록이 생긴다.
이는 실제로 해를 끼지지는 않고 단지 공간을 허비할 뿐이다. 
이를 해결하기 위해서는 프로그램이 이를 가용 리스트에 추가하면 된다.

![[Pasted image 20231205212448.png]]
이는 가용블록이, 가용리스트에서 두 번 나온 상황이다.
이는 가용 리스트를 다시 설정하면 된다.
![[Pasted image 20231205212459.png]]
이는 가장 심각한 상황이다.
이는 하나의 데이터 블록이 두 개 이상의 파일에서 동시 사용되는 상황이다.
이는 블록을 가용블록풀에 등록한 상태에서 디렉토리에서 파일을 제거하기 전에 크래쉬가 나면 발생한다.
이럴 경우 다른 파일이 가용 블록임을 인지하여 블록을 사용하며
따라서 두 파일에서 같은 블록을 사용하게 된 것이다.

이 상황에서 하나의 파일을 지우면 1,1 인 상황이 된다.
이 상황에서 두개파일을 모두 지우면 0,2의 상황이 된다.

이에 대한 해결방법은 가용 블록 하나르 할당하여 블록 내용을 복사한 후, 하나의 파일이 이를 갖게 하는 것이다. 
다만 이는 파일 내용이 복사된 것일 뿐이므로 사용자가 확인하여 어떤 게 잘못된 것인지 판단해야 한다.


## Directory Consistency Check
이는 카운터 테이블을 사용한다.
루트 디렉토리부터 시작하여, 각 디렉토리를 조사하는 데, 각 디렉토리에는 파일에 대한 inode를 갖고 있으므로, inode에 대한 파일의 사용횟수를 의미하는 카운터를 증가시킨다.(참고로 심볼링 링크는 세지 않는다. 왜냐하면 이는 링크 카운터와 무관하기 때문이다.)
이렇게 만들어진 카운터 테이블이 존재하며,
이를 각 inode에 존재하는 링크 카운터와 비교한다.
일관성 있는 파일 시스템의 경우 리스트의 숫자와 inode의 카운터는 동일해야 한다.

만약 
링크카운터 > 디렉터리 엔트리 라면, 모든 디렉터리에서 파일을 삭제하여도 링크카운터가 0이 되지 않아 inode를 반환하지 않는다.
이는 디스크 낭비이다.  
따라서 inode의 링크 카운터를 정확한 값으로 설정함으로써 해결한다.

링크카운터 < 디렉터리 엔트리
예를 들어 이는 두 디렉터리 엔트리가 하나의 파일을 가리키고 있고,하지만 inode에는 하나의 엔트리만이 자신을 가리키고 있다고 기록된 상황이다.
이럴 경우 하나의 엔트리(파일)이 삭제되면 inode는 0이되면서 inode를 반환하고, 해당하는 블럭을 반환한다. 
그럼 남은 파일은 엉뚱한 블럭을 열게 될 수 있다.
이에 대한 해결책은 inode의 링크 카운터를 실제 자신을 가리키는 디렉터리 엔트리 수로 설정하는 것이

## 4.4.4 파일 시스템 퍼포먼스
---

disk sector == disk block

### 캐싱
디스크 접근 시간을 줄이기 위해 블록 캐시(or 버퍼 캐시)를 사용한다.
캐시라는것은 디스크에 있는 정보를 메모리에 저장하여, 빠르게 정보를 가져올 수 있게 하는 것이다.

만약 읽으려고 하는 데이터가 캐시에 존재한다면 디스크 접근 없이 캐시에서 가져올 수 있고
캐시에 존재하지 않는다면 블록을 읽어 캐시에 저장한 후 복사하여 사용한다.

일반적인 캐시 방법은 해시 테이블을 사용하는 것이다. 
즉 블록 주소와, 장치 번호를 해시의 key로 사용하여 해당하는 곳을 검색하는 것이다.

만약 캐시가 가득찬 상태에서 새로운 블록이 들어오려면 기존의 블록을 제거해야 한다.
이때 페이징과 유사하게 FIFO, 두번째기회, LRU와 같은 페이징 교체 알고리즘을 사용할 수 있다.

버퍼 캐시는 페이징과 다르게 , 상대적으로 덜 빈번하게 사용되기에 Full LRU를 사용할 수 있다. (페이징에서는 LRU를 사용하기에는 많은 부하가 있어 유사 LRU를 사용했었다.)

다만 버퍼 캐시를 사용하면 오히려 안 좋은 경우가 있다.
* sequential scans: 예를 들어 비디오같이 딱 한번만 읽고 안 쓰는 경우에는 오히려 버퍼 캐시를 사용하면 성능이 저하된다.
* random access: 버퍼캐시는 locality가 존재해야 hit가 많이 발생하는 데. 데이터  접근이 random하면 hit가 줄어들어 성능이 저하된다.

또한 버퍼 캐시에 넣어도 좋지 않은 블록들이 있다.
* inode블록은 버퍼 캐시에 있어도 좋지 않다. 왜냐하면 inode는 단 기간내에 두번 이상 실행되는 경우가 드물 기 때문이다.(temporal locality가 없다.)
* 파일 시스템 일관성에 필수적이 블록은 즉시 디스크에 쓰여져야 하기 때문에 버퍼캐시에 넣으면 안좋다.
* 또한 아무리 블록이라도, 너무 오래 캐시에 존재하면서 디스크에 안 쓰여지면, 시스템 크래쉬가 일어날때 모두 날라가기에 좋지 않다.

위 같이 시스템 크러쉬를 방지하기 위하여 UNIX에서는 두 가지 기법을 사용한다.
* sync 시스템 호출을 사용하여 변경된 블록을 디스크에 즉시 기록한다.
* 매 30초마다 undate 시스템 콜이 sleep에서 깨어나 백그라운드로 디스크에 기록해준다.


![[Pasted image 20231206142746.png]]
이는 버퍼 캐시를 full lru로 만든 것이다.
맨 앞에는 가장 덜 최근에 사용한 블록이 존재하고
맨 뒤에는 가장 최근에 사용한 블록이 존재한다.
블록이 참조되면 양방향 리스트 맨뒤로 위치 변경된다,

만약 블록이 파일 시스템 일관성에 필수적인 역할을 한다면 이는 즉시 디스크에 기록되어야 한다. 그렇지 않으면 파일 시스템이 손상될 확률이 높아지기 때문이다.