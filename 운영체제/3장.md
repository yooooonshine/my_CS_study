# 메모리 관리

* swapping: 프로세스 전체를 메모리에 넣어서 돌리는 것. 이 후 다 쓰면 전체를 다시 디스크에 저장
* virtual memory: 전체가 아니라 부분만 메모리에 있더라도 프로그램이 돌 수 있게 하는 기법

## 3.3 가상 메모리

base레지스터와 limit레지스터를 통해 주소 공간이라는 추상화를 하였지만, 최근에는 메모리가 커지는 속도보다 소프트웨어가 커지는 속도가 빠른 Bloatware 문제가 발생하였다. 이를 해결하기 위해서는 메모리보다 더 큰 프로레스를 실행하는 기법이 필요하다.

해결책
### 오버레이(Overlay): 
오버레이란 프로그램을 작은 단위로 나누어서 실행하는 것이다. 즉 프로그램이 오버레이 1,2,3,등으로 나뉘고 오버레이 관리자가 해당 부분을 실행할 때 메모리에 적재하여 실행한다. 여유 공간이 있는 경우 메모리에 모두 적재되어 실행되지만, 공간이 부족할 경우 오버레이1이 실행된 후 오버레이1을 오버레이2가 덮어쓰고 실행될 수도 있다. 이 때 디스크의 스왑 공간에 일부 오버레이들이 존재하면서 스왑 아웃, 스왑 인을 오버레이 관리자가 담당한다. 다만 오버레이 단위로 쪼개는 것은 프로그래머의 몫이였으므로 문제가 있었다.
### 가상 메모리(virtual memory): 
각 프로그램이 자신의 고유한 주소를 가지며, 이는 페이지(page)라고 불리는 조각들로 구성된다. 페이지는 연속된 주소를 갖으며, 이를 하드웨어는 페이지가 필요할 때 가상주소를 물리 메모리에 매핑시켜서 사용한다. 
물리 메모리에 페이지가 존재하는 주소공간을 접근한다면 바로 매핑되어 가져다 쓸 수 있다.
물리 메모리에 존재하지 않는 주소공간에 접근한다면 디스크에서 읽어 메모리에 적재시키고 실행한다.

### 3.3.1 paging
프로그램이 참조하는 주소는 가상 주소(virtual address)이다.
* 가상 메모리가 없는 컴퓨터는 가상 주소가 물리 주소가 된다.
* 가상 메모리가 존재하는 컴퓨터는 MMU(memory management unit)이 가상주소를 물리주소로 변환(매핑)한다.
  
페이지: 가상 주소 공간은 페이지라는 고정된 크기 단위로 이루어져 있다.
페이지 프레임(page frame): 물리 메모리에 존재하는 단위이다.
페이지와 페이지 프레임의 크기는 동일하다.

예로 페이지 크기4KB이라면, 메모리의 한 공간은 1Byte이므로 4096개의 주소를 갖는다. 만약  가상  주소 20500을 매핑해야하며, 페이지 5번은 페이지 프레임 3번에 매핑된다고하면, 페이지 5번은 20480~ 24575이고, 페이지 3번은 12288~ 16384이므로 20 + 12288 인 12308로 매핑된다.

만약 페이지 프레임에 존재하지 않는 공간, 즉 페이지에 absent비트가 켜져있는(= 페이지가 매핑되어 있지 않는) 공간을 접근하려한다면?
그럼 cpu에게 트랩을 발생시킨다(page fault). 그럼 페이지 프레임에 페이지를 적재시키고, 맵을 수정한 후 다시 실행한다.

만약 페이지 개수가 16개라고 한다면,  16bit가상주소는 4비트(16)의 페이지 번호(virtual page number = vpn)와 12bit의 오프셋으로 구성되며,  프레임이 페이지개수의 절반이라면, 페이지 테이블에 존재하는 3비트의 페이지 프레임 번호(pfn)으로 대체되면서 물리주소가 된다.

만약 페이지 크기가 4KB라면 이는 2^12B이므로 12개 비트의 오프셋이 존재하게 된다.

\# 0x00000000은 16진수이므로 한자리가 4비트이므로 이는 총 32비트의 주소공간을 의미한다.

### 페이지 테이블 엔트리
페이지 테이블: 페이지 테이블의 인덱스는 vpn을 그대로 사용하면 된다. 페이지 테이블 엔트리(pte)에는 그에 해당하는 pfn이 존재한다.
\# 페이지 테이블은 메모리에 저장된다. 이 페이지 테이블은 프로세스당 만들어진다.
![[Pasted image 20231120195951.png]]
위와 같이 페이지 테이블 엔트리는 보통 32bit로 구성된다. 이 32 비트에는
* page frame number
* protection bit: 이는 0일때는 읽기만 가능 1일때는 읽기, 쓰기 모두 가능
* present/absent bit: absent면 page fault를 의미
* modified bit(=dirty bit): 1이면 내용이 변경된 상태이므로 디스크에 저장해야함을 의미, 0이면 클린 상태로 바로 덮어써도 된다.
* referenced bit: 해당 페이지가 읽기, 쓰기로 접근되었을 때 1로 설정된다. 이름 참고하여 대체할 페이지를 선택한다.
페이지 테이블을 보관하는 두 가지 극단적 방법
* 단일 페이지 테이블을 하드웨어 레지스터 배열에 적재하는 방법:  즉 프로세스 전체를 하드웨어 레지스터 배열에 적재하고, 인덱스는 그대로 가상 페이지번호와 매칭된다. 이는 추가적인 메모리접근이 필요없다는 장점이 있지만, 구현 비용이 크다.
* 페이지 테이블 전체를 메모리에 적재하는 방법: 이는 페이지 테이블 전체가  메모리에 있으므로 페이지 테이블 시작 주소를 가리키는 하나의 인덱스만 가지면 된다.다만 이는 주소를 가져올 때마다 메모리에 접근하고 이를 통해 프레임에 접근하므로 느리다.

## 3.3.3 페이지 속도 향상
### TLB(translation lookaside buffer)
대부분의 프로세스는 몇몇 페이지만을 집중적으로 사용한다. 이 점을 통해 TLB라는 작은 하드웨어를 MMU 내부에 배치해 두어 몇몇의 페이지에 대한 정보만을 저장해 둔다. TLB 히트이면 여기서 프레임 넘버 가져와 오프셋이랑 결합하고 TLB MISS이면 페이지 테이블로 가서 엔트리를 가져와 TLB에 적재한다.
* TLB는 fully associative를 사용, 즉 병렬처리하여 모든 엔트리를 확인(모두 확인하므로 fully associative)
\# 참고로 이렇게 사용안하면서 메모리에 있는 페이지를 internal fragmentation이라고 한다.
\# 만약 pageFault가 일어나면 시간이 오래걸리므로 context switch되는데 그럼 페이지테이블, tlb도 모두 스위치되어야 한다. 즉 오버헤드가 생긴다. 이 상황에서 다시 시작하면 아예 restart한다. 파이프라인을 이어서 갈려면 그 상황을 모두 저장해야하는 데 이는 번거롭기 때문이다.
\# tlb와 page table은 일치해야한다. 하지만 실행동안에 항상 일치하지는 않는데 예를 들어 tlb가 쫒겨날때 업데이트를 하거나, pt가 바뀌면 tlb invalid 비트를 킬 수 있다.

### 다단계 페이지 테이블(multilevel page table)
![[Pasted image 20231120213138.png]]
페이지 테이블엔트리의 구역을 나누는 페이지 테이블을 추가한 것.
이로 인하여 모든 페이지 테이블을 항상 메모리에 유지할 필요가 없어진다.(필요한 페이지 테이블 일부분만 적재)

32비트라고 하면 4KB의 12비트 페이지 제외 20비트가 남는 데 10비트씩 TL1, TL2로 둔다.

예로  데이터 12292는 4096 \* 3 + 4이다. 그럼 4KB로 3번째 공간(TLB2 = 3)임을 의미하고 그럼 3은 1024 이하이므로 (2^10) TLB1은 1이다.
이를 32비트 가상 주소공간으로 변환하면 0x00403004가 된다.

이를 통해 얻을 수 있는 장점은 위 그림을 보면 텍스트,데이터,스택 3개의 테이블과 상위 테이블 하나 총 4개의 테이블만 필요하게 되므로 나머지를 모두 present/absent를 0으로 하여 메모리공간이 여유로워 진다.

참고로 상위 테이블에 접근하기 위해서는 주소가 필요하다. 따라서 page table register가 존재하고 이 ptr에 TL1을 합쳐서 메모리의 상위 페이지테이블에 접근하게 된다.

예시: 4KB pages와 4 bytes/PTE 라고 할 때 총 주소는 몇비트 필요할까?
일단 4KB pages는 주소공간 2^2 \* 2^10 개의 byte공간을 필요로 하므로 12bit이다. 또한 4KB page는 몇개의 엔트리를 필요로할까? 그럼 4KB / 4(bytes/PTE) 이므로 1KPTE를 필요로 한다. 즉 1024PTE가 필요하며, 이 PTE는 10비트로 주소를 나타낼 수 있으므로 도합 22비트를 필요로 한다.

![[Pasted image 20231122201432.png]]
vpn(virtual page number)는 왼쪽, frame넘버는 오른쪽. 
vpn 0번은 frame 3번을 가리킨다.

## 역 페이지 테이블(Inverted Page Tables)
![[Pasted image 20231122204535.png]]
기존에는 페이지에 대해 페이지테이블을 만들어서 프레임을 찾아갔다. 
만약에 가상 주소 공간이 32비트가 아니라 64비트라면 4KB 페이지를 사용할 경우 2^52개의 페이지테이블 엔트리가 필요하다. 이를 for문 돌리면서 찾는 것은 매우 좋지 못하다.
이를 해결하기 위해 역 페이지 테이블 방법이 존재한다.
이는 프레임만큼의 페이지테이블 엔트리를 만들어서, (pid, p)로 서치를 하는 것이다.
이는 어떤 프로세스의 어떤 페이지인지 (프로세스번호, 페이지번호)로 저장한다. 다만 이는 프레임 for문을 돌아야 하므로 2^12를 돌아야하므로 평균 2^11번을 돌아야 한다. 


## 해쉬 테이블
![[Pasted image 20231122204653.png]]
검색을 빠르게 하기 위하여 가상 주소를 기반으로 하는 해쉬 테이블을 이용한다.
즉 입력에 가상 주소와 pid를 넣어 나오는 주소에 페이지를 저장하는 것이다. 물론 두 가상 주소가 같은 해쉬 값을 가질 수 있으므로 페이지들은 체인으로 연결된다. 
또한 페이지 엔트리만큼의 슬롯이 있다면 평균적으로 슬롯하나당 페이지 하나를 갖게 되므로 빠른 속도로 접근 가능하다.
또한 체인이므로 virtualpage 구분을 위하여 virtual page number를 기록한다.
![[Pasted image 20231122204938.png]]
예를 들어 왼쪽과 같이 2^52개의 엔트리가 있다고 하였을 때, 이를 2^16의 엔트리로 매핑하자. 그럼 2^52개의 엔트리를 해시하여 2^16이내가 나오게  하면 된다.
# 3.4 페이지 교체 알고리즘
프레임이 가득찬 상태에서 페이지 폴트가 난 경우 페이지를 내쫒아야 한다. 또한 내보낼 페이지가 변경되어 있다면 디스트의 쉐도우 페이지에 기록해야한다.4

trashingl 페이지 fault가 계속 발생하여 프로그램이 진행을 못하는 상황

## 3.4.1 최적 페이지 교체 알고리즘(Belady's Algorithm)
가장 나중에 사용될 페이지를 교체하는 것. 허나 실직적으로 페이지가 다음에 언제 사용될 지 알 수 없으므로 구현 불가능한 알고리즘이다. 이 알고리즘은 다른 알고리즘과 비교하여 다른 알고리즘의 성능을 평가하는 데 사용된다.

## 3.4.2 NRU(not recently used) 페이지 교체 알고리즘

컴퓨터는 페이지마다 페이지 정보를 담는 상태 비트들을 유지한다.
* M비트(modified bit): 수정되었으면 1, 아니면 0을 지닌다. 
* R비트(referenced bit): 최근에 참조되었으면 1, 아니면 0을 지닌다.
이 비트들은 페이지가 참조 때마다 갱신되어야 하므로 하드웨어가 담당하며, 하드웨어가 1로 만들면, 추후 운영체제가 0으로 다시 만든다.

예로 읽기 요청한 페이지를 참조하게 되면 R비트를 설정하고 페이지 테이블 엔트리가 READ  ONLY 모드로 가리키도록 한다.
혹은 쓰기 요청한 페이지를 참조하게 되면 M비트를 설정하고 페이지 접근 모드를 READ/WRITE로 변경한다.
추후 클럭 인터럽트마다 주기적으로 운영체제가 R비트를 0으로 초기화 한다. 여기서 M비트는 초기화하지 않는다. 수정되었으면 반드시 디스크에 기록해야 하기 때문이다.

페이지 교체 알고리즘은 M, R비트를 기준으로 4가지로 구분한다.
* 클래스 0: 참조되지 않았고, 수정되지 않았다.
* 클래스 1: 참조되지 않았고, 수정되지 않았다. (즉 참조되면서 수정도 있었는데 클럭 인터럽트때 R비트가 0이 된 상태)
* 클래스 2: 참조되었고, 수정되지 않았다.
* 클래스 3: 참조되었고, 수정되었다.
페이지 교체 알고리즘은 숫자가 낮은 클래스를 우선적으로 페이지 교체한다. 즉 클래스 0이 있는 지 살펴 있으면 이걸로 교체하고, 없으면 클래스 1을 확인하는 식이다.

## 3.4.3 FIFO(first in first out) 페이지 교체 알고리즘
가장 오래된 페이지가 추후 안 쓰일 것이라고 예상하여 교체하는 알고리즘. 다만 스테디 셀러같은 페이지들도 frame out 될 수 있기에 사용 안 하는 알고리즘이다.
이는 리스트로 페이지들을 관리한다. 리스트 맨 앞부터는 가장 오래 전에 프레임에 등록된 존재하며, 리스트 맨 뒤는 가장 최신 페이지가 존재한다. 리스트 맨 앞에 존재하는 페이지를 교체한다.

참고로 fifo알고리즘은 페이지 프레임을 저장하는 메모리를 추가하여도, fault가 줄어든다는 보장이 없다.
![[Pasted image 20231122212153.png]]

## 3.4.4 second -chance 페이지 교체 알고리즘
FIFO 알고리즘을 보완한 것이다. 리스트에서 맨 앞을 버리려고 할 때 R비트를 확인한다.
* R비트가 0이면 버린다.(M비트가 1이면 디스크에 쓰는 작업도 한다)
* R비트가 1이면 리스트 맨 뒤로 넣으면서 시간도 현재 시간으로 리셋하고 R비트도 0으로 리셋한다.
즉 새로운 기회를 주는 것이다.
만약 모두 R비트가 1이면 한바퀴를 돌게 되고, 결국 맨 앞에 있던 것이 버려진다.

## 3.4.5 클록 페이지 교체 알고리즘(clock page replacement algorithm)
![[Pasted image 20231122211621.png]]
위의 fifo, second-chance 알고리즘은 리스트의 원소를 이동시켜야 하므로 성능의 이슈가 될 수 있다. 
클록 페이지 교체 알고리즘은 위와 같이 화살표를 페이지에 가리키도록 한다.
* 가리키는 페이지의 R비트가 0이면 이 페이지를 교체한 뒤, R이 0이 되고 화살표는 다음을 가리킨다.
* 가리키는 페이지의 R비트가 1이면 해당 페이지의 R비트를 0으로 클리어하고 다음 페이지를 가리키도록 한다.

## 3.4.6 LRU(Least Recently Used)
페이지 폴트가 발생하면 가장 오래동안 사용하지 않은 페이지를 교체하는 것
다만 이는 구현비용이 크다.

예를 들어, 리스트로 가장 최근을 리스트 앞, 가장 오래된 것을 리스트 맨 뒤에 저장한다고 해보자.  만약 특정 엔트리가 사용되었다면 리스트 중간에 있는 엔트리를 찾아 삭제하고 맨 앞에 저장하는 작업을 해야한다. 이는 부하가 많이 걸린다.

혹은 불특정 페이지가 참조될 때마다 1씩 증가하는 전역 카운트 값을 갖고, 페이지는 참조되었을 때 이 카운터를 저장시킨다. 페이지가 꽉 찬 상태에서 폴트가 나면 모든 엔트리의 카운트 값을 비교하여 가작 적은 카운트 값을 갖는 것이 가장 오래된 것으로 판단하는 방법이 존재한다.

## 3.4.7 소프트웨어 LRU

### NFU(Not Frequently Used)
이 값은 페이지마다 카운터를 유지한다.  클락 인터럽트마다 모든 페이지를 확인하여 참조 비트(R)이 1인 경우에 카운터를 1 증가 시킨다. 페이지 폴트가 나면 카운터가 가장 적은 것을 교체한다.
다만 이는 오래동안 사용되다가 더 이상 사용하지 않는 페이지가 존재하고 , 새로 들어왔지만 앞으로 사용될 페이지가 존재한다면, 후자를 교체하므로 성능적으로 이슈가된다.

가능한 유사 LRU
* 메모리에 모든 페이지에 대한 링크드 리스트를 구현하여, 가장 최신이 앞에, 가장 오래된 것을 뒤에,
* 모든 페이지 엔트리에 대해 카운터를 갖게 한다. 특정 주기마다 모든 페이지를 검사하여 참조되었으면 카운터가 1증가하고, 추후 전체적으로 카운터가 제일 작은 페이지를 교체한다.  이는 LFU(Least Frequently Used), NFU(Not Frequently used)를 이용한 것이다.
* LRU에 대한 n\*n비트 매트릭스를 사용한다.(패스)

### AGING 알고리즘
각 페이지마다 특정  개수의 비트를 가지며 초기에는 모두 0으로 세팅된다.
클록 인터럽트 마다 비트들을 오른쪽으로 1 쉬프트하고, R비트가 1이면 최상위 비트를 1로 설정한다.
페이지 폴트가 나면 가장 작은 수를 갖는 페이지를 교체한다.

이는 단순히 R 비트를 사용하는 것에 비해 과거가 기록되므로 더 오래된 것을 고를 수 있다. 또한 비트 수가 제한되어 있기에 특정 이상의 과거는 버려진다.
![[Pasted image 20231122220707.png]]

## 3.4.8 작업 집합 페이지 교체 알고리즘(working set page replacement algorthm)
### 요구 페이징(demand paging)
페이징 시스템에서 프로세스가 시작될 때 미리 적재되어 있는 페이지는 없다. 전역변수, 스택 접근, 명령 반입등을 시도할 때 페이지 폴트가 발생한다. 초반에는 모든 게 없으므로 페이지 폴트가 자주 발생하고, 이 후로는 비교적 적은 페이지 폴트가 일어나게 된다. 이렇게 필요에 따라 페이지를 적재하는 전략을 요구 페이징이라고 한다.
### 참조 지역성(locality of reference)
프로세스가 실행되는 각 단계에서 전체 주소 공간의 일부 페이지들을 집중적으로 참조하는 경향을 의미한다.
* temporal locality: 한번 호출된 것은 다시 호출될 가능성이 높다는 것
* spatial locality: 호출된 것이 있으면 보통 그 옆에 있는 것도 호출될 가능성이 높다는 것.

### 작업집합(working set)
이렇게 자주 참조하는 페이지들의 집합을 작업집합이라고 한다. 작업 집합이 모두 메모리에 올라가 있으면 페이지 폴트가 적게 일어나고, 메모리가 작업 집합을 모두 저장하지 못하면 페이지 폴트는 자주 발생하게 된다.

작업집합 크기(working set size)
이는 프로그램의 locality에 따라 좌우된다. 
* 지역성이 작다는 것은 특정 페이지가 적은 시간만 실행된다는 것이고, 즉 여러 페이지가 필요하게 되므로 큰 워킹셋이 필요하다
* 지역성이 크다는 것은 특정 페이지가 오랜 시간동안 실행된다는 것이고, 즉 적은 페이지가 필요하므로 작은 워킹셋이어도 된다.
### 트래싱
이렇게 페이지 폴트가 자주 발생하여 느려지는 현상을 스레싱(thrashing)이라고 한다.

### 선페이징(prepaging)
만약 다중 프로그래밍에서 프로세스가 변경되면 페이지들은 어떻게 해야할까. 이론적으로는 교체하지 않아도 페이지 폴트가 나면 알아서 교체하므로 아무것도 안해도 된다. 다만 이는 많은 페이지 폴트를 야기하므로 좋지 못하다.
따라서 미리 작업 집합을 메모리에 적재시켜놓는 것을 선페이징이라고 한다

### w(t,k)
![[Pasted image 20231122221726.png]]
이는 시간 t에 최근 페이지 k개를 봤을 때 작업 집합의 개수를 의마한다.
k는 최근에 참조된 순으로 k개를 갖는다는 것을 의미한다. 
프로세스가 처음 시작할 때는 페이지 폴트가 많이 일어나지만,계속 진행되면 페이지 폴트가 줄어든다. 이는 오래 보면 워킹셋이 특정 개수로 정해져서 페이지 폴트가 줄어듬을 의미한다. 같은 의미로 최근 k개를 적게 보면 워킹셋이 많지만, 넓게 보면 사용되는 워킹셋은 한정되어있으므로 w가 증가하는 폭이 줄어든다.
위 그래프는 시간 t에 k와 workingset의 관계 그래프이다.  위 그래프를 통해  작업 집합이 천천히 변한다는 것을 알 수 있고, 따라서 프로세스가 다시 시작할 때 어떤 페이지들이 필요할 지 예측 가능함을 의미한다.

### 작업 집합 모델
작업 집합은 최근 k개의 페이지에서 중복을 제거한 페이지들을 의미한다. 페이지 폴트가 나면 작업집합을 구해 여기에 없는 페이지를 교체하면 된다. 하지만 페이지 폴트가 발생할 때마다 이 짓을 하는 것은 부하가 크다.

따라서 이를 해결하기 위해 다양한 근사 방법이 존재한다. 그 중 하나가 k개의 메모리 참조 대신 실행 시간을 사용하는 것이다.
즉 최근 n 시간동안 사용한 페이지들로 정의한다.
이를 구현하려면 우선 각 프로세스 별로 실행 시간을 유지한다. 에로 특정 프로세스가 T에 시작하였고 T + 100까지 40의 시간만 사용하였다면 이 프로세스의 실행시간은 40이다. 이 숫자를 각 프로세스의 현재 가상 시간(current virtual time)이라고 한다.

### 현재 가상 시간 (타우)
프로세스가 시작되어 실제로 사용한 cpu시간
![[Pasted image 20231122223232.png]]

### 작업 집합 페이지 교체 알고리즘
각 페이지는 페이지가 마지막으로 사용된 시간(time of last use)과 R비트를 갖는다.
페이지 폴트가 발생하였을 경우
* R비트가 1이다 : 현재 시간을 time of last use에 기록한다. 이는 최근에 사용된 것이므로 교체  대상에 포함되지 않는다.
* R비트가 0이다 : 이는 교체 후보가 된다. 현재 시간 - time of last use > 타우 이면 이는 작업 집합에 포함되지 않으므로 교체한다. 또한 교체하고도 멈추지 않고 나머지 페이지들중 r이 1인 것만 세팅
만약 타우보다 작으면 교체 대상에서 제외되며 다른 교체 대상을 찾는다.
이렇게 이렇게 교체 대상을 찾으면서 r비트 0이면서  현재 시간 - time of last use가  가장 큰 페이지를 기록한다.
추후 R비트가 0인 페이지 중에 교체 대상이 없다면 바로 위 기록이 가장 큰페이지를 교체한다.
만약 R비트가 0인 페이지가 없다면 임의로 하나를 교체한다. 가능한 수정된 페이지보다 수정되지 않은 페이지를 교체한다.

## 3.4.9 WSClock 페이지 교체 알고리즘(working set clock page replacement algorithm)
![[Pasted image 20231126161137.png]]
WSClock 페이지 교체 알고리즘은 기존의 clock 알고리즘과 working set알고리즘을 합친 것이라고 볼 수 있다.
과정은
1.초기에는 환형 리스트가 비어있다.
2.페이지가 적재되면서 리스트에 추가되며 링구조를 형성하게된다. 또한 각 페이지는 R비트,M비트 Time of last use필드를 갖는다.
3.페이지 폴트가 나면 화살표가 가리키는 페이지부터 검사한다.
4.화살표가 가리키는 페이지가 
* R비트가 1이다. -> R비트를 0으로 바꾼 후 화살표를 다음으로 넘긴다.
* R비트가 0이면서, 나이가 타우보다 작다 -> 넘어간다
* R비트가 0이면서, 나이가 타우보다 크고 페이지가 수정되지 않았다 -> 교체한다.
* R비트가 0이면서, 나이가 타우보다 크고, 페이지가 수정되었다 -> 디스크에 상태를 기록해야 하므로 페이지 내용의 디스크 쓰기를 스케줄링 후 다음으로 넘어가(화살표를 넘겨) 계속한다. 참고로 단순 스케줄링만 하고 넘어가는 이유는 디스크 쓰는 것은 io접근이므로 시간이 오래 걸려 기다리지 않고 다른 것을 찾는 것이다.

만약 교체할 것을 찾았으면 거기서 멈춘다.
만약 너무 많은 페이지가 디스크 쓰기를 해야할 경우 랙이 걸릴 수 있으므로 최대 쓰기 페이지 개수를 제한하기도 한다. 최대 쓰기 페이지 개수가 되면 스케줄링을 안한다.

만약 화살표가 교체할 것을 못 찾고 한 바퀴를 돌게 된다면?
이 때는 두가지 케이스가 있다.
* 최소한 하나의 쓰기가 스케줄링 되어 있는 경우 -> 이 경우는 쓰기가 완료되어 M비트가 0이되어 교체될 것을 찾을 동안 계속 돈다.
* 아무런 쓰기도 스케줄링 되어 있지 않는 경우-> 현재 화살표가 가리키는 페이지를 교체한다.
* 

## 3.5 페이징 시스템의 설계 이슈
페이징 알고리즘을 알고 있어도 실제 적용하는 것은 다른 문제다.
잘 적용하는 방법을 알아보자.
## 3.5.1 지역 전역  할당 정책
![[Pasted image 20231126162904.png]]
페이지를 교체 해야한다면 해당 프로세스가 가지고 있는 페이지 중에서 교체해할까 아니면 전체 프로세스 중에 선택해서 교체해야할까?

* 지역(local) 페이지 교체 알고리즘
자신의 프로세스(A) 내에서 페이지 폴트가 났을 경우 A에 해당하는 페이지 중 하나를 교체한다. 
이로 인하여 프로세스별로 할당되는 페이지를 고정시킬 수 있다.
* 전역(global) 페이지 교체 알고리즘
전체 프로세스의 페이지들에 대하여 페이지를 선택해 교체한다.
실행중인 프로세스들의 요구에 따라 동적으로 페이지를 할당할 수 있어
프로세스에게 할당된 페이지 프레임 수가 상황에 맞게 적절하게 변한다.

참고로 위의 페이지 교체 알고리즘 일부는 오직 지역에서만 의미하는 경우도 있다. 예를 들어 작업 집합과 WSClock 알고리즘의 경우는 반드시 지역에서 교체할 것을 골라야 한다. 왜냐하면 작업 집합이라는 건 같은 프로세스 내부에서만 의미가 있기 때문이다.

위 그림은 지역,전역일때 교체를 표현한 것이다.
(a)의 상황에서 A프로세스가 A6페이지에 대한 페이지 폴트가 났을 경우 지역은 A중 가장 오래된 A6을 교체한다.
전역은 전체 페이지중 가장 오래된 페이지 B3를 교체한다.(참고로 age는 참조된 시간이다. 즉 2가 가장 오래된 것이다.)

만약 프로세스의 실행에 따라 작업 크기가 변하는 경우에는 전역 알고리즘을 사용하는 것이 좋다. 지역으로 하면 워킹 셋이 적은 프로세스는 메모리 비를 하게 되고, 워킹 셋이 큰 프로세스는 thrashing이 발생할 수 있다.

전역 알고리즘을 사용하는 경우에는 aging bit를 사용하여 각 프로세스의 작업 집합의 크기를 모니터링 할 수 있으나, 작업 집합의 크키가 마이크로 초 단위라면 밀리초 단위의 클록 틱은 정밀하게 예측하지 못하므로 스레싱을 야기할 수 있다.

### page fault frequency(PFF)
전역 알고리즘을 사용한다면 각 프로세스가 초기에는 프로세스 크기에 비례하여 페이지를 할당하고,  실행이 되면서 동적으로 추가 할당/반납할 수 있다. 이 할당을 제어하는 방법이 PFF이다.
PFF는 어떤 페이지를 교체해야 하는 정보를 담고 있지 않고, 오직 할당 집합의 크기를 제어하는 기능이다.

![[Pasted image 20231126164616.png]]
PFF의 기본 원리는 할당된 페이지의 개수가 커지면 페이지 폴트율이 감소하는 것을 이용한다. 그럼 반대로 페이지 폴트율이 커지면 페이지를 추가로 제공하며, 페이지 폴트율이 작으면 페이지를 할당하면 된다. 위 그림은 A라는 페이지 폴트율 상한선을 넘으면 페이지를 제공하고, B라는 페이지 폴트율 하한선을 넘으면 페이지를 줄이는 것을 의미한다.

참고로 페이지 폴트율은 초당 페이지 부재 결함 횟수를 세기만 하면 구할 수 있다. 다만 오직 최근 1초동안의 페이지 폴트율을 반영하는 것은 평균을 고려하지 못하므로, (1초전까지의 평균 페이지 폴트율 + 1초동안의 페이폴트율)/2를 사용할 수도 있다.



## 3.5.3 페이지 크기
페이지 크기는 운영체제가 설정할 수 있다.
페이지 크기는 큰 것이 좋을까 작은 것이 좋을까?

텍스트의 같은 경우 데이터의 크기가 가변적이고, 페이지 사이즈를 다 못 채우는 경우가 많다. 평균적으로 절반정도 사용하지 않는다.
그래서 n개의 세그먼트가 존재하고 페이지 크기가 p라면 평균 n\*p/2만큼 낭비가 된다.
이를 internal fragmentation(내부 단편화)라고 한다. 
이 때 페이지 크기 p를 줄인다면 internal fragmentation이 줄어들게 된다.

즉 페이지 크기가 줄어들면 공간 낭비가 줄어든다.
반면에 페이지 크기가 줄어들면 그만큼 페이지 수가 늘어나며 페이지 테이블 크기가 커지게 된다.
또한 프로세스가 context switch될 때에는 페이지 테이블이 하드웨어에 적재되어야 하는데, 이는 페이지 테이블이 커지면 그만큼 시간이 더 걸리게 된다.

![[Pasted image 20231126171536.png]]
위의 그림은 페이지 크기와 그에 대한 오버헤드 관계이다.
s가 프로그램의 크기, p가 페이지 크기라면, s/p 개의 페이지가 필요하며
e가 페이지테이블 엔트리 하나의 크기라면 s \* e/p 크기의 페이지 테이블을 필요로 한다.
p/2는 마지막 페이지는 평균 절반만 사용하므로 이에 대한 부하를 의미한다.

## 3.5.4 명령어와 데이터 공간 분리
![[Pasted image 20231126172140.png]]
대부분의 컴퓨터는 프로그램과 데이터를 같은 주소공간에 유지하지만, 경우에 따라 주소공간이 부족하여, 프로그램과 데이터를 서로 다른 주소공간에 저장할 수도 있다.
이를 각각 I space(Instruction space)와 D space(data space)라고 한다.
따라서 이 프로세스의 데이터가 필요하면 D space만 접근할 수 있다.

## 3.5.5 공유 페이지
여러 사용자들이 동시에 같은 프로그램을 실행하는 경우, 메모리에 같은 페이지 두개를 유지하는 것 보다, 페이지를 공유하는 것이 더 효율적이다.

다만 이 때 중요한 것은 오직 읽기 전용 페이지만 공유 가능하고 데이터는 공유할 수 없다는 것이다. 이 점을 위의 명령어와 데이터 공간 분리를 사용하면 좋다.
즉 여러 프로세스들이 D-space는 따로 갖고 있으면서, I-space는 서로 공유하게 하는 것이다.
즉 한 프로세스는 두 개의 포인터를 갖고 있으면서 하나는 공유되는 I-space를 가리키며, 하나는 개인의 D-space를 가리키는 것이다.


### Copy-On-Write(카피 언 라이트)
프로세스를 fork할 때에는 복사를 하지 않고, 부모와 자식 프로세스 모두 동일한 텍스트와 데이터를 공유하도록 한다. 이 때 모드는 Read only모드인데, 만약 한 쪽에서 write 명령어가 들어오면 운영체제에 트랩이 걸린다. 그럼 쓰려는 데이터가 저장된 페이지에 대한 복사가 일어나고, 그럼 각각의 프로세스는 고유한 페이지를 가리키게 된다. 또한 모드도 read-write모드가 된다. 


### 공유 라이브리러(shared libraries)
라이브러리 함수같은 경우는 데이터를 변경할 수 없고 오직 일기 전용이므로 여러 동일한 페이지를 갖게 할 필요없이, 페이지를 공유시킨다.


### 파일 매핑
메모리 맵 파일(memory-mapped file)은, 파일이 디스크에 있기에 읽고 쓰는 작업은 디스크를 거치면 성능이 저하될 수 밖에 없기에, 이를 메모리(가상 메모리)에 올리고, 메모리에서 읽고 쓰는 작업을 한 뒤, 쓸 일이 없으면 수정된 내용을 파일에 기록하는 것이다.

## 3.5.8 클리닝 정책
### 페이지 데몬
이는 주기적으로 메모리의 상태를 검사하여 관리하는 백그라운드 프로세스이다.
가용 페이지가  적다면 페이지 교체 알고리즘을 이용하여 페이지를 제거한다. 물론 페이지 변경 내용은 디스크에 쓰여진다.

참고로 가용 페이지란 현재 시스템에서 할당되지 않은 페이지를 의미한다.


## 3.6 구현 이슈

## 3.6.1 페이징과 관련된 운영체제 작업
운영체제가 페이징 관련  작업을 하는 경우는 주로 4가지이다. 프로세스를 생성할 때, 프로세스를 실행할 때, 페이지 폴트가 발생할 때, 프로세스가 종료될때 이다.

* 프로세스가 생성될 때
프로세스가 생성되려면, 운영체제는 얼마나 큰 공간을 프로그램과 데이터를 위해 할당할 지 결정하며 이를 위한 페이지 테이블을 생성한다. 또한 페이지 테이블을 위한 공간이 메모리에 할당되고 초기화 된다.  페이지가 스왑 아웃될 경우를 대비하여 디스크에 스왑 공간도 할당되어야 한다.(스왑 공간에는 프로그램의 텍스트와 데이터로 초기화되어 페이지 폴트가 나면 바로 가져올 수 있게 한다.) 또한 페이지 테이블과 디스크의 스왑 공간에 대한 정보를 프로세스 테이블에 기록해야한다.

* 프로세스 실행될 때
프로세스가 실행되려면 MMU가 새 프로세스를 위해 리셋되고,MMU안의 TLB에 존재하던 정보를 제거하기 위해 flush를 한다. 새로운 페이지 테이블을 설정하는데 , 이 주소를 하드웨어 레지스터에 저장한다.
참고로 이후 선택적으로 페이지 일부를 메모리에 적재시켜 페이지 폴트를 줄일 수 있다.

* 페이지 폴트가 발생할 때
페이지 폴트가 발생하면 페이지 폴트를 야기한 페이지가 디스크 공간 상에서 어디 있는 지 알아야 하므로 하드웨어 레지스터를 읽어 base 주소를 가져온다. 또한 이렇게 가져온 페이지를 프레임에 저장하려면 페이지 프레임이 확보되어야 하며 이를 위해 페이지 교체도 할 수 있다. 페이지가 교체되고 저장까지 완료되면 프로그램 카운터를 페이지 폴트를 야기한 명령을 가리키도록 하여 다시 실행한다.

* 프로세스가 종료될 때
프로세스가 종료되면 그 프로세스의 페이지 테이블, 디스크공간(스왑 공간), 페이지등을 반납해야 한다.
참고로 특정 페이지가 다른 프로세스와 공유중이라면, 반납하지 않고, 이 페이지를 사용하는 마지막 프로세스가 종료될 때 반납한다.


## 3.6.2 페이지 폴트 처리(page fault handling)
1. 하드웨어는 커널에게 트랩을 발생시키고, 현재의 프로그램 카운터(PC)를 스택에 저장하고,현재 명령의 상태와 같은 정보를 특별 CPU레지스터에 저장한다.
2. 어셈블리 코드를 실행하여 범용 레지스터 내뇽과 휘발성 정보를 저장하여 추후 트랩이 끝나고 복구할 수 있도록 한다. 이 후 어셈블리 코드는 운영체제를 호출하여 페이지 폴트를 처리할 수 있게 한다.
3. 호출된 운영체제는 페이지 폴트가 발생했음을 인식하고, 어느 가상 주소에서 페이지 폴트가 일어났는 지 알아야한다. 이 때 두가지 방법이 존재한다. 첫 째 페이지 폴트가 날 당시에 시스템이 하드웨어 레지스터에 페이지 폴트가 난 가상 주소를 기록하고, 운영체제가 이를 확인하여 알아낸다. 혹은 하드웨어 레지스터가 없는 경우에는 프로그램 카운터를 통해 페이지폴트를 야기한 명령어를 가져오고, 이를 분석하여 페이지 폴트가 난 가상주소를 알아낸다.
4. 가상 주소를 파악하면 운영체제는 그 주소가 유효한 지 판단을 하고, 접근 권한이 있는 지를 체크한다. 만약 체크에 실패하면 프로세스에게 시그널을 보내거나 종료시킨다. 체크에 성공하면, 가용한 페이지 프레임이 있는 지 조사한다. 없으면 교체 알고리즘이 동작하여 교체할 페이지를 선택한다.
5. 만일 교체하려고 선택한 페이지 프레임이 수정된 것이라면, 디스크에 쓰기 요청을 한다. 그럼 이 프로세스는 당분간 사용할 수 없으므로 context switching이 일어나 다른 프로세스가 실행된다. 쓰기가 완료되는 동안 이 페이지 프레임은 busy 상태로 표현하여 다른 목적으로 활용하는 것을 금지한다.
6. 페이지 프레임 상태가 클린하다면(클린하게 된다면), 요청한 페이지가 디스크 어디에 있는 지 확인하고, 이 내용을 페이지 프레임에 적재하도록 디스크 연산을 스케줄링한다.
7. 페이지가 페이지 프레임에 적재되면 디스크 인터럽트가 발생하게 되며, 그럼 페이지 테이블에 변화를 반영하고, busy 상태이던 페이지 프레임은 normal로 되돌린다.
8. 기존의 프로세스를 다시 실행한다.



\# 참고로 가상 주소가 유효하다는 것은 가상 주소가 프로세스 주소 범위 내부에 있다는 것이다.
\# 참고로 메모리 접근 권한이 있는 지를 파악하는 것은, 메모리는 쓰기, 읽기, 읽기/쓰기 모드 등 모드가 존재하는 데. 읽기 모드인 메모리를 쓰려고 한다면 접근 권한에 없는 것이다.
\# 참고로 가상 주소가 유효하지 않은 페이지 테이블 엔트리를 갖는다는 것은 가상 주소에 해당하는 페이지 테이블 엔트리가 존재하지 않거나(이는 물리 메모리에 적재되지 않은 경우), 페이지 테이블 엔트리의 valid 비트가 0인 경우이다.


## 3.6.4 페이지 락
I/O와 연관된 페이지에 락을 설정하여 교체되지 않도록 하는 것.
왜냐하면 I/O와 연관된 페이지가 교체되면 데이터 일관성에 문제가 생기기 때문이다.

## 3.6.5 백킹 스토어(예비 저장장소)
메모리에서 교체된 페이지들은 디스크 어디에 저장될까?
이는 디스크 내부 별도의 스왑 파티션에 저장한다. 이는 파티션의 시작 주소에 상대적인 블록번호로 전체 공간을 관리한다.

시스템이 처음 부팅되면 스왑 파티션은 비어 있는 상태며, 메모리에 이를 관리하기 위한 자료 구조가 생성된다. 이 자료구조의 가용 공간의 시작을 파티션의 시작 주소로 하며, 가용 공간의 크기는 전체 파티션의 크기로 설정한다. 프로세스가 생성될수록 프로세스의 크기만큼 가용 공간의 크기는 줄어든다. 또한 프로세스가 끝나면 할당되었던 가용공간은 반납된다.

각 프로세스별로 스왑공간의 어디에 저장되어  있는 지 정보를 프로세스 테이블에 저장해 놓는다. 따라서 가상 주소의 오프셋과 스왑공간의 주소를 합치면 페이지 주소가 나온다.
프로세스가 실행되기 전 스왑 공간은 초기화 되어 있어야 하는 데 간단하게 두가지 방법이 존재한다.
* 첫째, 전체 프로세스 이미지를 스왑 공간에 복사해두고, 필요할 때마다 메모리로 적재하는 방식
* 두번째, 전체 프로세스이미지를 메모리로 적재하고, 필요할 떄마다 페이지를 스왑공간으로 스왑 아웃한다.
혹은 극단의 스왑 관리 기법으로 , 프로세스가 생성될 때 스왑 공간을 전혀 할당하지 않고, 페이지 교체가 발생하였을 떄, 스왑 공간을 각 페이지 별로 동적 할당하는 방법이다.(즉 스왑공간이 아예 없었다가 페이지 교체가 나면 그만큼의 공간을 만들어 사용하는 것) 즉 이 방법은 프로세스가 스왑 공간에 연결되어 있지 않다는 것인데, 이로 인해 각 프로세스는 페이지가 디스크 어디에 존재하는 지 알아야 한다.
![[Pasted image 20231127214555.png]]
이를 보면 스왑 공간은 디스크 상의 고정된 유치에 존재하지 않으며, 페이지가 스왑 아웃되면 비어있는 디스크 페이지를 동적으로 할당하여 여기에 저장한다. 또한 디스크 맵에 디스크 페이지에 대한 정보를 기록하여 접근할 수 있게한다.



# 3.7 세그멘테이션
---
지금까지는 각 프로세스는 하나의 가상 주소만을 가졌다.
하지만 두개 혹은 그 이상의 분리된 가상 주소를 갖는 것이 편리한 경우가 많다.
즉 main program, stack, symbol table등의 object들이 각자의 가상 주소공간을 가지면 좋은 경우가 많다.

![[Pasted image 20231206173337.png]]
이런 경우는 각각의 가상 주소들을 물리주소 공간에 매핑시켜주면 된다.

한 가상 주소공간에서 스택부분이 너무 많아지면, 공간을 재할당해야 한다. 이는 매우 번거로운 일이다.
이렇게 각 메모리 부분을 증가시키거나 감소시키는 작업을 시스템에서 자연스럽게 제공할 수 있는데, 바로 세그먼트를 이용하는 것이다.
세그먼트란 여러개의 서로 완전히 독립된 주소공간을 의미한다.
각 세그먼트는 서로 다른 크기를 갖고 실행중에 크기가 변할 수 있다.

세그먼트를 사용하기 위해서는 프로그램이 사용하는 주소가 필요하다.
이는 두 부분으로 구성되어있다.
\<세그먼트 숫자, 세그먼트 내부에서의 주소(offset)>
![[Pasted image 20231206175255.png]]
이렇게 세그멘트를 memory와 링킹 시키기 위하여 segment table이 존재하며
segment number를 통해 segmentable entry에 접근하여
offset이 limit보다 작은 지 확인하고
이보다 작다면 base + offset을 통해 memory에 접근한다.

## segmentation advantages
* 프로세스끼리 세그먼트 공유가 가능하다.: 즉 한 가상공간에 연속적으로 모두 저장한 것이 아니므로, 특정 부분을 프로세스끼리 공유가 가능하다.
* 다른 세그먼트 별로 다른 protection이 가능하다.: 각각의 세그먼트는 오직 하나의 타입의 객체를 저장할 수 있고 따라서 알맞게 type을 지정할 수 있다.
* 따로 컴파일된 모듈들끼리 linking하는 것이 간단하다.: 링킹을 하는 과정에서 특정 segment가 다른 segment를 사용할 때 호출하기위해서 주소를 적어야 하는데, 이 부분이 \<세그먼트#, offset>이므로 편리하다. 즉 링킹과정에서 따로 주소를 바꿔줄 필요가 없다.(왜냐하면 이는 어쩌피 테이블을 참조하는 것인데, 만약 segment를 사용하지 않았다면 A의 위치가 바뀌었을 떄 해당하는 데이터의 위치도 바뀌어서 이를 반영해줘야 하기 때문이다.)

단점: 세그먼트를 사용하기에 internal fragementation이 발생할 수 있다.
또한 세그먼트는 세그먼트 교체시 swapping방법을 그대로 사용하기에 swapping과 마찬가지로 external fragmentation이 발생할 수 있고 이를 compaction을 통해 해결한다.

![[Pasted image 20231206185545.png]]

# 3.7.2 세그멘테이션과 페이징
---
만약 세그먼트의 크기가 크다면, 이를 모두 메모리에 적재하는 것이 불가능할 수 있다.
이럴 때는 세그먼트 중에서 필요한 부분만 메모리에 적재하는 페이징 개념을 도입할 수 있다.
* pure segmentation: 페이지기법을 쓰지 않는 세그멘테이션
* paged segmentation: 페이지기법을 사용하는 세그멘테이션
![[Pasted image 20231205123648.png]]
즉 가상 주소가 기존에는 \<segment # ,offset> 이었던 것에 비해, 이는 \<segment #, page #, offset>이다
즉 segment number에는 기존에 base limit가 있었던 것에 비해, 이번에는 base가 page number와 합쳐져서 page table entry를 가리키고, 이 page frame number와 offset을 합쳐 page frame을 찾아간다.