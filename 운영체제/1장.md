* ## 1.1.1 운영체제
	* 운영체제란 io, 디스크, cpu 등을 직접 다루기는 어려운데, 이를 최대한 심플하게 효율적으로 활용하기 위해 사용되는 소프트웨어, linux와 windows 등이 있다.
	* 사용자 인터페이스(shell(텍스트기반 대화 시스템), GUI(grapical user interface))는 운영체제가 아니다. 운영체제를 이용해서 일할 뿐. 실제로 이들은 운영체제와 비슷한 기능을 갖고 있고 모두 운영체제 추상화를 바탕으로 하고 있지만 서로 분명히 다르다.
	* 커널모드(supervisor 모드), 사용자모드
		* 커널모드란 모든 하드웨어에 접근하여, 기계가 실행할 수 있는 어떤 명령어도 실행할 수 있는 모드, 운영체제는 커널모드에서 실행된다. 기계 제어, i/o 명령등이 포함된다. 다른 소프트웨어의 기반
		* 사용자모드는 기계 명령 중 일부만 실행가능. 즉 커널 모드 외의 모든것. 가장 낮은 단계로는 쉘이나 gui가 존재, 사용자 모드에서는 커널 모드로 진입하기 위해 psw의 비트를 조작하는 것도 허용하지 않는다.
	* 운영체제의 두가지 기능
		* 복잡한 것들을 추상적 모습으로 제공
		* 하드웨어 자원들을 관리
* ## 1.1.2 자원 관리자로서의 운영체제
	* 운영체제를 특정 관점에서 본다면
		* 탑 다운관점(top-down): 응용 프로그램에게 추상화를 제공
		* 다운 탑관점(down-top): 복잡한 시스템을 이루는 각 부분들을 정돈되고 잘 관리된 형태로 이 자원들을 할당하는 역할, 즉 이들을 관리하는 것
	* 사용자가 여러 프로그램을 동시에 사용한다면 충돌이 일어날 수 있다. 즉 자원 사용을 확인하고 자원 요청을 받아 관리를 하며 여러 요청에 대한 충돌을 중재하는 것.
	* 자원 멀티플레싱(다중화)
		* 시간: 한 자원을 시간에 맞게 사용자가 돌아가면서 사용
		* 공간: 한 자원을 쪼개서 사용자가 각각 사용
		* 이러한 자원 멀티플레싱을 오류없이 실행하는 것이 운영체제의 
---

* ## 1.3 컴퓨터 하드웨어 복습
	* #### CPU
		* cpu는 메모리에서 명령을 받아 해석하고 이를 실행
		* cpu는 각각 자기가 실행할 수 있는 명령어 집합을 가지고 있다(즉 sparc에서는 펜티엄을 사용불가, 반대도 마찬가지)
		* 특별 레지스터
			* pc(program counter)는 다음 명령의 메모리 주소 가리킴
			* 스택 포인터는 메모리에 있는 현 스택의 최상위를 가리킴
		* ##### PSW(program status word)
			* 이는 또 하나의 레지스터로 여러 제어 비트들이 존재한다. 대표적으로 커널모드, 사용자모드를 구분하는 비트가 있으며, 프로그램은 psw의 몇몇 필드만 쓰기 가능하며, 읽기는 전부 가능.
		* cpu를 시간 다중화할 경우 이에 대한 모든 레지스터들을 따로 저장해 둬야한다.
		* ##### 시스템 호출
			* 사용자 프로그램이 커널로 트랩을 걸어서 운영체제를 활용하기 위해 시스템 호출을 요청. 그럼 제어권이 사용자 프로그램에서 운영체제로 넘어가며, 일이 끝나면 다시 돌아온다.
		* ##### 다중 스레딩(multithreading), 하이퍼스레딩(hyperthreading)
			* 스레드란 가벼운 프로세스의 일종
			* cpu로 하여금 두개의 다른 스레드의 상태를 가질 수 있도록 하는 것. 즉 한 프로세스내에 둘 이상 스레드가 동시에 작업을 수행
			* 즉 장치만 복수로 두는게 아니라 제어로직도 복수로 두는것
		* ##### 멀티 코어
			* 이는 cpu자체가 여러개 있는 것. 다중 스레딩은 한 cpu가 여러개로 보이게 하는 것이지만, 이건 진짜로 cpu가 여러개 있는 것.
			* 여러 프로세스 동시 수행
	* #### I/O장치
		* i/o장치에는 컨트롤러와 장치 자체가 있고, 컨트롤러는 장치를 물리적으로 조정. 즉 읽고 쓰기같은 명령을 받아 수행.
		* ##### 장치 드라이버(device driver)
			* 이는 i/o 장치에 있는 게 아니라 cpu에 있는 소프트웨
			* 이는 각자 다른 컨트롤러와 이야기 하기 위해 만들어진 소프트웨어
			* 이런 드라이버들은 자신과 교신할 때 사용되는 레지스터들을 가지고 있다. 예를들어 디스크에서는 디스크주소, 레지스터주소, 섹터 카운트, 읽기 방향등을 지정하는 레지스터
		* ##### i/o장치의 세가지 수행 방식
			* 1. 바쁜대기
				* 사용자 프로그램이 시스템 호출을 하면, 커널은 이를 받아 변환 후 적절한 드라이버에게 함수 호출, 드라이버는 i/o를 시작한다. 이때 드라이버가 i/o가 완료되었는지 일정 주기로 폴링을 하여 확인하며, i/o가 끝나면 드라이버가 데이터를 받아 돌아온다. 그럼 운영체제가 제어권을 호출자에게 돌려준다.
				* 단점은 폴링 되었는지 확인하기 위해 cpu를 계속 잡고 있어야 한다.
			* 2. 인터럽트
				* 드라이버가 장치를 시작하고 마무리되면 인터럽트를 걸어준다. 인터럽트가 걸리기까지 cpu는 다른 할 일을 찾아 수행.
				* ![[Pasted image 20230925132549.png]]
				* 드라이버가 컨트롤러에게 특정 일을 하라고 알리면(장치 레지스터에 요청을 씀), 시간이 지난 후 컨트롤러가 읽기, 쓰기를 완료하면 특정버스선을 통해  인터럽트 컨트롤러에 시그널을 보내고, 인터럽트 컨트롤러가 받아들일 준비가 되면 cpu에 특정 핀(비트)를 올리고, 완료된 장치 번호를 cpu에 줘 완료되었음을 알린다.