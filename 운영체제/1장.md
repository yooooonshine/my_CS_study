* \# 커널모드에서는 모든 명령어를 수행할 수 있다. (유저 모드에서 사용가능한 명령어도)
* \# OS는 system call, falut, interrupt에 의하여 호출 된다.
	* 즉 기본적으로 system call에 의하여 호출되는데
	* io 장치가 수행을 마치면 interrupt에 의하여 호출 되며
	* 예외로 fault로 실행된다. fault는 os코드 동작하면서 프로그램 죽여버리는 것.
* \# 배치 시스템(batch system)
	* 일괄 처리 시스템으로 하나의 작업이 끝나기 전까지 다른 작업을 할 수 없는 것.
	* 즉 작업이 순차적으로 이루어진다.
	* 여기서 일괄 처리는, 요청이 들어올떄마다 실시간으로 통신하는 게 아닌, 한번 대량 건을 받아 처리한다는 것.
	* 즉 한번에 정보를 가져오기 떄문에, 조금조금 가져오는 것보다 훨 효율적이다.
* ## 1.1.1 운영체제
	* 운영체제란 io, 디스크, cpu 등을 직접 다루기는 어려운데, 이를 최대한 심플하게 효율적으로 활용하기 위해 사용되는 소프트웨어, linux와 windows 등이 있다.
	* 사용자 인터페이스(shell(텍스트기반 대화 시스템), GUI(grapical user interface))는 운영체제가 아니다. 운영체제를 이용해서 일할 뿐. 실제로 이들은 운영체제와 비슷한 기능을 갖고 있고 모두 운영체제 추상화를 바탕으로 하고 있지만 서로 분명히 다르다.
	* 커널모드(supervisor 모드), 사용자모드
		* 이 두 모드는 cpu가 제공해주는 것.
		* 커널모드란 모든 하드웨어에 접근하여, 기계가 실행할 수 있는 어떤 명령어도 실행할 수 있는 모드, 운영체제는 커널모드에서 실행된다. 기계 제어, i/o 명령등이 포함된다. 다른 소프트웨어의 기반
		* 사용자모드는 기계 명령 중 일부만 실행가능. 즉 커널 모드 외의 모든것. 가장 낮은 단계로는 쉘이나 gui가 존재, 사용자 모드에서는 커널 모드로 진입하기 위해 psw의 비트를 조작하는 것도 허용하지 않는다.
	* 유저모드에는 애플리케이션과 유저 인터페이스 프로그램(system call해주는 소프트웨어)이 존재한다.
	* 운영체제의 두가지 기능
		* 복잡한 것들을 추상적 모습으로 제공, 즉 복잡한 하드웨어들을 단순하게 다룰 수 있도록 해준다.
		* 하드웨어 자원들을 관리
			* 애플케이션에서 복잔합 자원을 관리할 수 있도록 한다.
			* 리소스에 대한 접근이 서로 침범하지 않도록 한다.
			* 리소스를 공유할 수 있게 해준다. 즉 여러 프로그램이 동시에 작동할 수 있게 해준다.
* ## 1.1.2 자원 관리자로서의 운영체제
	* 운영체제를 특정 관점에서 본다면
		* 탑 다운관점(top-down): 응용 프로그램에게 추상화를 제공, 위에서 아래 본 것.
		* 다운 탑관점(down-top): 복잡한 시스템을 이루는 각 부분들을 정돈되고 잘 관리된 형태로 이 자원들을 할당하는 역할, 즉 이들을 관리하는 것
	* 사용자가 여러 프로그램을 동시에 사용한다면 충돌이 일어날 수 있다. 즉 자원 사용을 확인하고 자원 요청을 받아 관리를 하며 여러 요청에 대한 충돌을 중재하는 것.
	* 자원 멀티플레싱(다중화)
		* 시간: 한 자원을 시간에 맞게 사용자가 돌아가면서 사용
		* 공간: 한 자원을 쪼개서 사용자가 각각 사용
		* 이러한 자원 멀티플레싱을 오류없이 실행하는 것이 운영체제의 역할
	* timeslicing: 시간 멀티플레싱
	* time-sharing: 동시에 여러명접속속
---

* ## 1.3 컴퓨터 하드웨어 복습
	* ## 메모리
		* ![[Pasted image 20231006194126.png]]
		* Register는 한 싸이클에 처리할 수 있는 만큼 빠르다.
		* Main memory부터 Magnetic은 os가 관리하고 cache, register는 cpu가 관리한다.
		* ssd(solid state drive or disk)
			* main memory와 magnetic disk 사이의 성능이다.
			* 하드디스크가 성능이 안좋아서 ssd안에 작은 하드를 둬서 메모리 사용을 빠르게 한 것.
			* 
	* #### CPU
		* cpu는 메모리에서 명령을 받아 해석하고 이를 실행
		* cpu는 각각 자기가 실행할 수 있는 명령어 집합을 가지고 있다(즉 sparc에서는 펜티엄을 사용불가, 반대도 마찬가지)
		* cpu를 시간 다중화할 경우 이에 대한 모든 레지스터들을 따로 저장해 둬야한다.
		* 
		* 특별 레지스터
			* pc(program counter)는 다음 명령의 메모리 주소 가리킴
			* 스택 포인터는 메모리에 있는 현 스택의 최상위를 가리킴
		* ##### PSW(program status word)
			* 이는 또 하나의 레지스터로 여러 제어 비트들이 존재한다. 대표적으로 커널모드, 사용자모드를 구분하는 비트가 있으며, 프로그램은 psw의 몇몇 필드만 쓰기 가능하며, 읽기는 전부 가능.
		* ##### 시스템 호출(system call)
			* 사용자 프로그램이 커널로 트랩을 걸어서 운영체제를 활용하기 위해 시스템 호출을 요청. 그럼 제어권이 사용자 프로그램에서 운영체제로 넘어가며, 일이 끝나면 다시 돌아온다.
		* ##### 다중 스레딩(multithreading), 하이퍼스레딩(hyperthreading)
			* cpu는 한 프로세스를 가지고 있고 그 안에 여러 스레드가 존재 한다.
			* 스레드란 가벼운 프로세스의 일종
			* cpu로 하여금 두개의 다른 스레드의 상태를 가질 수 있도록 하는 것. 즉 한 프로세스내에 둘 이상 스레드가 동시에 작업을 수행
			* 즉 장치만 복수로 두는게 아니라 제어로직도 복수로 두는것
		* ##### 멀티 코어
			* 이는 cpu자체가 여러개 있는 것. 다중 스레딩은 한 cpu가 여러개로 보이게 하는 것이지만, 이건 진짜로 cpu가 여러개 있는 것.
			* 여러 프로세스 동시 수행
	* Array등은 메모리 access이고 disk등은 i/o access이다.
	* #### I/O장치
		* i/o장치에는 컨트롤러와 장치 자체가 있고, 컨트롤러는 장치를 물리적으로 조정. 즉 읽고 쓰기같은 명령을 받아 수행.
		* 키보드 같은 io 장치를 읽어서 메모리에 넣는 게 목적이다.
		* ##### 장치 드라이버(device driver)
			* 운영체제안 커널의 일부이다.
			* 제작사에서 만든 전용 드라이버가 있고, 윈도우에서 만든 범용 드라이버가 있다.
			* 이는 i/o 장치에 있는 게 아니라 cpu에 있는 소프트웨어
			* 이는 각자 다른 컨트롤러와 이야기 하기 위해 만들어진 소프트웨어
			* 이런 드라이버들은 자신과 교신할 때 사용되는 레지스터들을 가지고 있다. 예를들어 디스크에서는 디스크주소, 레지스터주소, 섹터 카운트, 읽기 방향등을 지정하는 레지스터
		* ##### i/o장치의 세가지 수행 방식
			* 1. 바쁜대기(폴링)
				* 사용자 프로그램이 시스템 호출을 하면, 커널은 이를 받아 변환 후 적절한 드라이버에게 함수 호출, 드라이버는 i/o를 시작한다. 이때 드라이버가 i/o가 완료되었는지 일정 주기로 폴링을 하여(폴링이라는 것은 컨트롤러가 일을 하는지 나ㄴ타내는 비트가 있어 이를 확인하는 것) 확인하며, i/o가 끝나면 드라이버가 데이터를 받아 돌아온다. 그럼 운영체제가 제어권을 호출자에게 돌려준다.
				* 단점은 폴링 되었는지 확인하기 위해 cpu를 계속 잡고 있어야 한다.
			* 2. 인터럽트
				* 인터럽트의 종류
					* 1. 하드웨어 인터럽트
						* 하드웨어 인터럽트는 외부 장치 또는 하드웨어에서 생성되는 인터럽트입니다. 키보드 입력, 마우스 클릭, USB 장치, NIC 카드 등으로 인터럽트 발생이 가능합니다.
					* 2. 소프트웨어 인터럽트
						* 소프트웨어 인터럽트는 컴퓨터의 내부 시스템에서 생성되는 인터럽트입니다. 소프트웨어 인터럽트는 응용 프로그램이 종료 또는 예외처리 되거나 운영체제에 서비스를 요청할 때 발생합니다. 소프트웨어 인터럽트는 커널과 통신해 간접적으로 중앙 처리 장치를 인터럽트 합니다.
				* 드라이버가 장치를 시작하고 마무리되면 인터럽트를 걸어준다. 인터럽트가 걸리기까지 cpu는 다른 할 일을 찾아 수행.
				* ![[Pasted image 20230925132549.png]]
				* 드라이버가 컨트롤러에게 특정 일을 하라고 알리면(장치 레지스터에 요청을 씀), 시간이 지난 후 컨트롤러가 읽기, 쓰기를 완료하면 특정버스선을 통해  인터럽트(cpu를 가져와야하기에 인터럽트 대기) 컨트롤러 칩에 시그널을 보내고, 인터럽트 컨트롤러가 받아들일 준비가 되면 cpu에 있는 특정 핀(비트)를 올리고, 완료된 장치 번호를 cpu에 줘 완료되었음을 알린다.
				* 인터럽트 컨트롤러 칩은 장치마다 가지고 있어, 다른 인터럽트 컨트롤러 칩에 순위가 밀리면 기다릴 수 있다.
				* ![[Pasted image 20230925210602.png]]
				* 인터럽트 벡터: 
					* 인터럽트 벡터는 인터럽트가 발생했을 때, 그 인터럽트를 처리할 수 있는 서비스 루틴들의 주소를 가지고 있는 공간이다.
					* 메인 메모리 안에 인터럽트 벡터 테이블이 있고 각 인터럽트마다 주소가 있다.
				* 인터럽트 서비스 루틴(interrupt service routine)
					* 인터럽트가 발생하면 어떻게 할지 정해져있는 OS 안의 코드들
					* 이렇게 인터럽트가 걸리고 처리하는 과정을 인터럽트 서비스라고 한다.
				* 인터럽트 핸들러: 실제 인터럽트를 처리하기 위한 루틴, 인터럽트를 핸들링 하는 함수를 인터럽트 핸들러라고 한다. 
					* 인터럽트 핸들러는 인터럽트 컨트롤러칩과 다르다. 인터럽트 컨트롤러칩은 개별로 존재하고 인터럽트 핸들러는 장치 드라이버의 일부고 현재 스택을 저장하고 인터럽트 처리하고 다음 명령어로 돌아가는 역할을 한다. 
				* cpu가 인터럽트를 받아들이면 cpu는 작업하고 있었기에 이를 임시 저장하기 위해 pc,psw를 현 스택에 푸쉬하고 cpu를 커널 모드로 전환. 그럼 인터럽트 핸들러(인터럽트 핸들러는 장치마다 존재하고 이 주소를 알기 위해 메모리 영역 인덱스를 활용하기도 한다.)가 시작되는 데, 이 때 pc, psw를 저장해둔다. 인터럽트가 끝나면 명령으로 되돌아 간다.
				* 이때 cpu는 스택에 pc, psw를 올려놓기만하고, 이를 인터럽트 핸들러가 작동하게 되었을 때 따로 저장하는 것.
				* pc, psw는 pcb(process counter block)에 저장한다.
				* 여기서 cpu는 인터럽트 핸들러에 접근하기 위해서 이 주소를 알아야하는데, 우리는 장치번호를 알기에 이 장치번호를 메모리에서 인터럽트 핸들러 주소에 대한 인덱스로 활용할 수 있다.
				* \# 인터럽트를 하는 이유는 cpu속도가 io속도보다 현저하게 빠르기에.
			* 3. dma driven io
				* CPU의 지속적인 없앨려고 DMA(direct memory access)라는 하드웨어를 사용하는 것이다.
				* dma칩에 cpu가 메모리주소, 장치주소, 방향, 얼마나 많은 바이트 전송할 지를 적는다.
				* 그럼 이대로 dma칩이 작동하고 cpu는 그동안 다른 일을 한다.
				* dma가 작업을 완료하면 인터럽트를 건다.
				* 나머지는 2.와 동일
			* 만약 인터럽트가 다른 인터럽트를 처리하는 중에 발생할 수 있다. 그럼 발생한 인터럽트를 무효화하고, cpu에 인터럽트 시그널을 유지시키고, 진행하던 인터럽트가 끝나면 받아서 한다. 이 때 대기중인 인터럽트가 여러개면 우선 순위대로 처리한다.
			* 
	* ### PSW(Program Status Word)
			* 시스템 내부의 순간순간을 기록하고 있 정보, 즉 cpu의 현재 상태를 저장
* ## 1.4 운영체제 동물원
	* 1. 메인프레임 운영체제
		* io가 많이 필요로 하는 많은 작업들을 한번에 처리하는데 사용된다.
		* 수백개의 데이터 베이스와 엄청 큰 메인프레임 컴퓨터가 있다.
		* 이는 배치, 트랜잭션 프로세싱, 시분할이라는 서비스를 제공한다.
		* 배치는 사용자에 무관한 처리 (즉 보고서 처리등)은 주로 배치 시스템이 처리
		* 트랜잭션 프로세싱은 항공권 예매등의 우리와 관련된 짧지만 수 많은 요청이 동시에 일어나는 처리
		* 따라서 시분할을 통해 여러 클라이언트의 동시 요청을 처리해 준다.
	* 2. 다중처리기(multiprocessing, parallel) 운영체제
		* 다중처리기는 여러 cpu를 연결하여 하나의 시스템을 구축한 것
		* 다중처리를 위해 cpu간의 연결, 통신이 필요하며, 서로 데이터를 일관성 유지하는 것도 필요하다.
		* window ,linux등 포함한 여러 운영체제가 다중처리를 지원한다.
	* 3. 서버 운영체제
		* 서버 운영체제는 네트워크를 통해 클라이어언트들에게 서비스를 제공
	* 4. 개인용 컴퓨터 운영체제
		*  개인을 지원하기 위해 쓰이는 운영체제 최근에는 다중프로그래밍을 지원.
	* 5. 핸드헬드 컴퓨터 운영체제
		* 아주 작은 컴퓨터
		* pda(personal digital assistant)
	* 6. 임베디드 운영체제
		* 핸드헬드와 유사하나 차이점은 임베디드는 신뢰할 수 없는 소프트웨어를 절대 실행 못하게 한다. 
		* 즉 프로그램간의 간섭이 일어나지 않아 매우 간소화할  수 있다.
		* 사이즈. 메모리, 전력에 제한이 있다.
	* 7. 실시간 운영체제
		* 실시간 운영체제는 시간을 중요시 여긴다. 주로 공장등에 사용된다
		* #### 경성 실시간 시스템(hard real-time system)
			* 경성 실시간 시스템은 어떤 행동이 특정 시점에 반드시 이뤄져야 한다.
		* #### 연성 실시간 시스템(soft real-time system)
			* 연성 실시간 시스템은 행동이 미뤄질 수 도 있다. 
* ## 1.5 운영체제 개념
	* os는 프로세스를 생성,삭제,제개,복제,의존성,프로세스간 통신,동기화 기능을 제공해준다.
	* 프로세스:
		* 실행하고 있는 프로그램
		* 프로그램 안에 여러 프로세스가 존재, 이 프로세스는 같은 프로그램을 복사한 것. 각각 독립적으로 작동한다.
		* 프로세스는 프로그램의 instance, 즉 프로그램 자체는 디스크 안에 있는 작동될 bytes이다.
		* 프로세스는 주소공간과 자원의 집합에 연관되어 있다.
		* 프로세스는 주소공간(프로세스가 읽고 쓸 수 있는 메모리공간)과 연관이 있다.
			* 주소공간에는 프로그램, 데이터, 스택을 포함한다.
		* 프로세스는 자원의 집합과 연관이 있다.
			* 이는 레지스터, 열려있는 파일들의 목록, 기다리고 있는 알람, 관련 프로세스 목록 및 프로그램 실행에 필요한 모든 정보를 담고 있다.
			* #### 프로세스 테이블: 
				* 프로세스별로 하나씩 갖고 있는 배열구조의 테이블
				* 여기에는 한 프로세스가 다른 프로세스로 전환될 떄 저장해야 할 지금 사용하고 있는 파일들의 현재 포인터등 자신의 주소공간의 내용물을 제외한 모든 정보를 저장한다.
			* 즉 정지당한 프로세스는 주소공간(코어 이미지라고 불린다), 과 프로세스테이블 엔트리로 구성된다.
			* #### 프로세스간 통신(interprocess communication):
				* 만약 터미널을 통해 쉘,명령인터프리터 프로세스가  한 프로그램을 컴파일하라는 명령을 받으면 이 프로세스가, 컴파일 할 수 있는 프로세스를 만들어야한다.
				* 이렇게 만들어진 프로세스는 일을 마치고 쉘 프로세스한테 호출을 해야한다.
				* 이렇게 프로세스간의 통신을 프로세스간 통신이라고 한다.
		* #### UID(user identification)
			* 시스템 관리자는 시스템을 사용할 수 있는 유저에게 uid를 부여하고 
			* 이 유저가 프로세스를 시작할 때마다 각 프로세스가 uid를 갖게 되고 이 프로세스로 인해 시작되는 다른 프로세스도 같은 uid를 부여받는다.
		* #### GID:
			* 유저를 묶어 그룹
	* i/o
		* 모든 운영체제는 자신의 io들을 관리하기 위한 io서브시스템을 갖고 있다.
		* 어떤 io소프트웨어는 장치와 무관하다. 즉 여러 io에 호환가능
		* 각 io에 해당하는 장치 드라이버는 그 io장치에만 맞게 끔 되어있다. 즉 io마다 장치 드라이버가 따로 있다.
		* 장치 드라이버는 io장치와 상호작용하는 routine이라고 볼 수 있다.
	* 쉘(shell)
		* 쉘은 운영체제는 아니지만 운영체제의 많은 기능을 이용한다. 즉 사용자와 운영체제 사이에 있는 게 쉘이다
	* protected instruction
		* 몇몇 명령어들은 커널모드에서만 수행가능하도록 보호되어 진다.
		* 예로 메모리 접근, 페이지테이블 포인터 수정, mode bits조정, 명령어 중지등.
	* #### 시스템 호출
		* 시스템 호출이란 3 인자(각각 파일을 지정하는 인자, 어디 두는지 알리는 인자, 몇 바이트를 읽는지 알려주는 인자)를 통해 운영체제에 특정 행동을 요구하는 함수이다.
		* 즉 특정 프로세스에서 파일에 있는 데이터를 읽어야 하는 등의 시스템 서비스가 필요하다면 시스템 호출을 통해 운영체제로 제어권을 넘긴다.
		* ![[Pasted image 20231006213236.png]]
		* 1,2,3.에서 read라는 라이브러리 함수를 호출하기 위해 인자들을 스택에 넣어둔다.
		* 4.에서 read 라이브러리 함수를 호출한다. 
		* 5. 그럼 이 함수는 커널 코드가 어떤 시스템 호출을 했는 지 알게 하기 위해 시스템 호출 번호를 스택에 넣는다. 이후 커널로 TRAP한다.
		* 6. TRAP은 1.호출로 인해 커널 모드로 들어간다. 2. 다른 함수와는 다르게 특정 고정된 주소로만 이동한다라는 두 함수와는 다른 특징을 가지고 있다.
		* 7, 8. 커널 코드가 스택에서 시스템 호출을 확인하고(7) 테이블(시스템 호출에 맞는 번호에 있는 테이블 행에는 그에 해당하는 시스템 호출 핸들러를 가리키는 주소를 담고 있다.)을 통해 시스템 호출 핸들러로 이동한다.(8)
		* 9. 핸들러가 마치면 트랩 명령 바로 뒤 명령으로 제어권이 넘어갈 수 있다. 다만 키보드 입력을 기다리는 데 입력이 없다면 호출자가 블록되서 진행을 못하고, 입력이 들어올 때까지 운영체제가 다른 프로세스를 찾아 실행한다.
		* 10. 사용자 프로그램에게 반환된다.
		* 11. 스택 정리
	* #### POSIX 함수
		* 시스템 호출을 하는 라이브러리 함수들.
		* POSIX 함수는 무조건 시스템 호출을 하는 게 아니라, 경우에 따라 다른 라이브러리 함수를 호출할 수도 있다.
		* 여러 POSIX 함수들이 한 시스템 호출을 사용할 수 있다. 즉 시스템 호출과 POSIX함수는 일대일로 대응되는 것이 아니다
		* ##### FORK
			* fork는 한 프로세스(부모 프로세스)를 파일 디스크립터(파일에 접근하기 위해 사용되는 값), 레지스터등을 모두 그대로 복사(자식 프로세스)하는 것이다.
			* 이 부모와 자식은 각자의 길을 간다.
			* fork 호출 반환 값은 자식은 0, 부모의 경우는 자식프로세스의 식별자 혹은 pid가 반환된다.
			* 
* ## 1.7 운영체제 구조
	* #### 모놀리식 시스템
		* ![[Pasted image 20231008212312.png]]
		* 모놀리식 시스템은 전 운영체제를 하나의 커다란 프로그램으로 커널 모드에서 실행
		* 여러 함수들의 모음으로 구성되어 있고, 이들을 링크시켜 만든다.
		* 이 시스템 안에서 한 함수는 시스템 내 모든 함수를 호출할 수 있다.
		* 각 시스템 호출에 맞는 서비스 프로시듀어가 존재하고 이에 의해 호출되서 사용되는 유틸리티 프로시듀어가 있다. 
		* 운영체제 오브젝트 프로그램은 모든 함수들을 컴파일하고, 이들을 시스템 링커를 이용하여 모두 바인딩해서 하나의 실행 파일로 만드는 것이다.
		* 하나의 실행 파일이므로, 하나의 io장치가 바보여도(오디오라던가) 프로그램 전체가 먹통이 된다. 대신 장점으로 매우 빠르다.
		* 모듈이나 패키지는, 이 안에 정보를 은닉하는데 모놀리식 시스템은 은닉이 없다.
		* 애플리케이션에서 시스템 호출에 필요한 인자들을 저장하고(넘기기 위해) 운영체제에 넘기면, 
		* 운영체제에 있는 메인 함수가 각 시스템 호출에 맞는 서비스 함수를 호출한다.
		* 이 서비스 함수는 시스템 콜을 수행하고, 이 떄 유틸리티 함수를 사용한다.
		* 각 서비스 함수는 시스템호출에 일대일 매칭된다.
	* #### 계층 구조
		* 층으로 쌓여 있는 구조
		* 계층
			* 계층0
				* 하드웨어
			* 계층1
				* 이는 cpu 스케쥴링
				* 즉 지금 돌아갈 프로세스를 할당하는 일을 하며, 인터럽트나, 시분할 타이머가 종료되면 다른 프로세스로 교환하는 일을 담당.
				* 즉 프로세스들이 순차적으로 구성되며, 한 프로세스안에 여러 프로세스가 있고, 이 여러 프로세스가 돌아갈 때, 한 프로세스에 종속되어 있음을 상기하지 않은 채 실행할 수 있도록 함(다중 프로그래밍을 위한 기본 내용)
				* 다중 프로그래밍:: 메모리에 여러 프로그램을 상주시키고, 한번에 여러 프로그램이 돌아가는 거처럼 보이게 하는거. 시분할이 그 예
				* 
			* 계층2
				* 메모리 관리
				* 즉 프로세스를 위한 메모리 공간 할당하는 일을 하며, 프로세스가 메모리 공간 부족으로 드럼(디스크 같은 것)으로 저장되기도 하는데, 이를 메모리와 드럼에서 가져오는 지 인식할 필요 없게 해준다.
			* 계층3
				* 콘솔 디바이스
				* 즉 프로세스와 운영자 콘솔간의 통신을 처리해줬다.
				* 각 프로세스마다 개인의 콘솔이 있는 것과 마찬가지로 만들어준다.
			* 계층4
				* i/o 장치 버퍼링
				* 즉 io장치가 느리고,  프로세스가 이 장치와 정보를 주고 받을 때 생기는 버퍼링을 처리해준다.
				* 이로 인해, 느린 이상한 장치 대신, 좋은 특성을 가진 추상화된 io 장치로 만들어준다.
			* 계층5
				* 사용자 프로그램
	* #### 마이크로 커널
		* 커널 모드에서 돌아가는 것을 최소하하는 것.
		* 운영체제를 작은 모듈로 쪼개고, 이 모듈 중 하나만 커널모드로 실행하고, 나머지는 사용자 프로세스로 실행.
		* 즉 사용자 프로세스는 권한이 매우 낮아서, 이의 버그가 프로그램 전체를 망가트리지 못한다.
		* 즉 오디오 같은 것은 사용자 프로세스로 
		* 즉 신뢰성이 높고, 확장이 쉽다. 다만 유저 모드와 커널모드를 왔다갔다하므로, performance가 안 좋다.
		* mission critical한 프로그램에 많이 쓰인다.
		* mission cirtical
			* 높은 신뢰성을 요구하는 것
	* #### 가상머신(virtual marchine)
		* 가상머신이란 한 cpu 내에서 여러 운영체제가 작동할 수 있게 하는것.
		* 이를 위해서 메모리 관리 프로그램, 프로세스 스케줄러, I/O(입력/출력) 스택, 기기 드라이버, 보안 관리 프로그램, 네트워크 스택과 같은 운영 체제 수준의 구성 요소가 필요하다.
		* 시뮬레이터가 vm보다 큰 개념.
		* ##### 공유 호스팅(shared hosting)
			* 공유 호스팅은 여러 웹 사이트가 동일한 서버에서 호스팅되는 웹 호스팅 서비스 유형
			* 저렴, 중소기업에게 유리
			* 다만 한 서버를 공유하기 떄문에, 한 페이지에 사람들이 모이면, 전체 웹 페이지가 느려진다.
		* ##### 지정된 호스팅(dedicated hosting)
			* 클라이언트가 다른 클라이언트와 서버 리소스를 공유하지 않는 것.
			* 즉 빠름
			* 즉 클라이언트당 한 서버가 할당되는 것
		* #### 가상머신 모니터(vmm)
			* 가상 머신 (VM)의 생성, 관리 및 거버넌스를 지원하고 물리적 호스트 머신 위에서 가상화 된 환경의 작동을 관리하는 소프트웨어 프로그램입니다.
		* 이 때 가상머신을 통해 한 서버를, 완전한 여러 서버로 분리할 수 있다.
		* ![[Pasted image 20231008232031.png]]
		* vmm을 하이퍼 바이저로 불린다.
		* 하이퍼바이저가 설치된 물리 하드웨어를 호스트라고 하며 그 리소스를 사용하는 여러 VM을 게스트라고 합니다.
		* ##### 타입1하이퍼바이저
			* 기존의 vmm을 하이퍼 바이저1 이라 부르는데, 하이퍼 바이저1은 는 생(날것의)하드웨어 위에서 작동한다.
		* #### 타입2하이퍼바이저
			* 1과는 달리 vm이 생 하드웨어 위에서가 아닌 호스트 운영체제(host operationg sysyem)위에서 실행된다.
			* 호스트 운영체제는 윈도우나 리눅스등이 될 수 있고 이 위에 type 2 hyervisor라고 쓰여진 marchine simulater를 설치해 guest os 를 운영한다.