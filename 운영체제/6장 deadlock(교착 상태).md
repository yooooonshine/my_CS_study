컴퓨터에는 두 프로세스가 동시 사용할 수 없는 여러 리소스들이 존재한다
* printer
* tape drives
* tables
들이 그 예이다
테이블에 두 프로세스가 동시에 쓰려고 한다면 망가질 것이다. 이럴 경우에는 배타적인 접근 허락이 필요하다.

만약 한 프로그램이 A리소스를 가진 상태로 B를 요청하고
다른 프로그램이 B리소스를 가진 상태로 A를 요청한다면 진행을 못하면서 교착상태, 즉 deadlock이 발생할 것이다.
## 선점형 자원과 비선점형 자원
선점형 자원(preemptive resource): 뺏을 수 있는 자원을 의미한다. 
예를 들어 메모리 같은 경우 다른 프로세스에서 사용하고 있더라도 뺏어올 수 있다.
비선점형 자원(nonpreemptive resource): 자원을 소유한 다른 프로세스로부터 뺏을 수 없는 자원을 의미한다.

일반적으로 교착상태는 비선점형  자원들을 대상으로 발생한다.

만약 요청된 자원이 가용하지 않다면, 요청하는 프로세스는 가용이 가능할 때까지 기다려야 한다.
특정 프로세스에서는 요청이 실패되면, 블록되었다가 가용가능할 때 깨워진다.
혹은 요청이 실패되면 요청 루프에 들어가 자원이 가용할 때까지 sleep한다.

 ![[Pasted image 20231128114458.png]]
 오른쪽 코드는 프로세스 A가  resource 1을 할당 받고
 프로세스 B가 resource2를 할당받는다면 각각 2와 1을 할당받을 수 없으므로 deadlock을 발생시킨다.
## 자원 교착상태의 조건
다음 네 조건들이 반드시 만족되어야 교착상태가 발생한다
1. 상호배제(mutual exclusion): 각 자원은 현재 정확히 한 프로세스에게만 할당되어 있거나 가용한 상태이다.
2. 잡고 기다림(hold and wait): 현재 자원들을 보유하고 있는 프로세스가 새로운 자원들을 요청하고 있어야 한다.
3. 비선점(no preemption): 이전에 승인된 자원들은 프로세스로부터 강제로 뺏을 수 없으며, 반드시 그것을 보유한 프로세스에 의하여 반환되어야 한다.
4. 순환대기(circular wait): 둘 이상의 프로세스들의 순환 체인이 있어야 한다.

## Deadlock 모델
![[Pasted image 20231206163536.png]]
원은 프로세스
네모는 자원이다.

자원이 프로세스를 가리키면 그 자원은 프로세스가 소유하고 있다는 뜻
프로세스가 자원을 가리키면  프로세스가 자원을 기다리면서 블록되어 있다는 뜻

오른쪽은 두 프로세스가 하나의 자원을 갖고 다른 자원을 요청하며 블록되어 있어여 교착상태이다.

## 그럼 deadlock을 어떻게 처리해야 할까
1. 타조 알고리즘, 즉 무시한다.
2. 탐지 및 회복,  교착상태를 찾아 recovery한다.
3. dynamic avoidance,자원 할당을 조작하여 피해간다
4. prevention, 교착 상태의 네 가지 요구 조건을 무효화하여 교착상태를 막는다.
## 타조 알고리즘
무시한다.
즉 데드락이 매우 드물게 일어나고, 이 데드락을 막는데 큰 비용이 든다면 무시하는 것도 한가지 방법이다.
## 교착상태의 탐지 및 회복
교창 상태의 발생을 예방하지 않아, 발생하도록 내버려 둔 다음, 교착 상태가 발생할 때 이를 검출하려고 시도하고, 그로부터 회복하려고 조치를 취한다.

모든 타입은 하나의 자원이 존재함을 가정할 때(즉 프린터 자원은 한 개)
![[Pasted image 20231206164847.png]]
위와 같이 모든 자원과 프로세스의 요청과 할당 그래프를 그릴 수 있다.
이때 순환이 있는 경우 여기서 deadlock이 발생했음을 알 수 있다.


# 6.4.3 교착상태로부터 회복
---
이제 교착상태를 탐지했다고 가정하자, 그럼 회복해서 시스템이 다시 동작하도록 해야 한다.
## recovery through preemption
즉 프로세스로부터 자원을 빼앗고, 다른 프로세스가 그것을 사용하도록 하는 것이다.
이 때 사용을 마치면, 중단된 상태르 다시 복원하여 기존 프로세스가 뺏긴 것을 알아채지 못하도록 한다.

하지만 이는 자원에 따라 어렵거나 불가능할 수도 있다.
## recovery through rollback
체크 포인트를 사용하여, 교착된 프로세스 중 하나를 롤백하고 이전 상태로 되돌리는 것이다.

체크 포인트란 특정프로세스가 어떤 자원을 할당했는 지 혹은, 그 결과가 어떻게 되는 지등등 모든 것을 기록하는 것이다.

따라서 교착상태가 발생하면 한 프로세스를 해당 자원을 획득하기 이전 시점으로 롤백하여, 자원을 다른 프로세스에게 할당시켜 교착상태를 해결하는 방법이다.
## recovery through killing process
즉 교착 상태에 빠진 프로세스중 하나를 강제 종료 시켜 교착상태를 해결하는 것이다.

# 6.5 교착상태 회피
---
항상 올바른 선택만을 하여 교착상태를 회피하는 방법
즉 미리 어떤 자원을 사용할지 아는 경우에, 주의 깊게 자원을 할당하여 교착상태를 회피하는 방법이다.
![[Pasted image 20231206170551.png]]
위 그림은 두 프로세스가 진행되는 과정을 보여준다.
A프로세스는 가로로, I1, I2는 실행되는 명령어이다.
I1과 I3 사이에서 printer자원을 사용함을 의미한다.
p,q,r,s,t의 선은 p->q일 때 A프로세스가 실행됨을 의미하고 q->r은 B프로세스가 실행됨을 의미한다. 대각선은 없는게 두 프로세스가 동시에 실행될 수는 없기 떄문이다.

음영이 되어 있는 부분은 두 프로세스가 모두 Printer 혹은 Plotter를 가지고 있는 지역을 의미하며, 즉 갈수 없는 지역이다.

이 상황에서는 I1과 I2, I5와 I6사이의 영역을 들어가면 무조건 교착상태에 빠지게 된다.
따라서 t시점에서 B프로세스가 plotter를 요청하였을 때, 승인한다면 교착상태에 빠지므로 B는 중단되고 A가 I4를 통과하여 plotter를 반환할때까지 기다려야한다.

# Safe and Unsafe State
---
Safe state란 데드락이 앞으로 발생하지 않을 수 있는 상황
Unsafe state는 safe가 아닌 상황, 즉 데드락이 무조건 발생하거나 이미 발생한 상황
![[Pasted image 20231206171452.png]]
(a)를 보면 B에 2를 할당해주면 B가 끝나 자원이 5개가 되고 이를 C에 할당하여 끝내 7개가 되고 이를 A에 주어 모든 프로세스를 끝낼 수 있다.
![[Pasted image 20231206171611.png]]
(a)에서 (b)를 가면 unsafe이다.

하지만 이 알고리즘은 실질적으로 max 리소스 량을 파악하기 힘들고, 새로운 프로세스가 생겨 자원을 요청할 수도 있으며, 리소스가 중간에 고장날 수도 있기에 사용하기 힘들다.

# 교착상태 예방(deadlock prevention)
---
데드락의 네가지 조건들을 제거하여, 교착상태가 발생하지 않게 하는 것이다.


## 상호 배제 조건 공략하기
예를 들어 프린트 같은 경우는 mutual exclusive한데, 이에 대한 큐를 만들어 독점적으로 사용하지 않도록 만들면 된다.

## 잡고 기다림 조건 공략하기
프로세스가 필요로 하는 자원들을, 프로세스가 시작하기 전에 모두 받아서, 중간에 wait하지 않도록 만드는 것이다.

다만 이는 어떤 리소스를 필요로 하는지 모두 파악해야 하며, 프로세스동안 리소스는 대기해야 하므로 효율성이 떨어진다.

## 비선점 조건 공략하기
이는 뺏기면 안되는 자원들이 존재하므로 공략할 수 업다.
## 순환 대기 조건 공략하기
첫번째로 프로세스는 어떤 순간에 반드시 하나의 자원만 보유할 수 있도록 하는 것이다. 즉 두번째 자원이 필요하다면 반드시 첫번째 것을 반환해야 한다.
두번째 방법으로는 자원들에게 숫자를 할당해 모든 프로세스는 이 순서에 따라 자원을 할당받도록 하는 것이다. 그럼 순환이 안생긴다.