* ![[Pasted image 20231009204040.png]]
* 스케줄링: 컨텍스트-스위치가 일어날 떄 레디있는 것중 어느 것을 실행할 지 결정
* ![[Pasted image 20231009204111.png]]
* cpu가 희소하다는 가정에서 출발.
* 서버시스템은 cpu가 희소하지만, 개인 피시에서는 cpu가 넉넉하다
* ![[Pasted image 20231009204431.png]]
* 상태저장, 메모리맵저장, 다음 프로세스 선택등 여러 오버헤드가 존재한다.
* ![[Pasted image 20231009204549.png]]
* cpu바운드 자리 io 바운드 자리 구분이 되는데.
	* a는 cpu, cpu는 한번 쓰면 오래 쓴다.
	* b는 io바운드, 짧게 쓴다.
	* 다만 이는 상대적이다. cpu가 10배 빨라지면 간격이 줄어든다. io는 빨라지기 힘들다.
* ![[Pasted image 20231009204823.png]]
* 스케줄은 언제 일어나냐?
	* 1. fork
	* 3. block은 io나 page fault등
	* 5. cpu가 한 프로세스가 너무 오래 동작했다했을때.
	* 
* Nonpreemptive는 프로세스가 끝날 때까지 놔둠, 무한루프 걸리면 계속 돈다.
* Preemptive는 특정 간격을 둬서 주기적으로 interrupt를 걸어 다시 스케줄링
* ![[Pasted image 20231009205817.png]]
* 배치시스템은
	* 프로그램을 시작하고 끝날때 제출을 받는, 그동안 다른 거 못하는.
	* preemptive여도 시간을 매우 길게 준다.
	* 스위치를 최소화
* 인터렉티브 환경은 
	* 인터렉티브 환경은 반응이 바로바로 와야 하므로 preemptive반드시 필요.
* 리얼 타임은
	* 무조건 데드라인을 맞춰야한다.
	* 이건 미리 이 프로그램이 얼마나 도는 지 정확히 알고 스케줄링 한다.
* ![[Pasted image 20231009210222.png]]
* 모든 시스템은 프로세스가 공정하게 cpu를 쓸 수 있도록 해야한다.
* 정책은 예외없이 적용되어야한다.
* 모든 시스템의 이용률이 좋아야한다.
* 배치시스템은
	* throuput이 중요, 즉 시간동안 몇 개의 프로그램을 돌리는 지.
	* cpu이용 높아야함, 즉 쓸때없는 context switch가 적어야함
* 인터렉티브
	* 반응속도가 좋아야한다. 즉 시간안의 얼마나 많은 프로그램을 마치는게 중요하지 않다.
	* 프로포셔널리티- 1초에 10개 프로그램 -> 10초에 100개 하겠지가 맞아야함
* 리얼타임
	* 데드라인 맞추기
* ![[Pasted image 20231009210734.png]]
* 롱텀은
	* 몇개의 프로그램이 메모리에 할당되어 실행될 지
	* 즉 얼마나 많은 잡을 한번에 돌릴지
	* 너무 많으면 문제가 생긴다.
* ![[Pasted image 20231009210915.png]]
* ![[Pasted image 20231009210933.png]]
* 한 프로세스가 너무 못 돌아가면 안된다.
* ![[Pasted image 20231009211103.png]]
* 온 순서대로 처리
* starvation도 없어, 줄 서면 언젠가 실행 되니까.
* ![[Pasted image 20231009211202.png]]
* 앞에서 너무 많으면 시간 너무 걸려
* 두 처리는 throughput 관점에서는 똑같다.
* 하지만 1.은 A는 8, B는 9, C는 10 즉 평균 9분씩 기다린 것.
* 2.는 B는1, C는2,A는 10 평균 4.,.. 많은 차이가 난다.