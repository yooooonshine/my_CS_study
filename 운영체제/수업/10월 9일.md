* 퀀텀이 2분이어도 한프로세스가 1분만 쓰면 , 다른 프로세스가 나머지 1분을 사용한다. 즉 cpu는 쉬지 않는다.
* ![[Pasted image 20231009204040.png]]
* 스케줄링: 컨텍스트-스위치가 일어날 떄 레디있는 것중 어느 것을 실행할 지 결정
* ![[Pasted image 20231009204111.png]]
* cpu가 희소하다는 가정에서 출발.
* 서버시스템은 cpu가 희소하지만, 개인 피시에서는 cpu가 넉넉하다
* ![[Pasted image 20231009204431.png]]
* 상태저장, 메모리맵저장, 다음 프로세스 선택등 여러 오버헤드가 존재한다.
* ![[Pasted image 20231009204549.png]]
* cpu바운드 자리 io 바운드 자리 구분이 되는데.
	* cpu bound는 cpu, cpu는 한번 쓰면 오래 쓴다.
	* io bound는 io를 많이 쓴다.
	* 다만 이는 상대적이다. cpu가 10배 빨라지면 간격이 줄어든다. io는 빨라지기 힘들다.
	* cpu bound가 계산이 많으므로 io bound보다 그냥 시간을 오랫동안 잡도록 해놓은 것
	* io bound는 입출력만 하므로 계산이 필요없어서 시간을 많이 잡을 필요없다.
* ![[Pasted image 20231009204823.png]]
* 스케줄은 언제 일어나냐?
	* 1. fork
	* 3. block은 io나 page fault등
	* 5. cpu가 한 프로세스가 너무 오래 동작했다했을때.
	* 
* Nonpreemptive는 프로세스가 끝날 때까지 놔둠, 무한루프 걸리면 계속 돈다.
* Preemptive는 특정 간격(quantum)을 둬서 주기적으로 interrupt를 걸어 다시 스케줄링
* ![[Pasted image 20231009205817.png]]
* 배치시스템은
	* 프로그램을 시작하고 끝날때 제출을 받는, 그동안 다른 거 못하는.
	* preemptive여도 시간을 매우 길게 준다.
	* 스위치를 최소화
* 인터렉티브 환경은 
	* 인터렉티브 환경은 반응이 바로바로 와야 하므로 preemptive반드시 필요.
* 리얼 타임은
	* 무조건 데드라인을 맞춰야한다.
	* 이건 미리 이 프로그램이 얼마나 도는 지 정확히 알고 스케줄링 한다.
* ![[Pasted image 20231009210222.png]]
* 모든 시스템은 프로세스가 공정하게 cpu를 쓸 수 있도록 해야한다.
* 정책은 예외없이 적용되어야한다.
* 모든 시스템의 이용률이 좋아야한다.
* 배치시스템은
	* throughput이 중요, 즉 시간동안 몇 개의 프로그램을 돌리는 지.
	* cpu이용 높아야함, 즉 쓸때없는 context switch가 적어야함
* 인터렉티브
	* 반응속도가 좋아야한다. 즉 시간안의 얼마나 많은 프로그램을 마치는게 중요하지 않다.
	* 프로포셔널리티- 1초에 10개 프로그램 -> 10초에 100개 하겠지가 맞아야함
* 리얼타임
	* 데드라인 맞추기
* ![[Pasted image 20231009210734.png]]
* 롱텀은
	* 몇개의 프로그램이 메모리에 할당되어 실행될 지
	* 즉 얼마나 많은 잡을 한번에 돌릴지
	* 너무 많으면 문제가 생긴다.
* ![[Pasted image 20231009210915.png]]
* ![[Pasted image 20231009210933.png]]
* starvation 문제: 한 프로세스가 너무 못 돌아가면 안된다. ,즉 cpu할당을 못받는 것.
* ![[Pasted image 20231009211103.png]]
* 온 순서대로 처리
* starvation도 없어, 줄 서면 언젠가 실행 되니까.
* ![[Pasted image 20231009211202.png]]
* 앞에서 너무 많으면 시간 너무 걸려
* 두 처리는 throughput 관점에서는 똑같다.
* 하지만 1.은 A는 8, B는 9, C는 10 즉 평균 9분씩 기다린 것.
* 2.는 B는1, C는2,A는 10 평균 4.,.. 많은 차이가 난다.
* turnaround
	* 도착했을 때 부터, 종료까지의 시간
* waiting 
	* 도착했을 떄 부터 cpu할당 받기전까지의 시간
* Response Time
	* = FirstRun Time - Arrival Time
* Throughput 
	* 단위 시간당 완료된 프로세스 수
* 
* turnaround time은  여기서 8, 9, 10을 의미하고 total turnaround time은 27이다.
* cpu bound , io bound
	* cpu bound는 io보다 연산으로 이루어진 cpu burst가 큰 프로세스, 즉 cpu작업이 큰 프로세스 인데. 일반적으로 burst가 일어날떄는 io보다 cpu가 더 긴시간을 갖는다.
	* io bound는 io burst가 큰 프로세스
* 1초를 cpu사용하고 io 발생 -> 다른 잡 돌아감
* cpu바운드 1초, io바운드 잠깐 쓰고 io 발생, 다시 cpu바운드 잡이 1초
* cpu bound에 io 바운드 끼워넣으면 10초면 끝난다.
* 하튼 끼워넣으면 빨라진다.
* ![[Pasted image 20231010005428.png]]
* FCFS는 약간의 문제를 가졌다. 앞에 긴 프로세스가 있으면, 뒤에 짧은 프로세스의 waiting이 길어진다
* 이를 보고 짧은 프로세스를 먼저 집어넣는 것.
* 단 non preemtive 스케줄링이다.
*  그럼 전체적으로 waiting time이 줄어들어서 좋다.
* cpu 사용시간은 어떻게 예측? -> 경험, 뭐 이정도 걸리더라
* cpu 사용시간을 정확히 모를 수 있는 게 문제가 된다.
* ![[Pasted image 20231010005955.png]]
* 1. cpu의 사용시간을 정확히 알 수 없다는 문제점.
* 2. A, B가 0초에 먼저 도착 A의 서비스타임이 작으니 A 실행, 2초 뒤 B밖에 없어서 B 넣음
* B끝나고 C,D,E가 도착했는데 모두 시간이 같으니 아무렇게나.
* 즉 AABBBBCDE 정도
* A는 2, B는 6, C는 4, D는 5 E는 6, 총 23(여기서 c, d, e는 도착시간을 고려해야 한다.)
* 만약sjf 적용안하고 b부터 시작하고, B끝나고 sjf 적용하면  BBBBCDEAA
* B는 4 ,C는 2 D는 3, E는 4, A는 9 총 22
* 즉 sjf를 적용 안 한게 더 낫다
* 왜?
* sjf가 잘 적용되려면 모든 잡이 동시에 도착해야 한다. 위는 중간에 새로운 조합들이 들어와서 최적의 결과가 나오지 않게 된다.
* 즉 조건
	* 1. 모든 잡의 시간을 알아야 하며
	* 2. 모두 동시에 도달해야함.
* ![[Pasted image 20231010010803.png]]
* non-preemtive가 아닌. 즉 선점적인 것., 즉 퀀텀을 적용하여 짧은 것을 퀀텀단위로 실행
* 1분마다 스케줄링한다고 가정하고 위의 상황 적용하면
	* A, B중 A먼저 시작,  
	* A 1분 후 스케줄링 A는 1분남고, B는 4분남은 -> A 선택
	* A끝남, B밖에 안남음, ->B 수행
	* B 1분 후 스케줄링, 이 순간 c, d, e 들어오고 모두 1,1,1, 남음 B는 3분
	* 즉 C 수행
	* D 수행
	* E수행
	* 그다음 BBB 수행
	* 즉 AABCDEBBB
	* A는 2, B는 9, C는 1, D는 2, E는 3
	* 합 17
* 단 여기서 context switching 시간은 0이라고 가정
* 단점 :
	* 미리 cpu 시간을 정확히 알아야함.
	* starvation 문제가 일어날 수 있다. 왜냐하면 B처럼 계속 밀릴 수 있기에.
	* 
* ![[Pasted image 20231010011342.png]]
* 이는 큐를 만들어서 큐에 들어오는 방식.
* quantum은 일정 시간만큼은 진행하도록 보장하는 것.
	* 물론 quantum 안의 프로세스가 자발적으로 종료하거나 인터럽트를 호출하면 중단될 수 있다.
* 퀀텀 다 쓰면 그 때 다시 스케줄링 한다.
* 위 케이스를 적용하면
	* ready que에 A,B들어있고 먼저 A가 들어왔다면
	* A 퀀텀만큼(1분이라하자) 실행.
	* 끝나면 A를 큐에 맨 뒤로 넣는다. 그럼 큐에 B A 존재
	* B 꺼내서 수행
	* B 끝나면 큐에 넣음
	* 다시 A 꺼내서 수행. 그럼 A는 끝나고 큐에 b만 존재 하는데, c, d,e 들어와서 큐에는 BCDE 존재
	* B를 큐에서 꺼내고 실행
	* CDE 수행하면 다 빠지고  B만 존재
	* B계속 수행
	* ABABCDEBB
	* a=3, b=9, c=2,d=3,e=4
	* 총 21
	* 만약 cde가 들어오면서 있던 a가 큐로 들어온다면 뭐 맘대로. 근데 cde를 먼저하는게 공평할 거 같다.
* 장점
	* starvation문제가 없다.
* 단점
* ![[Pasted image 20231010012657.png]]
* 퀀텀에 따라 많이 달라진다. 작으면 context switch 많아지고
* 크면 반응시간이 안좋아진다.
* ![[Pasted image 20231010012843.png]]
* 우선 순위를 정해서 cpu를 사용. 
* 레디 큐에 있는 프로세스 중에 가장 높은 프로세스를 cpu할당.
* 만약 같은 우선순위면 여러 방법들이 존재.
* 우선순위는 
	* 1. 사용자가 지불한 비용에 따라 정하고 이를 고정
	* 2. 프로세스가 진행되면서 바뀜. io bound process에게 우선 순위를 먼저 준다. 그럼 response time 이 좋아진다. (키보드 입력 같은 거니)
* f는 사용자가 퀀텀을 60초를 줬는데 60초 다 못쓰고 10초만 썼다면 f = 1/ 6 이고 
* 그럼 우선순위가 6이 된다.
* 단점 : 
	* ![[Pasted image 20231010013609.png]]
	* starvation이 발생할  수 있다. 자신보다 우선순위가 높은 프로세스가 계속 오면 밀린다.
	* \# 우선순위가 존재하면 항상 starvation이 존재.
		* 해결은 기다리는 시간이 길어질 수록 우선순위를 높여주는 메커니즘이 존재하면 된다.
		* 혹은 cpu를 많이 쓰면 우선순위를 낮춰주면 된다. 그럼 상대적으로 높아진다.
* ![[Pasted image 20231010013835.png]]
* 프로세스들은 같은 priority 그룹에 묶었다.
* priority4에는 3개가 존재. 이 세개 라운드로빈하여, 프로세스들을 모두 끝내
* 그다음에 priority3 라운드로빈
* ![[Pasted image 20231010014130.png]]
* 멀티플 큐( == 피드백 큐)
* 여러 개의 큐가 있는데 각각 다른 알고리즘 적용가능하고, 큐사이로 프로세스 이동가능
* 멀티플 큐는 타입을 나타낼 수 있다(배치, 인터랙티브 등)
* 각 큐에는 레디상태의 잡들이 연결되어있다.
* 우선 순위가 낮으면 퀀텀을 더 길게 가질 수 있다.
* 각 큐마다 우선순위가 존재. 같은 큐는 라운드 로빈 사용
* io bound잡은 빨리빨리 해서 퀀텀을 다 못 쓰고 끝나는 경우가 많다., 우선순위를 높게 준다.
* cpu bound잡은 자신 퀀텀을 다 쓰고 강제적으로 스위칭이 발생, 우선순위를 낮게 주는 대신 퀀텀을 길게 준다. 만약 퀀텀을 다 못 썼으면(io 발생으로 인해) io bound에 넣어 우선순위를 올려준다.
* 보통 iobound가 우선순위 높고 cpubound가 낮다.
* 어떤 프로세스가 cpu bound 특성을 많이 갖다가. iobound 특성을 갖는다면
* \# 여기서도 age없기에 starvation 발생할 수 있다.
* ![[Pasted image 20231010015414.png]]
* cpu 할당했다면, 할당된 cpu time 존재할 것이고. 
	* A = 10초
	* B = 20초 일떄
	* 둘다 1초를 썼다면
	* A 의 ratio 는 1/10
	* B의 ratio는 1/20
	* 이 중 적게 쓴 애 (작은 수)를 우선순위 높다 판단. 
	* 이렇게하면 B 사용 많아지고 비슷비슷해진다.
* cpu가 얼마나 할당해줬는지, 얼마나 썼는지, 다른 프로세스와 비교하는 과정을 거치면서 스케줄
* ![[Pasted image 20231010015752.png]]
* 퍼포먼스 assurance를 보장
* 로또가 100개 있다면 이를 프로세스한테 나눠주고, a 20 b 20 c60
* 복권 돌려서 가진 애가 cpu할당
* 쓴 복권은 버려진다. 즉  a가 40이면 결국에는 40을 사용하게 된다.(preformance assurance)
* 즉 복권 많은 쪽이 확률 높다.
* 즉 100개의 시간중 b는 반드시 20개 쓴다.
* performance assurance
	* 전체 시간중에 특정 프로세스가 얼마나 쓸 수 있는 지를 보장해준다.
* 프로세스들은 서로 티켓을 양도 가능. 즉 A가 이미 많이 처리해서 당장 들어갈 필요없다 싶을때 다른 프로세스에게 양도
* proprotinate scheduling
	* 초당 a는 10 b는 20 c는 25번 처리를  해야한다면.
	* 이를 다른 스케줄링과 다르게 보장해 줄 수 있다.
	* 즉 티켓을 이 비율대로 할당하면 된다.
* ![[Pasted image 20231010020619.png]]
* userA가 6개의 프로세스
* userB가 1개면
* A가 6배 받는 것은 불공평
* 유저 비율로 할당하는 것.
* ![[Pasted image 20231010021834.png]]
* 이벤트가 주기적 ,비주기적으로 구분
* ![[Pasted image 20231010021953.png]]
* 스케줄링을 했을 때 데드라인을 맞출 수 있냐가 핵심
* m개의 주기적인 이벤트가 발생하고
* 이벤트 i는 Pi만큼의 주기로 발생하고, Ci만큼의 시간을 요구
* 즉 주기안에 시간을 써야한다.
* 이 식의 의미는 
* 100ms 당 50ms를 채우고, 또 200당 30을 채우고
* 이렇게 채운 것들을 모두 합쳤을때 넘치지 않는지
*  저 식을 만족하면 모두 끼워 넣을 수 있다.