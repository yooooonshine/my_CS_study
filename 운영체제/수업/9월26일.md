* ![[Pasted image 20230926111212.png]]
* os는 스레드를 몰라, 프로세스만 있는 줄안다.
* ![[Pasted image 20230926111234.png]]
* 커널에는 프로세스테이블 밖에 없다. 오른쪽은 스레드 테이블도 존재, 이건 tcb 
* 라이브러리가 스레드를 구성, 즉 프로그램의 일부
* 즉 pthread create 등은 라이브러리 함수
* 원안의 네모가 라이브러리, join등의 함수를 여기서 받는다.
* ![[Pasted image 20230926111454.png]]
* user level 장점은 cheap, 그냥 function call 이므로 매우 빠르다. 커널도움을 전혀 받지 않는다. 
* 스레드간의 스위치등은 커널이 아닌 라이브러리가.
* user 스레드는 많이 만들어도 부담 x, keranl 스레드는 부담
* ![[Pasted image 20230926111727.png]]
* cpu가 두개면 cpu할당은 커널이 한다. cpu가 많이도 user 스레드는 충분히 할당 못한다. 한 프로세스안에 있는 여러 스레드 이기에. 즉 한 cpu가 빌 수 도 있다.
* 만약 한 프로세스 안의 스레드에서 read를 시스템 call 하면 한 프로세스가 전체 block되므로 사용가능한 다른 스레드도 멈춤
* page fault(메모리에 데이터 있을경우) -> 전체가 block
* 무한루프돌면 cpu 한 스레드가 다 써버린다.
* ![[Pasted image 20230926112211.png]]
* 한 스레드 블록되면 os가 다른 스레드 꺼내 cpu할당, 이 스레드는 다른 프로세스말고 자신 프로세스에서 스레드 할당하는 게 이득, 오버헤드가 작다.
* 라이브러리 필요x 
* 비쌈
* 각 스레드에서 tcb 유지해야됨.
* 프로세스 구성할 떄 모두 쓰레드로 하면 좋을까? 이건 한 프로세스 부분이 돌아가는것. 즉 메모리 공유하는데, 메모리 잘못쓰면 segment fault.
* ![[Pasted image 20230926112543.png]]
* 요즘 커널 스레드에도 유저스레드 적용하는 느낌
* 즉 os가 스레드를 아느냐 모르느냐가 user- kernel 레벨 스레드 구분


* scheduler activation 패스
* ![[Pasted image 20230926112743.png]]
* palleler 할때 , 동기화 문제, 즉 한 자원을 공유할 때, 
* 멀티스레드에서 스레드가 협동해야함. 왜? resource를 share하기에 조절 필요, 이 조절을 synchronizaiton 즉 문제 없도록 하는 것
* 즉 coordinate 해줘야 race condtion이 발생하지않는다.
* 
* ![[Pasted image 20230926112927.png]]
* 은행에 서버가 있고 내 계정이 있고 거기에 balance가 있을때 , 정보가 공유되면,  balance에서 2000원 뺄려면 balance정보가져와서 amount를 빼면 8000원 될떄 이를 다시 서버에 넣는다
* 왼쪽 오른쪽 cpu가 두개.
* ![[Pasted image 20230926113426.png]]
* 빨강에서 balace 8000
* 한 쪽 cpu가 매우 느려져서 연두가 동작하기 시작하면 문제 연두는 10000원에서 9000됨
* 하튼 서로서로 돌아가는게 엇갈리니까,
* ![[Pasted image 20230926113708.png]]
* 즉 위는 타이밍에 의존적이다.
* ![[Pasted image 20230926113821.png]]
* ![[Pasted image 20230926113933.png]]
* 즉 메모리의 전역변수 같은 경우, 무조건 synchronization해줘야한다.
* ![[Pasted image 20230926114041.png]]
* mutal exclusion을 이용하여 race condition을 해결
* shared resource을 access하는게 critical region
* mutex는 mutual exclustion
* 즉 한 곳이 실행되면 다른 곳은 멈추게 하는 것.
* ![[Pasted image 20230926114316.png]]
* 상호 배제 하려면 위를 4가지를 만족해야함. 
* bounded waiting은 대기하는게 무한적 대기하면 안된다. 들어갈 수 있어야함
* 속도를 가정하면 , 다른 속도 cpu에서는 문제 있을 수도
* progress는 a가 나왔는데도 b가 못들어가면 안된다는 것. 즉 진행할 수 있도록 조치를 취해줘야한다.
* ![[Pasted image 20230926114728.png]]
* 이거는 주소공간을 공유한다는 가정하에 사용되는 방법
* ![[Pasted image 20230926114815.png]]
* disabling interrupts
	* cpu가 하나인 환경에서 한 쓰레드 실행되다 멈추고 다른 쓰레드 실행, 즉 프로세스 스위치가 일어난것 os가 개입, 즉 interrupt가 발생, interrupt가 발생하지않도록 disable해준다, 그럼 mutaul exclusion 가능
	* 근데 cpu가 두개면, 인터럽트 disable 해도 두 쓰레드 동시 실행가능....
*  lock variables
	* lock은 두프로세스가 동시에 접근가능한 변수, 즉 lock걸린것은 계속 while돈다
	* 0이 되면 그떄 들어간다.
	* lock = 1 은 들어왔을 때 lock이 0이었기에
	* no assumption조건을 만족 x 즉 lock = 1이 오래걸려서  아직 0이 아니라 두 스레드가 들어오게 된다. 이로 인해 mutual exclusion이 안된다.
	* 
* ![[Pasted image 20230926120642.png]]
* busy waiting은 진행안하고 기다리는 것 while문 계속도는것
* spin lock: lock이 바뀌길 기다림
*  a,b 함수 같이 도는데 한쪽이 들어갔다 나오면 다른 쪽이 들어가게 된다, 즉 turn 값은 0,1이므로 critical region이 발생할 수 없다.
	* 유일하게 progress를 만족 못시킨다. 
	* 만약 한쪽의 noncritical이 매우 늦게 끝나면 한쪽이 while에 갇히게된다. 즉 critical region에 아무도 없는데 아무도 못들어감
	* 즉 pogress condition을 만족 x. 즉 한쪽이 다른쪽을 못들어가게 막았다.
* ![[Pasted image 20230926121944.png]]
* 위를 해결
* 집 가서 보기!
* 근데 소프트웨어가 너무 길고, 증명하기도 쉽지않아(물론 증명되어있긴함)
* ![[Pasted image 20230926122149.png]]
* 더 좋은 방법 소프트웨어 지원이아닌, 하드웨어적 지원
* test and set : 메모리 로케이션 값을 읽어들이고, 그 주소 위치를 1로 세팅(즉 메모리 버스 두번사용 읽기 쓰기)
* tsl(lock) 이면 기존lock 의 값을 반환하면서 1로 세팅
* atomic하게 돌아간다: 한번에 돌아간다 , 즉 나누어질 수가 없다. 즉 다른거 멈춘다.
* 즉 인터럽트가 발생해도 instruction이 완료 된 후에야
* tsl이 즉 lock값 세팅하는것도 묶어주기에 위 문제 x
* ![[Pasted image 20230926123122.png]]
* register에 lock 가져오고 cmp로 #0과 regsiter 비교
* ![[Pasted image 20230926123155.png]]
* xchg는 lock값을 register로 register를 lock으로 즉 swap
* 

* ![[Pasted image 20230926123324.png]]
* priority inversion problem은 한쪽이 우선 순위가 높아 한쪽에 계속 할당하면 다른 건 cpu할당 못받아 계속 돈다. 즉 계속 lock만 체크
* ![[Pasted image 20230926123620.png]]
* sleep and wakeup이라는 시스템 콜
* sleep은 block 되는 것 
* 프로듀서가 물건을 만들어내서 4개의 버퍼에 집어넣으면 여기서 컨슈머가 꺼내서 사용
* 만약 버퍼가 꽉차면 프로듀서가 멈춰야함
* ![[Pasted image 20230926123736.png]]
* 이 코드 자체는 문제가 있다..
* N은 버퍼 크기, 즉 버퍼 꽉차면 SLEEP
* counter가 n-1 일떄 프로듀서가 슬립할지도-> 꺠워줌
* 이로 인해 궁극적으로는 세마포어 사용
* 문제 
	* 1:insert와 remove 동시에 일어날수도
	* 2: counter 업데이트 문제: 즉 카운터 업데이트 섞인다면
	* 3: if count == N 이랑 sleep 의 시간차가 있을떄 consumer가 소모를하여 계속소모해 sleep에 들어간다면, 둘다 슬립에 들어감.
	* 즉 컨디션 체크 등이 atomic 하지 않아서, 문제 n체크과 sleep을 atomic하게 해야함.
* 