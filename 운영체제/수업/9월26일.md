* ![[Pasted image 20230926111212.png]]
* os는 스레드를 몰라, 프로세스만 있는 줄안다.
* ![[Pasted image 20230926111234.png]]
* 커널에는 프로세스테이블 밖에 없다. 오른쪽은 스레드 테이블도 존재, 이건 tcb 
* 라이브러리가 스레드를 구성, 즉 프로그램의 일부
* 즉 pthread create 등은 라이브러리 함수
* 원안의 네모가 라이브러리, join등의 함수를 여기서 받는다.
* ![[Pasted image 20230926111454.png]]
* user level 장점은 cheap, 그냥 function call 이므로 매우 빠르다. 커널도움을 전혀 받지 않는다. 
* 스레드간의 스위치등은 커널이 아닌 라이브러리가.
* user 스레드는 많이 만들어도 부담 x, keranl 스레드는 부담
* ![[Pasted image 20230926111727.png]]
* cpu가 두개면 cpu할당은 커널이 한다. cpu가 많이도 user 스레드는 충분히 할당 못한다. 한 프로세스안에 있는 여러 스레드 이기에. 즉 한 cpu가 빌 수 도 있다.
* 만약 한 프로세스 안의 스레드에서 read를 시스템 call 하면 한 프로세스가 전체 block되므로 사용가능한 다른 스레드도 멈춤
* page fault(메모리에 데이터 있을경우) -> 전체가 block
* 무한루프돌면 cpu 한 스레드가 다 써버린다.
* ![[Pasted image 20230926112211.png]]
* 한 스레드 블록되면 os가 다른 스레드 꺼내 cpu할당, 이 스레드는 다른 프로세스말고 자신 프로세스에서 스레드 할당하는 게 이득, 오버헤드가 작다.
* 라이브러리 필요x 
* 비쌈
* 각 스레드에서 tcb 유지해야됨.
* 프로세스 구성할 떄 모두 쓰레드로 하면 좋을까? 이건 한 프로세스 부분이 돌아가는것. 즉 메모리 공유하는데, 메모리 잘못쓰면 segment fault.
* ![[Pasted image 20230926112543.png]]
* 요즘 커널 스레드에도 유저스레드 적용하는 느낌
* 즉 os가 스레드를 아느냐 모르느냐가 user- kernel 레벨 스레드 구분


* scheduler activation 패스
* ![[Pasted image 20230926112743.png]]
* palleler 할때 , 동기화 문제, 즉 한 자원을 공유할 때, 
* 멀티스레드에서 스레드가 협동해야함. 왜? resource를 share하기에 조절 필요, 이 조절을 synchronizaiton 즉 문제 없도록 하는 것
* 즉 coordinate 해줘야 race condtion이 발생하지않는다.
* 
* ![[Pasted image 20230926112927.png]]
* 은행에 서버가 있고 내 계정이 있고 거기에 balance가 있을때 , 정보가 공유되면,  balance에서 2000원 뺄려면 balance정보가져와서 amount를 빼면 8000원 될떄 이를 다시 서버에 넣는다
* 왼쪽 오른쪽 cpu가 두개.
* ![[Pasted image 20230926113426.png]]
* 빨강에서 balace 8000
* 한 쪽 cpu가 매우 느려져서 연두가 동작하기 시작하면 문제 연두는 10000원에서 9000됨
* 하튼 서로서로 돌아가는게 엇갈리니까,
* ![[Pasted image 20230926113708.png]]
* 즉 위는 타이밍에 의존적이다.
* ![[Pasted image 20230926113821.png]]
* ![[Pasted image 20230926113933.png]]
* 즉 메모리의 전역변수 같은 경우, 무조건 synchronization해줘야한다.
* ![[Pasted image 20230926114041.png]]
* mutal exclusion을 이용하여 race condition을 해결
* shared resource을 access하는게 critical region
* mutex는 mutual exclustion
* 즉 한 곳이 실행되면 다른 곳은 멈추게 하는 것.
* ![[Pasted image 20230926114316.png]]
* 상호 배제 하려면 위를 4가지를 만족해야함. 
* bounded waiting은 대기하는게 무한적 대기하면 안된다. 들어갈 수 있어야함
* 속도를 가정하면 , 다른 속도 cpu에서는 문제 있을 수도
* progress는 a가 나왔는데도 b가 못들어가면 안된다는 것. 즉 진행할 수 있도록 조치를 취해줘야한다.
* ![[Pasted image 20230926114728.png]]
* 이거는 주소공간을 공유한다는 가정하에 사용되는 방법
* ![[Pasted image 20230926114815.png]]
* disabling interrupts
	* cpu가 하나인 환경에서 한 쓰레드 실행되다 멈추고 다른 쓰레드 실행, 즉 프로세스 스위치가 일어난것 os가 개입, 즉 interrupt가 발생, interrupt가 발생하지않도록 disable해준다, 그럼 mutaul exclusion 가능
	* 근데 cpu가 두개면, 인터럽트 disable 해도 두 쓰레드 동시 실행가능....
*  lock variables
	* lock은 두프로세스가 동시에 접근가능한 변수, 즉 lock걸린것은 계속 while돈다
	* 0이 되면 그떄 들어간다.
	* lock = 1 은 들어왔을 때 lock이 0이었기에
	* no assumption조건을 만족 x 즉 lock = 1이 오래걸려서  아직 0이 아니라 두 스레드가 들어오게 된다. 이로 인해 mutual exclusion이 안된다.
	* 
* ![[Pasted image 20230926120642.png]]
* busy waiting은 진행안하고 기다리는 것 while문 계속도는것
* spin lock: lock이 바뀌길 기다림
*  a,b 함수 같이 도는데 한쪽이 들어갔다 나오면 다른 쪽이 들어가게 된다, 즉 turn 값은 0,1이므로 critical region이 발생할 수 없다.
	* 유일하게 progress를 만족 못시킨다. 
	* 만약 한쪽의 noncritical이 매우 늦게 끝나면 한쪽이 while에 갇히게된다. 즉 critical region에 아무도 없는데 아무도 못들어감
	* 즉 pogress condition을 만족 x. 즉 한쪽이 다른쪽을 못들어가게 막았다.
* ![[Pasted image 20230926121944.png]]
* 위를 해결
* 집 가서 보기!
* 근데 소프트웨어가 너무 길고, 증명하기도 쉽지않아(물론 증명되어있긴함)
* ![[Pasted image 20230926122149.png]]
* 더 좋은 방법 소프트웨어 지원이아닌, 하드웨어적 지원
* test and set : 메모리 로케이션 값을 읽어들이고, 그 주소 위치를 1로 세팅(즉 메모리 버스 두번사용 읽기 쓰기)
* tsl(lock) 이면 기존lock 의 값을 반환하면서 1로 세팅
* atomic하게 돌아간다: 한번에 돌아간다 , 즉 나누어질 수가 없다. 즉 다른거 멈춘다.
* 즉 인터럽트가 발생해도 instruction이 완료 된 후에야
* tsl이 즉 lock값 세팅하는것도 묶어주기에 위 문제 x
* ![[Pasted image 20230926123122.png]]
* register에 lock 가져오고 cmp로 #0과 regsiter 비교
* ![[Pasted image 20230926123155.png]]
* xchg는 lock값을 register로 register를 lock으로 즉 swap
* 

* ![[Pasted image 20230926123324.png]]
* priority inversion problem은 한쪽이 우선 순위가 높아 한쪽에 계속 할당하면 다른 건 cpu할당 못받아 계속 돈다. 즉 계속 lock만 체크
* ![[Pasted image 20230926123620.png]]
* sleep and wakeup이라는 시스템 콜
* sleep은 block 되는 것 
* 프로듀서가 물건을 만들어내서 4개의 버퍼에 집어넣으면 여기서 컨슈머가 꺼내서 사용
* 만약 버퍼가 꽉차면 프로듀서가 멈춰야함
* ![[Pasted image 20230926123736.png]]
* 이 코드 자체는 문제가 있다..
* N은 버퍼 크기, 즉 버퍼 꽉차면 SLEEP
* counter가 n-1 일떄 프로듀서가 슬립할지도-> 꺠워줌
* 이로 인해 궁극적으로는 세마포어 사용
* 문제 
	* 1:insert와 remove 동시에 일어날수도
		* insert item remove아이템 모두 버퍼를 access 해야하는데 mutual exception하지 못한다.
	* 2: counter 업데이트 문제: 즉 카운터 업데이트 섞인다면
		* count =count -1은 count를 load하고 decrement하고 저장하는데, 이 가져오고 나서 상대쪽에서 count를 업데이트 해버리면, 가져온 값으로 decrement하기에 mutual exclusive하지 못하다.
	* 3: if count == N 이랑 sleep 의 시간차가 있을떄
		* consumer가 소모를하여 계속소모해 sleep에 들어간다면, 둘다 슬립에 들어감.
		*  즉 컨디션 체크 등이 atomic 하지 않아서, 문제 n체크과 sleep을 atomic하게 해야함.
* race condition : 어쩔떄 제대로 돌아가고, 어쩔떄 제대로 못돌아간다. 결과가 타이밍에 따라서 바뀐다. 이를 해결하기 위해 mutual exclusive하계 설계하는 것.
* ![[Pasted image 20231009170259.png]]
* 세마포어는 락보다 하이레벨,
* 세마포어는 두개의 operation 
	* down 이를 P()라고도 부름
		* 세마포어가 0이하면 block 아니면 1감소하고 함수에서 나옴.
		* 0보다 아래면 wait, 즉 block, sleep
		* 깨어지면 down을 다시 실행
	* up 이를 V() 라고도 부름
		* 세마포어 1증가.
		* 만약 기다리는 wait가 있으면 꺠움
		* 여러명이면 한명 골라서 꺠움
		* 깨운 것은 ready상태에서 cpu 버퍼링
		* 깨어나면 다시 down 시작, 근데 이 사이에 세마포어가 다시 0 되면 다시 sleep 아니면 실행
* 아토믹 한 점이 중요.
* ![[Pasted image 20231009170853.png]]
* counting semaphore는  0부터 N까지
* binary는 0하고 1만
* ![[Pasted image 20231009170938.png]]
* 세마포어변수인 mutex, 
	* 1.상호배제를 위해
* full, empty
	* full은는 차있는 버
	* empty는 비어있는 버퍼 숫자를 카운트
	* 2. 꽉차면 sleep, 버퍼가 비면 wake등을 위해 사용
* 스레드는 세마포어를 안 사용해도 되는 synchronize기법들이 있다.
* ![[Pasted image 20231009171151.png]]
* sleep 했다가 꺠어나면 함수 다시 돌리는게 포인트
* remove item from buffer는 위에서 remove 아이템 , buffer를 access하기에 상호배제 필요,
* down(mutex)가 1이어서 생산자 소비자 둘중먼저 down 실행, 만약 생산자가 먼저하면 mutex는 0 되고 add에서 수행, 이 때 consumer는 mutex가 0이라 wait로 돌아간다.
* 끝나면 프로듀서가 up(mutex) -> mutex 1증가 -> consumer wake up -> 빠져나온다.
* consumer 의 down(mutex)로 진입. 수행.
* 깨어났다고 mutex가 반드시 1인 보장은 없다. 이 사이에 다른 producer가 down할 수 있다.
* 이래서 atomic 필요
* 싱크로나이즈
	* count안 쓰고 empty하고 full을 쓴다.
* 여기서 만약 mutex가 2이면 다운이 동시에 두 개가 일어날 수 있다.
* empty = n 이다. 비어있는 버퍼 수.
* down 과 up이 producer와 consumer에서 반대에 있는 이유는 프로듀스에서 full을 업해야지 consumer의 down full이 동작할 수 있기에 서로 아다리가 맞는다.
* context  switching이 어디서든 일어나도 상관없다. atomic하기에 ![[Pasted image 20231009172901.png]]
* 세마포어가 간단한 문제푸는 데는  좋지만 어려운 문제에는 적용하기 어렵다.
* 세마포어 조금만 줄 바꿔도 버그가 나므로 사용하기 어렵.

* 뮤텍스 넘어간다.
* ![[Pasted image 20231009191122.png]]
* 프로세스들은 프로세스내에서 서로 데이터를 공유 못하므로 다른 방법을 찾아야 한다. 
	* 커널에 저장되어 사용될 수 있다.
	* 프로세스는 메모리를 공유하게 할 수 있는데. A 영역 B영역을 곂치게 할 수 있다(shared memory), 이 안에 lock variable 공유해서 세마포어 사용.
	* 혹은 파일을 공유해서 할 수 있다. 다만 좋은 방법은 아니다. io 발생해서 느리기에.
* ![[Pasted image 20231009191415.png]]
* 모니터는 프로그램언어에서 지원해준다. 세마포어는 그냥 c언어등에서도 사용가능하다.
* 데이터 access하려면 monitor이용
* 모니터가 주먹구구 접근 막아준다.
* ![[Pasted image 20231009191610.png]]
* 모듈식으로 선언
* 안에 함수들이 있는 데 서로 상호배제
* 함수를 통해서만 접근 가능
* 프로시저가 모니터에 하나만 들어간다.
* 
* ![[Pasted image 20231009191658.png]]
* 모니터는 기본 상호배제.
* 모니터안으로 들어간다. => 스레드나 함수가 모니터를 불러 들어갔다.
* 들어갈 수 있는 것은 딱 한명. 즉 누가 있으면 다른 사람은 못들어간다.
* ![[Pasted image 20231009191809.png]]
* 이건 시그널을 보내는 것.
* 모니터 안에서만 사용된다.
* wait and signal은 sleep and wake와 비슷
* wait는 특정 조건을 기다리는 것
* signal은  꺠워주는 것
* ![[Pasted image 20231009191905.png]]
* 위 full, empty는 특정 값을 갖고 있지 않다 
* remove은 item을 빼서 리턴
* count가 1이면 , 기존에 empty가 자고 있었을테니까. empty를 깨워준다.
* 
* sleep and wait랑 논리가 비슷한 데 왜 이건 race condition이 없을까?
	* count, item 관련해서 상호배제 하지 않았다.
	* 근데 여기서 wait가 아니면, insert_item , count 계산만 해서 상호배제된다.
* wait면 모니터밖으로 나와서 다른 애가 진입할 수 있게 해준다.
* 여기서 모니터로 들어간 insert라는 프로세스가 wait이면 모니터에서 나와서 조건동기 큐에 들어간다.
* ![[Pasted image 20231009193939.png]]
* 호어는 웨이팅한애가 먼저
* 메사는 시그널을 먼저 보낸 애가 수행
	* 즉 위 remove에서 signal 보냈다면, 
		* 이때 호어는 모니터에 있던 애 나오고, wait 한애가 들어가며
		* 메사는 signal 밑에 코드가 있다면 마저 진행, 즉 이 방식에서는 밑에서 count를 맘대로 바꿀수 있으므로, inset는 count를 다시 확인해야한다. 근데 여기서 다시 확인하지 않아, 즉 위 코드는 메사모니터가 아니다.
* 한센
	* 시그널 보낸 애는 항상  그 문장에서 끝나야 돼. 즉 function의 마지막 문장이 되어야해. 그럼 끝나고 나외까. wait에서 다시 조건 확인할 필요가 없다.
* ![[Pasted image 20231009194558.png]]
* 이건 함수하나가 상호배제 되므로, 병령 처리, 즉 동시성이 줄어든다.
* 즉 느려질 수 있다.
* 만약 언어가 제공 안하면 못 쓴다.
* 분산환경에서는 못 쓴다.(세마포어,모니터등은 스레드나 프로세스가 모두 access 가능하다는 가정에서 짠 것.  shared memory,즉 메모리에 두고 모두가 접근 가능하다는 가정인데,) 분산환경에서는 메모리가 공유되지 않으므로 처리 불가
* 분산환경은 각각 cpu, 메모리 쌍으로 따로 있고, 네트워크로 통신하는 것.
* ![[Pasted image 20231009194943.png]]
* 분산환경(네트워크로 연결된 시스템)에서는 메모리가 공유가 안되므로, 메세지 패싱으로 해결
* 센드. 리시브라는 시스템 콜. 
	* send는 destination으로 message를 보내는 것.
	* receive는 저쪽소스에서 메세지를 보낼떄까지 block
	* 
* ![[Pasted image 20231009195714.png]]
* 메세지로 실어보내는 것은 item
* 컨슈머가 빈 바구니를 보내면 생산자가 바구니에 item을 넣어 보냄.
* 초창기에 빈 바구니는 컨슈머가 만든다.
* 만약 컨슈머가 바구니 비우는 게 느리다 -> 꽉 찬 바구니 밀리고, 빈바구니가 생성자한테 안와,.그럼 receive에서 블락된다. 
* 생산자, 소비자 모두 receive에서 블럭된다.
* ![[Pasted image 20231009200540.png]]
* 지금까지 동기화(세마포어등) 메커니즘과 다르다. 이건 어떤 패턴
* 각각 a,b,c,d 계산 후 모으고 ,계산 후 모으고, 하면 어느 지점에 스탑해서 결과를 받아 모으고 다시 시작
* 이렇게 stop 시키는 것을 barrier라하고 이렇게 동기화하는 것은 barrier 동기화라고 한다.
* ![[Pasted image 20231009200747.png]]
* 철학자들이 스파게티를 먹을때 두개의 포크가 필요하고 다 먹으면 끝남.
* 각 사이에 포크가 한 개씩 존재.
* 즉 포크가 공유되는 리소스
* 데드락: 만약 모두가 포크를 하나씩 가져간 상황이면, 가져갈 포크가 서로 없다.
* ![[Pasted image 20231009200942.png]]
* 포크를 못가져오면 블락.
* 따라서 포크를 하나 가지고 있는 데 블락되면 내려 놓으면 된다.
* 근데 만약에 동시에 다들 왼쪽 포크 들고 왼쪽 내려놓고 반복할 수 도있다. 이건 액션을 계속 취하니까 데드락은 아니지만 모두 굶게 된다. (race condition)
* 즉 내려놓는 시간을 랜덤등으로 해결할 수 도 있다.
* ![[Pasted image 20231009201658.png]]
* 