* context switch 는 a프로그램에서b프로그램으로
* ![[Pasted image 20230925161324.png]]
* A가 수행하면서 B access 막는 것
* main 안에 f, g함수가 실행될 떄, 둘이 연관이 없다면 동시 실행 가능,  각각을 thread라고 지정하면 알아서 cpu가 분기를 해서 f, g 따로 cpu에서 돌게 한다. 즉 한 프로그램에서 동시에 할당받게 하는 것.
* ![[Pasted image 20230925161530.png]]
* web server는 getrequest를 만들어 request가 오면 타입에 따라서 a면 a수행후 리퀘스트를 닫아. 이떄 여러 클라이언트가 요구할때 순차적이라면 한참 기다려야한다. 이를 해결하기 위해
* fork해서 a 돌리고 그럼 b를 받을 수 있고, 그럼 fork해서 b 처리, 그 다음 바로 c 즉 cpu가 많으면 동시에 여러개 처리 가능.
* multiprocessor란 cpu 많음, 그럼 각각 requset 동시 처리가능. 그럼 fork를 해야한다. 정보를 주고 받을려면 os가 관리해서 소켓등으로 정보 교환(혹은 빠르게 메모리 공유) 여기선 메모리공유, 즉 child 리퀘스트처리와 메모리 공유
* 근데 프로세스 만들떄마다 pcb 등 여러개 처리해야한다. 일이 많아
* ![[Pasted image 20230925162129.png]]
*  프로세스들끼리 공통점이 많아, 수행하는 코드는 달라도,나머지는 다 똑같다.
* f, g function을 fork해서 처리할 필요가 있을까라는 생각 왜냐면 같은 것을 많이 물려받기에 -> process안에서 execution하는 thread of control를 나눠보자.
* 즉 process에서 resouce 공유 thread of eexcutoin 여러개
* ![[Pasted image 20230925162415.png]]
* 물론 cpu가 하나여도 한 쓰레드가 블록되어도 다른 쓰레드 돌리면 돼
* ![[Pasted image 20230925162657.png]]
* ![[Pasted image 20230925162835.png]]
* 기존에는 프로세스당 쓰레드 하나였으나, 이제는 쓰레드를 나누고 각각 cpu 할당
* ![[Pasted image 20230925162920.png]]
* 왼쪽은 프로세스에 필요했던건 , 오른쪽은 쓰레드 나누면서 생긴 테이블
* ![[Pasted image 20230925163039.png]]
* 보통은 function 단위로 thread를 할당
* f, g 돌아가면 stack에 먼저 main 쌓이고 그다음 f, 그다음 g 쌓인다.
* 만약 f안에서 k를 호출하면 f밑에 k 쌓는다. 근데 g는? 이미 g가 차지하고 있다 -> overwrite하면 g가 망가져, 즉 memory공간이 쓰레드마다 스택이 따로 만들어져야 한다.
* ![[Pasted image 20230925163609.png]]
* 이와 같이 하면 overwrite할 필요가 없다.
* 특정 쓰레드안에서 k 함수 실행되면 각 스택밑에 쌓인다. 즉 남의 스택에는 access 못한다.
* 만약 한 쓰레드가 너무 많아져서 아래 쓰레드 위치를 침범하면?(예 recursive 무한하게)
* 그래서 특정 스레드밑에는 갭을 만들어서여기를 침범하면 알려준다.
* ![[Pasted image 20230925164131.png]]
* 프로세스 만드는 것보다 쓰레드 만드는 게 쉽다. 4.5ms 보면 알 수 있다.
* ![[Pasted image 20230925164255.png]]
* 쓰레드 만들어주는 콜
* create는 프로세스 fork
* join은 wait
* 리눅스는 이걸 clone으로 만드는 데 프로세스도 clone으로 만들어줌 즉 유사!
* ![[Pasted image 20230925164435.png]]
* printhello라는 함수를 기반으로 쓰레드 만듬, thread0에는 할당된 쓰레드 id가 들어감, void는 함수 argument, 0 ,1등의 printhello의 id
* printf가 끝날떄까지 멈춰라 -> join
* 