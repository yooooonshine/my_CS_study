* ## Chapter 3 memory management
* ![[Pasted image 20231016161305.png]]
* phisical메모리 고려하지 않고 코드를 짤떄 virtual 이용
* 또한 효율적으로 공간 사용하려고 노력
* ![[Pasted image 20231016161514.png]]
* primary가 dram, 이를 관리해주는 게 os 물론 sencondary도 os가 처리
* sencondary는 ssd, io를 통해
* Tertiary는 cd등
* L1, L2 chche는 cpu 하드웨어에서 알아서
* ![[Pasted image 20231016161702.png]]
* ROM : read only memory
* virtual을 안쓴다면 MOV R1,1000 처럼 바로 dram 위치에다가 저장
* 일반적인 경우에는 1000에 virtual 주소가 적힌다.
* 일반적으로 컴파일러가 돌릴 때 사용하는 주소는 virtual 주소공간을 사용한다.
* ![[Pasted image 20231016161846.png]]
* 0부터 16k공간 사용할 수 있다고 생각하고 compile한다. 일일이 공간 확인하지 ㅇ낳고 virtual 가정한다.
* JMP 24로 24번지 이동
* c는 physical dram 이고 실제 공간은 가상 주소랑 다르다.
* 문제
	* 0번지에서 시작하다가 context switch발동해 16384로 이동하면 다음 jmp 28면 add가 실행된다. 
	* 24아니고 20000등 자기 메모리를 넘어간 위치를 실행하려한다.
* 해결
	* relocation
		* 28을 16412(28 + 16384)로 바꿔준다.
* ![[Pasted image 20231016162744.png]]
* ![[Pasted image 20231016162919.png]]
* 주소공간: process가 access 할 수 있는 adrress집합
* physical : dram의 공간을 의미
* logical: 프로그램에서 사용하는 공간
* \# 참고로 위 dram공간이 반드시 0부터 시작한다는 보장은 없다.
* \# 인텔 32bit 아키텍쳐다 -> 주소공간의 크기를 나타낸다. 만약 cpu가 32비트이면 64bit윈도우 못깐다.
* 저 위의 주소는 일반적으로 logical address
* 만약 physical 쓰려면 dram이 이 주소를 알고 있어야함
* 
* 
* ![[Pasted image 20231016163128.png]]
* ![[Pasted image 20231016163631.png]]
* cpu가 이와 버스로 연결되어있다. cpu에서 28달라하면 16412줘야한다.
* 그럼 baseregister와 버스로 들어오는 값을 합친다.
* 즉 가상주소를 모두 shift한 것
* 아래 공간의 basereigister는 0
* base register값은 pcb에 저장된다.
* limit register는 사이즈를 저장해둔다.
* 즉 위에서 logical 20000이면 limit register 크기(16384)를 넘었다. -> 에러(fault) -> os가 가동해서 처리
* ![[Pasted image 20231016163809.png]]
* reloc reg =base register
* 이 계산하는 게 MMU이다.
	* additon하고 comparsion은 addition이 더 빠르고 둘다 한싸이클안에 끝나도록 구
* 아까는 loader가 이 계산을 처리해줬다. 
* ![[Pasted image 20231016164843.png]]
* physical memory가 충분하지 못한 경우가 많고 이럼 disk에 저장한다.
* 추후 프로세스가 들어올려 했는데 공간이 부족하면 하나 뺴야한다.
* 이렇게 저장하는 공간을 swaparia라고 한다.
* ![[Pasted image 20231016164804.png]]
* swapping 프로세스 전체가 메모리로 들어온다,
* virtual memory(paging)
	* 이는 프로세스크기가 너무 커서 메모리에 못 들어올 때,
