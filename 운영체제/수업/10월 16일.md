* ## Chapter 3 memory management
* ![[Pasted image 20231016161305.png]]
* phisical메모리 고려하지 않고 코드를 짤떄 virtual 이용
* 또한 효율적으로 공간 사용하려고 노력
* ![[Pasted image 20231016161514.png]]
* primary가 dram, 이를 관리해주는 게 os 물론 sencondary도 os가 처리
* sencondary는 ssd, io를 통해
* Tertiary는 cd등
* L1, L2 chche는 cpu 하드웨어에서 알아서
* ![[Pasted image 20231016161702.png]]
* ROM : read only memory
* RAM: random access memory
* virtual을 안쓴다면 MOV R1,1000 처럼 바로 dram 위치에다가 저장
* 일반적인 경우에는 1000에 virtual 주소가 적힌다.
* 일반적으로 컴파일러가 돌릴 때 사용하는 주소는 virtual 주소공간을 사용한다.
* 구성은 중요x
* 
* ![[Pasted image 20231016161846.png]]
* 0부터 16k공간 사용할 수 있다고 생각하고 compile한다. 일일이 공간 확인하지 않고 virtual 가정한다.
* JMP 24로 24번지 이동
* c는 physical dram 이고 실제 공간은 가상 주소랑 다르다.
* 문제
	* 0번지에서 시작하다가 context switch발동해 16384로 이동하면 다음 jmp 28면 add가 실행된다. 
	* 24아니고 20000등 자기 메모리를 넘어간 위치를 실행하려한다.
* 해결
	* relocation
		* 28을 16412(28 + 16384)로 바꿔준다.
* ![[Pasted image 20231016162744.png]]
* ![[Pasted image 20231016162919.png]]
* 주소공간: process가 access 할 수 있는 adrress집합
* physical : dram의 공간을 의미
* logical: 프로그램에서 사용하는 공간
* \# 참고로 위 dram공간이 반드시 0부터 시작한다는 보장은 없다.
* \# 인텔 32bit 아키텍쳐다 -> 주소공간의 크기를 나타낸다. 만약 cpu가 32비트이면 64bit윈도우 못깐다.
* 저 위의 주소는 일반적으로 logical address
* 만약 physical 쓰려면 dram이 이 주소를 알고 있어야함
* 
* 
* ![[Pasted image 20231016163128.png]]
* ![[Pasted image 20231016163631.png]]
* cpu가 이와 버스로 연결되어있다. cpu에서 28달라하면 16412줘야한다.
* 그럼 baseregister와 버스로 들어오는 값을 합친다.
* 즉 가상주소를 모두 shift한 것
* 아래 공간의 basereigister는 0
* base register값은 pcb에 저장된다.
* limit register는 사이즈를 저장해둔다.
* 즉 위에서 logical 20000이면 limit register 크기(16384)를 넘었다. -> 에러(fault) -> os가 가동해서 처리
* ![[Pasted image 20231016163809.png]]
* reloc reg =base register
* 이 계산하는 게 MMU이다.
	* additon하고 comparsion은 addition이 더 빠르고 둘다 한싸이클안에 끝나도록 구현
* 아까는 loader가 이 계산을 처리해줬다. 
* ![[Pasted image 20231016164843.png]]
* physical memory가 충분하지 못한 경우가 많고 이럼 disk에 저장한다.
* 추후 프로세스가 들어올려 했는데 공간이 부족하면 하나 뺴야한다.
* 이렇게 저장하는 공간을 swap aria라고 한다.
* ![[Pasted image 20231016164804.png]]
* swapping 프로세스 전체가 메모리로 들어온다,
* virtual memory(paging)
	* 이는 프로세스크기가 너무 커서 메모리에 못 들어올 때,
* ![[Pasted image 20231017111930.png]]
	* 메인메모리에 A프로그램 올라옴
	* (c)에서 A가 block 된다면 cpu할당해도 못사용하니까 메모리 차지하는 것는 비효율적,
	* (d)에서 A를 swap aria에 저장
	* (e) D를 swaparia에서 가져옴
	* A가 io다끝나도 메모리에 없으면 실행할 수 없다. e를 보면 두 나눠진 공간 합치면 들어올 수 있는데 못들어옴
	* fragmentatoin문제 
		* 공간이 나눠져있어서 못들어옴
		* 해결
			* compaction
	* (b)에서 진행하다ㅏㄱ A가 커질 수 있다. 
		* 해결
			* b를 위로 민다
			* A를 swap aria로 뻈다ㅏ가 더 큰공간으로 이동
* ![[Pasted image 20231017112516.png]]
* 늘어나더라도 수용가능한 공간을 배정
* b처럼 stack과 data공간을 만들어 가운데로 채워지도록
* 다만 사용 안되면 낭비 문제가 있을 수 있다.
* ![[Pasted image 20231017112622.png]]
	* bitmap
		* 1이면 해당영역이 사용되는 중. 0이면 비어있음, 
		* 비트하나당 1k즉 10개의 공간이 있는 것 A는 5k영역
		* A가 4.5k이면 5k를 써야한다. 할당 단위가 1k이므로 남은 0.5k는 못쓰게 된다.
		* -> internal fragmentation
		* 이를 쓸수 있게 하려면 allocate unit을 0.5k로 바꿔주면된다.
		* 다만 unit을 작게하면 bitmap 사이즈가 늘어난다. 위의 경우는 2배로 늘어난다.
		* bitmap은 dram에 들어가 있다.
		* bitmap에서 연속된 프로세스는 굳이 구별 x, 그냥 차지하는 공간만 의미
	*  공간 최소표현단위는 byte, allocation unit을 byte로 하면
		* 4512 byte이면
		* 빗맵의 크기는 4512비트
	* linked list
		* p가 첫노드 
		* 0은 시작주소
		* 5는  사용하는 공간 크기
		* H는 unlocation block
		* 왜 p8 p14나눠졌을까? c가 나가면 hole로 바꿔줘야하는데, 지금 상태에서는 hole로 만들어주기는 쉬운데, 만약 합쳐져있으면 만들기 쉽지않다.
		* 리스트의 최소는 아예 비어있거나 한프로세스로 꽉찬 것
		* 최대는 alocation unit마다 다른 프로세스
		* 여기서도 internal fragmentation문제는 존재한다. 이를 없앨 수 있을까?
			* 없앨 수 있다. linked list 값들  모두 바꾸면 된다.
			* 숫자만 조금 바꾸면 되기에
			* 숫자의 field 정도만 바꿔서 overhead가 거의 없다
			* 즉 메모리 더 차지하게 하고싶지 않을때는 linked list이용
	* 만약 접근을 빨리하게 하고싶다면 bit맵, linked list는 노드를 따라가야하므로 느리다.
	* 이를 빠르게 하고 싶으면 table로 만들어서 빈 공간들을 따로 모아두면 된다.
	* externalfragmentation
		* 위의 경우에 4k가 들어올려하면 공간이 없다.
		* 이럴떄는 compactation사용

		* 
* ![[Pasted image 20231017120031.png]]
	* (a)는 A X B로 메모리 꽉찬 상태
	* (b) hole은 합쳐줘야함, 즉 노드 두개가 되어야한다.
	* 이를 통해 doubled linked list가 훨씬 편하다.
	* 
* ![[Pasted image 20231017120328.png]]
	* first fit
		* 만약 앞부터 search하면서 빈공간을 찾으면
		* 앞에서부터 차서 , 뒤에는 사용 덜 함, 비효율적
	* next fit
		* 한번 찾으면 다음은 거기서부터 다시 순환
	* best fit
		* 사이즈 딱 맞는 데에 넣는 것
		* 다 찾아봐야하므로 search하는데 시간이 많이 거린다.
	* worst fit
		* 큰공간을 찾아가자. 왜? 2칸 남은거 1개가 채워버리면, 이 빈공간은 채우기 어렵기에
	* quick fit
		* 다른 구조체 필요
	* 요즘은 next fit사용하면서 하는 게좋다는게 정론
	* 혹은 linked list의 노드를 작은 공간에 사이사이 넣어주는 방법도 있다.
* ![[Pasted image 20231017121332.png]]








* ## 시험은 주로 단답형, ox이며 서술형은 잘 안나온다.
	* chapter1
		* 역사는 중요 용어 몇개만
		* 멀티프로그래밍 타임 쉐어링
		* unix 역사는 버려
		* os의 목적 중요
		* memrory page
		* io device 의미 개념들 중요 + system call 합쳐서
		*  systemcall 어셈블리 나올 수 있다
		* 배치, 리얼타
		* 마이크로 커널 , 모놀릭 커널  차이 장단
* ![[Pasted image 20231017121918.png]]
* exec하면 무슨일?
  ![[Pasted image 20231017121941.png]]
  이게 1장 그림과 합쳐서 나올 수있다.
  * pcb 내용 외울 필요는 없다
  * 컨텍스트 스위치 과정 외울 필요없다,
  * 이 그림 ![[Pasted image 20231017122033.png]]
  * 위랑 연계, 및 1장  그림과
  * 스레드 장점 단점 종류,의 장단점 ,한계,  왜 유저레벨 스레드가 빠른다.
  * 블락 시스템 콜발생하면 왜 다 멈추는지
  * 동기화 개념
  * 각 방법에서 무제가 문제인지
  * tsl 이 왜 앞의 문제를 다 해결했는지
* tsl 코드 눈여겨보기
* spinlock 왜 없애?
* 세마포어가 문제를 어떻게 해결하는지
* 바이너리 카운팅 세마포어가 동시에 사용되는 데어떻게 사용되는지
* 코드들 이해 중
* 모니터 개념, 슬립앤 웨이크와 비슷한데 왜 문제 없는지
* 스케쥴링 그림을 모든 방법으로 할 수있어야한다.
* mlfq
* lottery 잘이해
* realtime수식의 의미


* 메모리 문제가 뭐고 솔루션이 뭔지, 그림 잘이해
* 
* 