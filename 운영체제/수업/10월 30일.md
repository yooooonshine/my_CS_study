* ![[Pasted image 20231030160657.png]]
* 오버레이가 있다
* 아니면 페이징, 일부만 메인메모리에 올라가 돌아갈 수 있도록
* ![[Pasted image 20231030160729.png]]
* Bus로 physical 주소 밑의 1000은 virtual
* ![[Pasted image 20231030160809.png]]
* 페이징은
* 지금은 32비트 버츄얼 주소
* ![[Pasted image 20231030160846.png]]
* 가상주소를 page사이즈로 나누고, 물리 주소를 frame으로 나누고 서로 매칭시킨다.
* 즉 페이지 단위로 로딩
* ![[Pasted image 20231030160923.png]]
* 0부터 64k니 16bit
* 32k는 15bit
* 0번 페이지가 2번 프레임에 로딩
* x표시는 로딩이 안되어있다. 즉 디스크에 존재한다.
* 이런 부분을 access하려면page fault
* k는 1024byte
* 0번 페이지 주소는 0k
* 8196은 2번 페이지 이는 24580에 로딩(1024 \* 24 + 4)
* 정확히 8k주소는 1024 * 8 = 8192
* 32780은 x니까 pagefault이므로 block상태로 들어간다.
* 그럼 frame중에 가장 안쓰는 것을 교체, 버리는 것은 디스크(swaparea)에 돌아가고 가져오는 것은  frame에 넣는다. 그럼 당연히 page의 x도 변한다.
* ![[Pasted image 20231030161924.png]]
* 8196은 16bit로 표현이 된다.
* 12bit는 4k 이고 
* 위 001에서 1은 8192
*  밑은 offset 이는 건들일 필요없다.
* 앞의 4bit로 16에 매칭된다.
* 위에서 1은 이용가능. 즉 절반정도가 loading되어있다. 만약 0이면 fault
* 
* ![[Pasted image 20231030162556.png]]
* 32bit는 page가 4k라면 앞이 20bit가 있다.  즉 page가 2^20개 있다. 
* 0x는 13325가 20bit이고 이게 page  Number
* page table에서 나온 값을 앞에 붙여준다.
* 이게 physical address
* 
* ![[Pasted image 20231030162816.png]]
* 가상페이지 숫자랑 오프셋으로 구분
* PFN + OFFSET으로 물리주소
* 페이지당 pte
* ![[Pasted image 20231030162956.png]]
* 이를 mmu가 자동실행해 준다.
* 페이지 테이블은 어디 저장? 메모리에 저장한다.
* page table은 프로세스당 만들어 진다.
* 인덱스와 어레이 시작 주소 필요 어레이 시작주소는 page table pointer register에 들어 있다. 이 주소는 physical이다.
* 여기에 페이지테이블 시작 주소를 넣어주고, 그럼 합치고 변환이 필요없다. 페이지 테이블은 physical에 있고 이에 접근하기 위해서 시작주소를 저장한 것
* 
* ![[Pasted image 20231030163016.png]]
* refer와 modi는 store가 되면 dirtybit세팅, 
* protecting이 수행할 수 있느냐
* caching disabled는 해당 메모리데이터는 보통 캐쉬되는데 캐쉬를 쓰지말라는 것.
* ![[Pasted image 20231030163543.png]]
* 컨택스트 스위치가 되면 프로세스당 page table이 있으니까 메모리에 page table이 바뀐다.
* memory map change는 context switch
* 페이지 테이블 가져오려고 메모리 접근하여, 가져오고, 이로 physical 만들어 다시 메모리 접근
* 2^20의 레지스터를 만드는 것은 쉽지 않다.  그래서 single page table안쓰고 page table in main memory를 사용.
* ![[Pasted image 20231030163858.png]]
* 페이징의 장점은?
* 가장 큰 것은 swaping과 비교해했을 떄 프로그램이 physical보다 커도 일부 로딩만 해도 되니까 유리
* 64bit면 이만큼의 메모리가 있어야 한다는 것인데, 이는 쉽지 않아서 paging 사용
* 메모리 재할당은 프레임단위로만 하므로, 사이즈가 맞는 공간만 있다면 찢어서 저장
* ![[Pasted image 20231030164236.png]]
* 약점 
* 메모리에 페이지 테이블 access하므로 두번의 접근이 필요하게 된다.
	* tlb라는 하드웨어(캐싱)를 갖고 해결
* 페이지 테이블이 32bit 주소를 사용하는데 그럼 pte가 2^20개 필요, 각 entry는 4byte이므로 pte는 4mb 이는 프로세스당, 프로세스가 100개면 400mb 엄청난 양의 메모리를 필요로 한다.
* 만약 64bit이면 2^52이면 더 많이 필요 ->문제
* ![[Pasted image 20231030164623.png]]
* 메모리 추가로 access해야하는경우, 캐쉬 미스일경우 100cycle이상걸리고 파이프라인은 멈춰있다.
* tlb는 하드웨어인데 굉장히 빠른 캐쉬. 캐쉬는 크게 세종류
* 이는 fully associative 캐쉬
* 서치하는데 많은 시간이 걸려, 크게 안됨
* 값으로 pte가 나온다.
* 엔트리가 16에서 64개 존재
* 근데 엔트리가 8개면 pt의 2^30라면 세개(프로그램,데이터, 스택)로 프로그램 돌릴 수 있고 즉 3개면 충분, 이 세개 가지고 도는 시간이 상당히 길다. 즉 실질적으로 굉장히 작은 부분만 access하므로,
* tempolary access
* spatial access
* ![[Pasted image 20231031111107.png]]
* tlb 캐쉬 구조, 페이지 넘버 있고 해당페이지 ㅇ엔트리 ㄴ내용이 존재
* 130이 들어오면 virtual page 한번에 찾아, 즉 찾을때까지 비교
* 50을 찾는 데  없어->tlb miss
* ![[Pasted image 20231031111353.png]]
* virtualpage숫자 다 비교하여 매칭되면 앤트리 나오고 (프로텍션같은 것도 체크) 프레임 넘버 나와 피지컬 주소에 붙임
* 미스 나오면 페이지 테이블 access (즉 메모리 접근) 엔트리 나오면 이를 frameNumber에 붙인다.
* tlb miss 나면 엔트리를 찾는 데 이 엔트리는 다시 access 될 확률 높으므로 tlb에 가져오는데, 꽉 차있으므로 하나를 밀어내야하는 데 , 이 기준이 lib(가장 access 안된거 버림) 그리고 저장한다음 여기서 frame Number를 가져오는 것
* tlb는 결국 캐쉬, tlb와 pagetable 정보 일치 시켜야하는데 modify bit바뀔 수 있고, 그럼 다시 pt에 써줘야 함
* protectionbit를 바꾸면 pt를 업데이트 하고, tlb에 존재하면 os가 추적해서 invalidate해준다.
* page table을 봤는데 falut면 block 상태로 가고 엄청 오래걸린다. disk에서  frame으로 로딩시키고 pagetable 업데이트 시켜준다.
* 이러면  context switch 그럼 pagetable도 스위치, 그럼 tlb정보도 날려야 한다. 즉 context switch면 memory overhead가 생긴다.
* 디스크에서 가져오면 ready 상태, fault 발생한 상태에서 시작하는 게 아니라. 아예 restart한다
* restart하는 이유는 cpu상태를 저장을 해둬야 하는데, 그럼 파이브라인 단계에서 변화하는 모든 값들, 쉐도우레지스터를 모두 저장해야하는데 (실제 레지스터 반영은 complete단계에서 한다), 이는 불편하다. 저장해야할게 많으니, 아예 날려버린다.
* 이건 인터럽트도 마찬가지
* ![[Pasted image 20231031112327.png]]
* 하드웨어가 마이크로 코드로 작동
* 소프트웨어로 하면 fault 나면os코드가 진행, 하드웨어보다 느리고, 여러 싸이클이 필요
	* 이에 접근에 대한 instruction이 필요하다
	* 단 mmu가 간단해진다.
* ![[Pasted image 20231031112730.png]]
* tlb와 pt가 일치해야한다. 하지만 반드시 동일하지는 않느데
* tlb 쫒겨날때 update하거나 pt 바뀌면 tlb invalid
* 쫒겨내는 엔티리는 LRU를 사용하여 쫒아낼 것을 결정한다.
* 시간을 저장해서 가장 오래된 것을 replace
* 근데 이거 구현 어려워서 pseudo LRU 사용.
* ![[Pasted image 20231031113109.png]]
* vpn 20bit, offset 12bit
* 이는 2^20승의 page table안에 pagetable entry 존재
* vpn을 나눈다. 10bit는 first level, 뒤 10bit는 second
* pt를 안에서 2^10개씩 묶어 그럼 2^10개의 덩어리가 나온다.
* 앞 first가 덩어리중에 몇번쨰인지를 알려준다.
* 이 덩어리 안에서 second를 통해 고른다.
* 위 그림은 이를 블록 별로 나눈 것
* 이것을 하는 목적은?
* 이렇게 하면 2^20개 와 2^10개 해서 기존의 pt보다 2^10만큼 더 커졌다.
* virtual space의 코드가 4k , data가 4k일때(stack제외) 이게 어떤 frame에 연결된다면, 이것만 쓰려면 0 1, 0 0의 first second라면 2^10짜리 두개만 필요
* 근데 stack이 생기면 ffff.ffff로 갔는데 프레임이 없으니 fault이고, 이를 생성한다. 
* 즉 다 할당하는 게 아니라 필요한 만큼만 사용
* pt는 프로세스당 할당하니 이 pt  하나에 data, code, stack이 연관된다. pt 맨위에 stack 존재, 맨 밑 data
* 즉 이렇게 하면 실질적으로 맨 끝에 해당하는 second의 2^10하나와 data,code에 해당하는 second 맨 아래 2^10 제외한 sencond에 해당하는 pt는 아예 사용안하고 할당도 안하니 다른 용도로 사요 가능
* 
* ![[Pasted image 20231031113146.png]]
* 만약 master에서 secondary로 연결된 게 없으면 page fault이다.
* 이 모든 건 메모리에 저장하므로, 속도를 위해 tlb가 매우 중요해진다.
* 여기서 테이블이 가리키는 화살표는 다음 테이블 모서리를 가리킨다.
* ![[Pasted image 20231031114905.png]]
* first, second는 꼭 10bit일 필요가 없다. 마스터 page table이 딱 4k가 되어서 그냥 이렇게 한 것
* 만약 64bit라면 보통 page size는 4k로 잡는다. 
* 오프셋은 12bit
* 그럼 10bit(first) + 10bit(second) + 10bit(third) +10bit(forth) +12bit(좀 더 큰 pt) + 12bit(offset)
  
  
* 
* 우린 페이지 테이블에 다음 페이지테이블이나 frame 넘버를 저장
* vpn-> frame넘버
* frame 넘버 최대수는 8개, 즉 frame수에 
* 즉 프레임 수만큼 8개의 엔트리가 존재한 다 했을 때, 
* ![[Pasted image 20231031121351.png]]
* 0번은 vpn 3번이 사용, 1번은 vpn1번등이 오른쪽 pt에 적혀있다.
* 8196이면 vpn2 + offset이며 vpn2번은 어떻게 찾아?
* 오른쪽 페이지 loop돌면서 
* 전체 시스템의 매핑 정보는 이것만 존재
* 즉 프로세스가 얼마나 많던간에 8개만 필요

* 4G가이면 2^20의 엔트리(frame 개수) 이를 루프돌면서 찾아.
* 그럼 평균 2^19번을 확인해야한다.
* 만약 루프를 돌았는 데 없다면 page fault
* ![[Pasted image 20231031115411.png]]
* 페이지 번호p이면 전체 서치. 서치할때 들어가는 입력은 pid와 virtual page number이다. 이를 찾아서 매칭이 되면 frame number
* ![[Pasted image 20231031122305.png]]
* 이제 남은 문제
* 페이지 컨텐츠 접근 시간이 걸린다
* 이를 해결하기 위해, 컨텐츠 서치를 index 서치로 바꿔버리면된다. 해쉬 테이블 이용.
* 즉 자기 컨텐츠를 해쉬해서 나온 값이 주소
* ![[Pasted image 20231031122658.png]]
* 2^16의 어레이를 만들고, 이 어레이를 access하는데( 매핑정보가 2^16), vpn의 사이즈는2^52. 이를 해쉬하여 0부터 2^16 -1로 바꿔준다. (이는 인덱스가 된다.)
* 오른쪽 연결된 노드들은 pid, vpn,frame정보가 들어가 있다.
* 예로 pt가 4bit이고 frame을 가진 pt가 8개(3bit)라면 맨 앞비트 제외한 주소( 나름의 해쉬) 그럼 frame 엔트리당 이를 가리키는 두개의 노드가 존재
* 충돌 줄일려면 mapping정보 수만큼 엔트리 만든다.
* ![[Pasted image 20231031123642.png]]
* fault가 났는데 frame 다 사용중이면 어떤 것을 replace할 것인가.
* fault가 났을 때 frame으로 가져오는 것을 demand paging
* 스와핑은 전체가 다 들어오지만 이건 page만
* 디스크 버전과 page frame있는 버전이 같으면 page frame flash하면된다. 아니면 디스크에 써줘야 한다.
* 즉 disk에 있는 게 본체, 메모리에 있는게 cashing
* ![[Pasted image 20231031124256.png]]
* 트래싱은 프레임이 적으면 fault가 계속 발생.  그럼 프로그램이 진행이 못하는 상황 .
* 프로세스가 너무 많으니 ready상태의 프로세스를 빼버리는 방법도 있다.
* ![[Pasted image 20231031124621.png]]
* 정상적인 상황에서 페이지 replace할거야. 어떤 게 쫒아내기 좋은 페이지 일까?
	* 잘 안쓰는 것
	*  미래에 터치 안하는 페이지 ,근데 그럼 뭐가 잘 안 쓰일지 미래를 알아야 한다.
	* belady가 미래에 안쓰는 거 쫒아내는 게 가장 낫다고 증명
* 예시는 frame이 세 개인 것.
	* B처음 access ->fault이다
	* C처음 access -> fualt
	* B 페이지 hit
	* A fault, 이제 frame 꽉찼다
	* E 넣기 위해 뭘 버려야할까?A가 앞으로 안쓰이니 A바