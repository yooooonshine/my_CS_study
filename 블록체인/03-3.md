* ![[Pasted image 20231013112157.png]]
* 조건을 걸어서 pay, 즉 한달 뒤에 사용할 수 있도록 등
* 즉 그 기간동안 무슨 일이 있으면, 번복하고나 그런 것
* transaction이나 output에 lock을 걸어, 이후에만 spend할 수 있도록
* 두가지
	* transaction level timelocks
	* utxo level timelock: 각 개별 레벨에도 락을 걸 수 있도록
* transaction이란 input output을 연결 하는 것.
* 
* ![[Pasted image 20231013112056.png]]
* nlocktime이란 transaction의 필드이고 값을 지정함으로서 미래 시점을 지정할 수 있다.
* 즉 트랜스엑션이 유효하여 블록체인에 포함될 수 있는 가장 빠른 시점을 의미
* 대부분이 lock이 없다
* 만약 걸렸다면 0이 아닌값
	* 1. block height , 5억보다 작다고 설정하면( block height, 최초로 연결된 block이 genesis block, 이 후 height가 1씩증가, ) 5억이 될 때까지 락이 걸린다.
	* 2. >= 5억 이면, unic epoch timestamp로 이해해서, 시간으로 계산
* ![[Pasted image 20231013112935.png]]
* ![[Pasted image 20231013113033.png]]
* 이건 일종의 op코드
* output마다 설정될 수 있는 lock, (엘리스가 bob에게 돈보낼때, bob에거 설정하는 것)
* 특정 시간이 지났다면 그대로 진행
* 아니면 invalid
* cltv만족 확인
* cltv는 파라미터가 필요,  lock시킬 시간을 알려주는 것.
	* 다만 포맷이 nlocktime이랑 똑같아야함, nlocktime이 시간이면 이것도 시간
* ![[Pasted image 20231013113350.png]]
	* bob에게 지불할 때 조건을 걸고 싶을때,
	* <>는 value
	* 지금으로부터 3달 후를 표현? -> 지금의 unix 찾아서 3달 계산 후 추가
	* 혹은 block은 평균 10분마다이므로, 3달후를 계산해서 nlockblock
	* drop은 스택에 \<now 3month> 있으므로 지우기 위해서.
* ![[Pasted image 20231013113909.png]]
	* cltv는 결과에 lock, 전체에 lock하는 것이 더 엄격해야하므로 , 이게 기간이 더 길어야한다.
* ![[Pasted image 20231013114146.png]]
	* stack empty -> 검증할 시간이 없다.
	* 2. lock time은 미래여야하므로 음수 x
	* nSequnece라는 필드가 존재 -> 내 거래가 안될때, fee를 더 높이기 위해 사용하는 필드, 즉 nSequnece가 커지면 더 최신 것임을 의미
	* 
* ![[Pasted image 20231016170136.png]]
* 어떤 transcaction이 시장에 뿌려졌을 때 이게 반드시 10분내에 포함된다는 보장이 없다.
* 즉 상대적인 시간으로 특정 transaction이 블럭에 포함된 몇분  등의 방법으
* ![[Pasted image 20231016170454.png]]
* nsequence는 4byte, 가장 큰 수보다 작은 값이면 아직 finalized되지않았다.
* finalized는 transactionfee를 올려서 다시 보내는게 nsequence 수를 늘리는 거고, 이게 최대가 fianlized라고 한다.
* finalize는 된 적 없고 이 값을 바꿔 timelock을 해보자는 아이디어
* ![[Pasted image 20231016170801.png]]
* nsequence가 2의 31승보다 작으면 relative로 (위랑 차이 있다 위는 2^32 -1 인데)
* 2의 31승은 맨 위의 bit가 0이되면된다.
* 22비트가 
	* 1이면 512의 배수인 secound로 설정, 파랑 * 512가 시
	* 0이면 block height로 설정, 파란 색 비트가의 수가 block수
* ![[Pasted image 20231016171242.png]]
	* 비트코인 스크립트언어에서 새롭게 제공하는 것
	* relative timelock을 검증하는  용도
	* csv는 nsequence가 유효한지
* ![[Pasted image 20231016171515.png]]
	* segwit은 최근에 나온 기술
	* 분리된 signature, 즉 시그니처가 분리된 상태이다. 서명을 transaction밖으로 빼겠다
	* 분리되기전에는 
		* 모든 transaction을 사용하려면 privatekey로  signature를 해야한다.
	* 분리 후에는?
		* 왜 분리?
		* ![[Pasted image 20231016171833.png]]
		* 노란색은 block, 보라색은 block이  차있다. 즉 비트코인이 인기가 많아졌다.
		* 그럼 transaction수가 늘어난다.
		* 이 때 사토시는 블럭 크기를 1MB로 제한을 해놨다. 이 룰을 뒤집는 게 쉽지 않았고, 
		* 룰을 지키자 -> BTC
		* 룰을 버리고 블럭사이즈를 늘리자 -> BCH -
		* 둘로 비트코인이 나눠졌다.
		* 우리는 BTC에 관심이 있다.
			* 근데 transaction은 많이 넣고 싶어
			* -> segwit의 탄생
	* ![[Pasted image 20231016172432.png]]
	* signature를 빼자. ecds에서 서명은 512bit로 길다. 즉 64byte
	* 뺸 서명은 witness data에 넣고 흔적만 남기자.
	* 이제 block의 크기는 base block
	* 이로 인해 block의 크기가 4MB로 확장
	* ![[Pasted image 20231016172630.png]]
	* 0은 wit 버전, 이 뒤는 hash값
	* ![[Pasted image 20231016172908.png]]
	* 보내는 쪽 받는 쪽이 모두 segwit이 구현되어 있어야 사용가능
	* scriptsig에 아무것도 없고
	* witness로 분리되어있다.
	* ![[Pasted image 20231016173056.png]]
	* p2sh는 이를 제시한 사람이 redeem가능
	* 밑은 두명이 서명하면 사용할 수 있다.
	* 
	* ![[Pasted image 20231016173231.png]]
	* 차이는 witnessprogram차이 이 길이는 32byte 이를 통해 p2wkh와 p2wsh 구분가능
	* ![[Pasted image 20231016173437.png]]
	* 20Byte = 160bit RIPEEMD160에서 사용
	* 32Byte = 256bit -> SHA256에서 사용
	* ![[Pasted image 20231016173709.png]]
	* segwit 업그레이드
		* segwit을 사용하려면 wallet, miner모두에게 적용해야함
		* Backword compatible: segwit을 사용안하려하는 bsh 인원들도 고려
			* 이들에게는 witness를 안보냄. 즉 signature를 빼고 보낸다?
			* 이를 받은쪽에서는? segwit 구현 안한쪽은 format은 문제 없지만 그럼 이들은 이것을 anyonecanspend로 해석, 하지만 실제로 anyonecanspend는 아님. 일단 valid해 보인다.
			* segwit 노드들한테는 다 보낸다.
			* 즉 A -> B, C에서 거래되는데 B가 segwit안되어있다해도 C에게는 segwit적용된게 퍼짐
	* ![[Pasted image 20231016174509.png]]
	* ![[Pasted image 20231017170101.png]]
	* signature를 만드는 건 ecdsa인데, 이는 서명이 주어졌을때, 이 서명을 가지고 조작을 가하면 같은 메세지의 타당한 서명이 된다.
	* N은 public key이고 r, s는 주어졌으므로 가능
	* (r,s) 가 시그니처, (r, -s ,(mod N))이 시그니처 별표면 이것또한 키 확인 통과
	* 이건 문제가 없다 서명 내용에 a가 b에 보내는 것은 못바꾸기에
	* 블럭에는 이전 transaction의 utxo의 ??
	* 시그니처별표로 바꾸면 tid가 바뀐다. 그럼 tid가 여러개? -> 혼란,
	* 즉 이걸 훔치는 것은 불가능하지만 , 혼란은 야기한다.
	* 이를 dos 공격
	* 즉 공격자가 이익을 취할 수는 없지만 서비스를 해칠 수 있다.
	* segwit은 시그니처를 제외한 것.
	* 이를 제외하고 tid를 만들면 된다
	* 만약 다른 부분을 바꾼다면, 시그니처는 바꾸기 전 데이터에 대한 서명이므로,  발각이 된다.
	* 시그니처별표를 wtxid라 한다.

* ![[Pasted image 20231017171013.png]]
* miner는 여러 비용이 든다.
* cpu는 nonse를 바꿔가면서 계산하는 데 필요
* network는 정보받고 뿌리기 위해
* disk는 utxo의 블럭을 가지고 있어야 하므로, 
* 메모리는 access time이 적게 걸리니 utxo를 참조하여 valid한지 확인해야하므로
* transaction fee도 중요한데, 채굴비트코인은 낮아지므로,
* ![[Pasted image 20231017171544.png]]
* ![[Pasted image 20231017171712.png]]
	* 