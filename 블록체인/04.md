* ![[Pasted image 20231017172209.png]]
	* P2P는 master client개념없이 동등한 peer끼리 소통하는 것
	* 인터넷 위의 새로운 네트워크
	* 이때 TCP 연결
	* 들어갈 때 나갈때 승인을 받을  필요없다.
	* 
* ![[Pasted image 20231017172126.png]]
	* wallet을 설치하고 연결된 이웃 노드에 transacitoin을 보냄
	* 이는 또 다른 이웃노드한테 뿌리면서 퍼져나감
	* 검증은 현재 대세의 블록체인에 입각하여 
	* 3은 나한테 도착한 transaction이 나한테 또 들어오면 무시
* ![[Pasted image 20231017173005.png]]
* race 컨디션이 얼마든지 일어날 수 있다.
* ![[Pasted image 20231017173234.png]]
* ![[Pasted image 20231017173421.png]]
* race 컨디션이 block 단위로도 발생가능
* 한 지점에서 두 블럭으로 분기(fork)가 생긴다면(두 마이너가 동시 채굴)
* 마이너들은 둘중 더 빨리 채굴되는 쪽을 선택
* ![[Pasted image 20231017173717.png]]
* ![[Pasted image 20231017173850.png]]
* 오른쪽이 더 오래된 블럭(화살표 방향을 통해, 포인터느 ㄴ이전꺼 가리키므로)
* 헤더는 메타데이터, 블럭에 대한 설명, 해ㅟ포인터
* timestamp는 만들어진 시간
* block height는 +1 하면 현재
* 과거 2016개의 block을 봐서 난도 조절
* nonse는 마이너가 넣는 값
* merkle root 는 (block은 transaction을 포함하는 것) block을 효율적으로 관리하기 위해 merkle tool을 이용
* 두 해시값을 연결해서 해쉬해 노드를 만드는 트리
* 
![[Pasted image 20231027110307.png]]
* time stamp는 만들어진 시점
* difficulty target: 난도
* nonce: x값 해시퍼즐푸는 
* ![[Pasted image 20231027110455.png]]
* block header hash: 블럭해쉬이다. sha256두번 돌려서 나온 결과
* 32byte의 결과가 블럭 헤더 해쉬
* 왜 두번 돌릴까?
	* 이유는 정확히 없다
* 블럭 식별 방법 
	* 블럭의 하이트를 언급
	* 두 개이상의 같은 블럭하이트를 가진 블럭이 있을 수 있고 결국 이는 수렴할 것
* ![[Pasted image 20231027110711.png]]
* 머크루트의 해시값
* 디피컬티는 어떻게 이런 숫자가 어려움을 표현할까?
	* 난도가 이런 숫자가 나오도록 하는 알고리즘이 있으나 중요하지 않다
* ![[Pasted image 20231027110837.png]]
* 리프노드가 4개인 머클 트리
* HA는 Hash(T A)를 sha256한번 더 돌린 것
* Hash(tx A)는 A를 해쉬한 것
* 두 해쉬값을 더해 해쉬
	* 여기서 더하기는 두 스트링을 이어 붙인 것
	* 256bit + 256bit 로 해쉬를 적용
* 이 최종값이 위의 머클 루트에 들어간다.
* 이를 사용하는 이유는 효율성을 위해, 단순 해쉬들을 테이블로 나열하는 것보다  낫다.
* ![[Pasted image 20231027111156.png]]
* 어떤 트랜잭션이 포함되는 지 확인하려면?
* 만약 채결한 트랜잭션이 Hd라면 이 위로만 따라가면 된다/
* 즉 depth(logn)만큼만 확인하면 이게 포함되는 지 알 수 있다.
* ![[Pasted image 20231027111336.png]]
* Hk를 계산하고 루트까지가는 모든 노드(점선 네모)를 확인
* 이 때 체크를할 때 도움을 받을 수 있는 노드가 파란색
* ![[Pasted image 20231027111642.png]]
* 돈을 벌려고 채굴을 하는 게 비트코인을 견고하게한다.
	* 채굴과정에서 검증과정을 거친다.
* 비트코인의 목적은 탈 중앙화 이 역할을 여러 마이너가 행동한다.
* 채굴보상이 원화가 아니라  코인인 것도 중요
* 원화는 가치가 떨어질 수 있다. 이럴 때는 채굴을 잘 안하려할 수 있다.
* 그럼 btc의 가치가 떨어지면? 비트코인의 신뢰성을 더욱 높일려 할 거고, 안정성이 높아져 교환가치가 다시 높아질 수 있다.
* 비트코인의 총발행량을 정함으로써 화폐가치를 지킨다.
* ![[Pasted image 20231027112224.png]]
* 트랜잭션이 블럭에 포함되었다 = confirm되었다. one confirmation 이후로는 웬만하면 신뢰성을 갖는다.
* 채굴 보상은 coinbase reward, transaction fee
* 작업증명:채굴을 하는 방법은 알려져 있지만, 빨리 푸는 방법은 존재 하지 않는다. 작업증명이라는 것은 short cut이 없다는 것에 기반을 한다. 즉 채굴을 하는 데 굉장한 양의 계산을 했을 것이고 증명으로 nonce제공
* ![[Pasted image 20231027112516.png]]
* transaction fee =input -output
* 현재 기준으로 채굴자가 가져가는 보상의 0.5퍼센트 이내
* 채굴자는 block reword를 보고 하지만, 이는 4년에 반감기를 가지고, 그럼 채굴을 하는 데 드는 비용은 동일하므로 transaction fee를 높이게 된다.
* ![[Pasted image 20231027112714.png]]
* block reward는 21만 비트코인으로 제한
* 지금은 6.25
* ![[Pasted image 20231027112913.png]]
* 마이너가 트랜잭션을 받아서 이를 가지고 블럭을 만들려 함.
* 검증이 끝난 transaction을 머클트리로 구성 후 
* ![[Pasted image 20231027113220.png]]
* 해쉬 퍼즐을 푸는데는 오래걸리지만
* 이를 검증하는 과정은 매우 간단하다.
* 해쉬는 256비트의 0 1 sequence 즉. 각 자리의 확률이 절반이라면 앞의 128비트가 모두 0일 확률이 낮다.
* 이를 통해 난도 조절을 한다.
* ![[Pasted image 20231027113559.png]]
* 마이닝 과정
* nonce는 32비트
* ![[Pasted image 20231027113729.png]]
* 모든 마이너가 같은 퍼즐을 풀고 있을까?
	* 완전 같은 퍼즐을 풀 때 더 빠른 머신을 사용하는 쪽이 이긴다.
	* 답은 모든 마이너가 각기 다른 퍼즐을 푼다!
	* nonce를 제외하고도 해쉬 대상(transaction)을 갖기에 서로 다르다.
	* a,b가 똑같은 트랜잭션들을 가지고 한다하더라고 머클트리의 위치, 즉 순서가 바뀌면 해쉬값이 바뀐다.
	* 즉 x 에 y를 붙여 해쉬하는 것과 y에 x를 붙여 해쉬하는 값은 서로 다르다.
	* 완전히 같은 순서, 같은 트랜잭션을 해도 같지 않다. 결정적으로 자신의 주소로 채굴 보상을 보내니까 다르다.
	* ![[Pasted image 20231027114228.png]]
* ![[Pasted image 20231027114253.png]]
* 2016블럭은 2주
* ![[Pasted image 20231027114449.png]]
* 초록색: 해쉬 파워
	* 해쉬 파워가 커지면, 채굴이 일찍끝난다
	* 그럼 난도를 높인다.
	* 초록색과 빨간선이 만나도록 한다.
* ![[Pasted image 20231027114557.png]]
* 파란색은 채굴 걸리는 시간
	* 난도가 상승하면서 증가한다.
* ![[Pasted image 20231027114648.png]]
* cpu로 가능했던게 cpu(parrell이용)-> Fpga(gpu보다 특화된 장치)-> asic(채굴 공장,sha 256 채굴에 특화됨)
* ![[Pasted image 20231027114810.png]]
* 채굴 공장
* ![[Pasted image 20231030170217.png]]
* consensus과정에서 각 노드마다 의견이 다른 사황이 생길 수있으나 궁극적으로 합의에 이르게 된다. 또한 특정 시간이내에 합의가 이루어진다 아니다. 이는 비동기적이기에. p2p네트워크 상황에서 발생하는 일이기에
* 각 노드는 다른 노드의 지시 간섭을 받지 않고 다음과 같은 네가지 진행
	* 첫번째로 각 트랜잭션을 검증한다.
	* 두번째로 이러한 트랜잭션을 새 블락에 넣어 채굴하려고 한다.
	* 채굴에 성공했다고 제시하는 작업증명, 
	* 채굴에 성공한 노드가 valid한지 검증하고 블록체인에 연결시키고, 이에 붙을 블락을 채굴하기 시작
	* 어떤 블럭 위에 내가 연결시킬지는 각자 판단.
* ![[Pasted image 20231030170624.png]]
* 트랜잭션 검증
* 트랜잭션이 유효하다고 판단된 것만 네트워크에 뿌림
* 아니면 즉각 폐기하여 퍼지지 않도록함
* 트랜잭션의 신텍스, 자료구조가 맞는 지 확인
* 스크립트가 포함되는 데, 이 스크립트는 튜링 완전 허용 x, 허용범위는 표준에 나와있고, 이에 맞지 않는 스크립트는 거부
* 어떤 트랙잭션을 포함한 성공 블럭이 나한테 오면 인정하고 내 pool에서 트랜잭션을 제거
* 채굴된 블럭에 포함되지 않는 트랜잭션인지 확인
* utxo인지 확인
* 트랜잭션의 크기가 블럭사이즈 이내인지 확인
	* 지금은 witness 제외하고 1mb이다.
* ![[Pasted image 20231030170931.png]]
* ![[Pasted image 20231030170958.png]]
* 블럭이 있으면 헤더가 있고, 그 아래 트랜잭션이 존재
* 트랜잭션은 머클트리에 있고, 가장 왼쪽아래에 coinbasetransaction을 넣어야한다.
* 이는 목적이 딱 하나, 채굴을 성공하면 채굴보상을 받기 위한 트랜잭션이 들어간다,.
* 기존에 존재하던 코인을 사용하는 게 아니므로 인풋이 필요하지 않
* 따라서 vin에는 dummy 데이터,  즉 coinbase 안에 임의의 데이터를 넣어도 된다. 사토시는 처음에 여기에 text를 집어 넣었다.
* 중요한 것은 output, 내 주소로 보낸다. 얼마를? 25.090를
* 근데 0909는 뭐야? transaction fee의 합
* address는 마이너의 주소
* ![[Pasted image 20231030171338.png]]
* 퍼즐을 풀때 nonce값을 변경하면서 타갯넘버보다 작은 지 반복하는데
* 이런 상황, 초창기에는 채굴난도가 낮았다 왜? 비트코인 사용하는 채굴자가 별로 없었으니까.
* nonce는 32비트이고 이값을 바꿔가면서 답을 찾았다.
* 요즘은 비트코인 가격이 올랐고, 채굴에 뛰어드는 사람이 많고, 즉 난도를 올려야 한다.
* nonce값을 바꿔가면서 했는데 이에 맞는 답이 하나도 없었다.
* 이의 결과 가지수는 2^32 즉 40억정도의 가짓수가 있다.
* 이 모든 가짓수를 다해봤는데 답이 안나온다?
* 그럼 내 블럭의 트랜잭션 순서를 바꾸면 된다. 그럼 머클트리 해쉬값 바뀌니까. sha256하면 새로운 output이 발생
* 문제 트랜잭션의 두 위치를 물리적으로 바뀌는 것은 시간이 오래걸리는 일, 이는 가급적 자제하고 싶어
* 그래서 등장한게 랜덤한 값
* 이게 coinbase의 값 8byte를 추가로 nonce로 쓰자
* 즉 이로 nonce값 space가 커졌다.
* 그럼 트랜잭션 위치 안바꾸고 머클트리 값을 바꿀 수 있따.
* ASIC으로 된지는  꽤 오래되었다(10년정도 됐다)
* 비트코인 채굴 전용이 5나노의 반도체
* 이의 등장으로 초당 테라(1조) 해시 계산 이상을 해야 채굴 가능성이 존재한다.
* 이로 인해 굉장히 빨리 2^32를 하므로, 이로는 부족
* 이로 인해 추가로 등장한게 coinbase transaction의 extra field이다
* 토탈 12byte, 이는 96비트 즉 2^96의 가짓수
* ![[Pasted image 20231030172319.png]]
* 컨센슈스가 이루어지는 과정
* 이는 p2p네트워크 별표동그라미가 각각 노드
* 별표는 이들끼리 서로 합의가 이루어졌다는 뜻
* ![[Pasted image 20231030172404.png]]
* 둘 이상의 채굴자가 동시 채굴 성공
* 별표 위에 붙이는 것은 반대 의견이 없다만
* 한쪽은 이 위에 세모 한쪽은 역세모로 채굴을 성공해서 뿌렸다.
* 별들은 아직 채굴했는지 모르는 상황
* ![[Pasted image 20231030172521.png]]
* 결국 그룹이 두개로 줄어들었다.
* 이 두 진영으로 나누어져서 세력다툼
* 역세모입장에서 세모는 orphan
* ![[Pasted image 20231030172752.png]]
* 마름모 채굴 성공, 이는 하얀 삼각에 속해있으므로, 마름모가 뿌리면 흰 세모가 이긴다.
* 만약 역세모가 엄청난 해쉬파워를 갖고있어서 밀어 붙일 수 도 있다. 하지만 굳이?
* 결국 합의에 이르게 된다.
* ![[Pasted image 20231030173019.png]]
* 컨센슈스는 공격이 가능하다.
* 마이너들이 담합해서 공격을 하면 가능
* 마이너가 마이닝파워의 상당부분을 가진다면 가능
* 컨센슈스 공격은 미래에 대해서는 가능하나 오래전 과거에 대해 invalid하게 만들 수는 없다.
* 엄청난 해시 파워도 작년의 블락은 뒤집을 수 없다 몇천 몇만이므로, 하지만 현재 블락을 뒤집을 수 있다.
* 다른 주소의 비트코인을 훔치고 싶다.  주소는 public이라 당연히 알 수 있다. 어떤 주소의 50bit가 사용되지 않았다를 알 수 있다. 이를 훔칠 수 있다면 할만 하다. 근데 못한다 이를 훔칠려면 서명을 위조해야하고, 그럼 암호화를 깨야한다.
* 그래서 공격자는 dos공격이나, 최근블럭만 뒤집을 수 있다.
* ![[Pasted image 20231030173531.png]]
* 뭐 49퍼라도 공격 실패하는 것은 아니다.
* 큰 마이너가 공모를 해서 뒤흔들려한다면 이러한 공격들이 가능하다.
* 첫번째로 fork가능하다. 즉 새 브랜치를 만들어 대세로 만들 수 있다.
* 그럼 원래 체인을 unvalid하게 만들 수 있다.
* 더블스펜드는 어태커 자신의 것만 가능하다. 왜? 서명해야하므로
* 엘살바도르는 비트코인을 법정화폐로 지정
* 그럼 비트코인이 굉장히 많이 필요, 그래야 비트코인의 가격 변화에 민감해지지 않는다.
* 엘살바도르에 비트코인을 팔고싶어서 전달하고 달러를 받은 상태에서 더블 스펜드 시도 가능
* 컨텀되기전에 더블스펜드, 컨펌된 후에 포크를 시도할 수도 있다.
* dos공격은 어떤 특정한 주소로 전달되는 트랜잭션, 나오는 트랜잭션을 채굴블럭에 포함되지 않도록 할 수 있다
* 예로 엘리스가 굉장히싫어 엘리스가 발생시킨 트랜잭션을 포함시켜주지 않아. 혹은 목적지가 엘리스이면 이를 거부
* 그럼 엘리스의 트랜잭션이 굉장히 오랜기간 포함되지 않을 수있다.
* 즉 dos 서비스 거부 공격을 할 수 있다
* 그렇다고 이렇게 해서 돈을 벌 수 있는 것은 아니다.
* ![[Pasted image 20231030174128.png]]
* 취약점
* 어떤 사람이 굉장히 돈이 많으면 문제
* 미친 사람이면서 돈이 많으면, 경제적 이득 신경안 쓰고 행동하면 비트코인을 흔들 수 있다.
* 일론 머스크가 몇 조를 쏟아부어 채굴장비에 투자하면 문제가 될 수 있다.
* 다수의 해쉬파워가 뭉치면 어택이 가능할 수 있다.
* 해쉬 파워가 적으면 어택성공 줄어든다. 자기 이익의 충실한 마이너가 많다면 성공확률 줄어든다.
* 어떤 연구결과에 따르면 실제로 공격이 가능한 해시파워는 대략 30퍼정도만 있으면 공격할 수 있다라고 한다.
* 단 비트코인의 해킹사례는 많이 발생했다. 다만 이는 대부분 거래소에서 발생하였다.
* ![[Pasted image 20231031170217.png]]
* 비트코인의 신뢰성이 떨어지면 돈을 잃을 사람이 많기에 최선을 다함
* ![[Pasted image 20231031170310.png]]
* consensus규칙은 바뀔 수 있다. segwit도 변경 중 하나이다.
* 예를 들어 if나 condition이 없었는데 추가 했다
* improvement는 p2sh
* ![[Pasted image 20231031170519.png]]
* consensus 바꾸는 법
	* hard fork 이는 서로 상대방을 인정하지 않는 상황
	* 이후 두 체인이 다시 converge하지 않는다. 즉 별도의 체인이 생긴다.
	* segwit 반대한 사람들이 bth로 떨어져 나간 거 처럼.
	* 이를 통해 완벽하게 서로 다른 규칙에 따라 네트워크가 운영된다
	* 혹은 버그 때문일 수도 있다. 이로 인해 의견차이가 있어 하드포크
	* 기능 개선을  하드포크가 발생할 수 있다.
	* 룰을 바꾸는 데, 룰 바꾸기 전과 바꾼 후 규칙이 서로 compactable하지 않는 경우
	* 즉 절대다수의 인정없이 하드포크하는 것은 위험
	* 비트코인의 모든 노드는 서로 독립적이고, 새로운 규칙이 맘에 안들 수 있다. 그럼 새 것을 인정하지 않는 방향으로
* ![[Pasted image 20231031171016.png]]
* 4a, 4b는 서로 거의 동시에 블록 채굴 성공
* 6번 이후로 새로운  규칙 적용, 두개의 체인으로 나누어진다.
* 파란 7 쪽이 새로운 것을 적용한 거라면, 이 블럭에는 새로운 서명 알고리즘이 포함된다.
* 오랜지 입장에서 파랑은 invalid block으로 간주할 거다.
* 형식이 다르기에
* b체인은 a블록들이나 이에 해당하는 transaction은 무시한다.
* 만약 서명이 없는 트랜잭션을 8b에 넣는다면
* 주황입장에서는 8b가 valid하나, 옳지 않은 체인 뒤에 있으므로 orphan으로 본다.
* ![[Pasted image 20231031171618.png]]
* pos : proof of state 지분증명. 자신이 가지고 있는 이더리움의 양에 따라 검증자로 채택될 확률이 높아진다. 이럼 훨씬더 신속하게 블록에 넣을 수 있고, 전력 손실이 적다. 하지만 이게 무조건 좋은 건 아니다. pow(proof of work)는 훨씬 더 안전하다.
* pos는 cheating이 가능한가? 많은 코인을 가질 수록 유리하기에 탈 중앙화가 흔들릴 수 있다.
* 개발자들은 하드포크로 개발하는 것을 꺼린다.
* 만약 찬성 반대 반반이면 하드포크 하면 안된다. 이러면 두개의 체인이 생기는데 서로 상대방을 인정하지 않는다. 그럼 채굴 파워가 절반으로 줄어든다. 이러면 51%공격이 더 수월하게 가능해진다.
* segwit은 반대 3프로 밖에 안되었다.
* ![[Pasted image 20231031172118.png]]
* 포크를 지지하지 않는 쪽도 배려하면서 점진적으로 나아가자
* compatible하게 -> 소프트포크
* 사실 소프트포크는 포크라고 볼 수 없다. 그냥 하드포크 반대
* 새로운 안을 받아들이지 않은 노드가 봤을 때도 transaction이 valid하다고 판단해야한다.
* 즉 기존규칙을 모두 만족하면서 뭔가 추가한 것
* 소프트 포크로 하는 것은 제약을 더 가하는 것만 가능. 기존 방식을 완화하는 것은 안된다.
* 하드포크는 이러한 제약이 없다. 어쩌피 갈라지기에
* 소프트 포크는 모든 노드가 일시에 새 기능을 구현한 소프트웨어로 넘어가자 약속할 필요가 없는 것. 즉 새로운 구현 적용을 강조하지 않는다.
* ![[Pasted image 20231031172714.png]]
* NOP는 no operation
* 즉 아무 것도 안하는 것
* 미리 만들어놓은 nop코드가 10개가 있다.
* nop쓰는 것은 불법은 아니다. 쓰면 그걸 무시하고 지나간다.
* 예로 nop 5 와 256이면 이걸 뭐라고 약속하자 -> 이걸로 구현되어있구나 알면되고, 모르는 노드는 그냥 넘어감
* ![[Pasted image 20231031172912.png]]
* 소프트 포크에 대한 비판
* 물론 소프트포크는 문제가 발생했을 때 해결해야하므로 필요하나.
* 그럼에도 불구하고 발생하는 문제점
* 기술적으로 소프트웨어는 구현하기가 깔끔하지 않다.
* 이전기능을 구현한 노드를 배려해야하기에 이전 기능을 버릴 수 없고, 즉 코드가 복잡해진다.
* 그럼 maintainance 비용이 증가한다.
* segwit은 hardfork가 맞았는데, softfork로 했다.. witness 데이터 어디에 넣어? coinbase는 output만 존재, 이 밑에 머클트리를 또하나만들고 witness 데이터를 여기에 넣으므로 segwit을 적용했다.
* 문제는 코드가 매우 지저분해졌다. coinbase는 output하나만 있는게 맞는데 dummydata가 생김
* 두번째는 validation relaxation
* 기존노드는 새기능을 넣었는 지 몰라, 즉 트랜잭션이 동일해보인다 즉 검증 불가능. 즉 검증책임은 새 기능을 적용한 노드에게 검증책임이 모두 넘어감
* 즉 검증이 느슨해짐
* 규칙을 풀어준건데, 제한이 풀어진 이후로 공격자가 쉽게 훔쳐갈 수 있는 상황이 생긴다.
* 즉 비트코인을 훔쳐갈 수 있기에 안된다.
* ![[Pasted image 20231031173830.png]]
* 해쉬 rate와 채굴파워의 관계
* th는  teraHash 초당 1조
* 해쉬 파워가 커지므로 채굴 난도 증가
* ![[Pasted image 20231031174018.png]]
* 초기에는 집 컴퓨터로
* asic 비트코인 채굴 전용
* ![[Pasted image 20231031174240.png]]
* 채굴 사업에 관심이 생겨 채굴해볼까 
* 할 떄 합리적판단 기준
* hardware cost는 일회성, 
* 비트코인은 막대한 전기를 사용한다. 
* 전기를 생산하면 그냥 사라지는 전기도 많다.