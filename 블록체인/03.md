* ![[Pasted image 20230925171014.png]]
* 사용되지 않은 것 utxo
* 사용된 것 stxo 이건 miner들이 관리할 필요 없다. 즉 utxo만 가지고 있으면 된다.
* 비트코인을 received 했다. ->bob의 wallet이 utxo를 가지고, payment가 있었다.
* 여러 계좌의 잔액 합이 balance인데 wallet이 계산해준다.
* satoshi는 10의 8승 분의 1 bit코인
* sathoshi가 가장 작은 단위
* ![[Pasted image 20230925171218.png]]
* 이를 redeem 하기 위해서는 퍼즐 
* 다른 사람이 bob의 address로 계산할 수 있다면 신뢰성 깨짐
* ![[Pasted image 20230925171350.png]]
* A가b에게 커피값을 줬다면 그걸 bob이 가져와 input으로 사용. 즉 bob의 주소가 있어야함. 0.015는 커피값 0.0845는 거스름돈, 이는 A의 wallet이 만들어준다.
* ![[Pasted image 20230925171555.png]]
* txid는 어떤 transaction의 id에서 가져올지
* vout은 output의 몇번쨰 reading 할지, 즉 이게 unlocking script, 그 output이 locking script
* scrkptsig가 unlocking script
* replaced by fee: 거래비가 부족했을떄 output sum 조금만 낮추면됨. 근데 sequenceㄴnumber는 요즘 안씀. wallet이 이를 알아서 맞춰주기에
* ![[Pasted image 20230925171924.png]]
* utxo가 아니면 doublespend이기에 반드시 utxo . 이는 어떻게 알아? utxo transaction id가 존재하는지
* 0.1은 받은 것것
* ![[Pasted image 20230925172117.png]]
* 비트코인도 코드가 있지만 매우 제한되어서, 제한된 기능만 함. 근데 최근에는 새 아이디어로 script 기능 커짐
* script는 프로그래밍 언어(java같은게 아니라 극히 제한된 일만 하도록), stack기반이라는 것은 사용하면 stack기반의 virture marchine상에서 사용
* script에는 기존이 없음. 즉 어떤것도 기억 x
* turing imcompleteness는  루프 for while등이 없어 공격자가 의도적으로 무한 루프 넣어서 망가지는것을 막음, 조건문정도만 허용
* 복잡도가 뛰지 않아 악성 배제 가능, 시간 예측 가능
* locking은 output 즉 bob만이 가져다 쓸 수 있도록
* wallet이 가져와 쓰는 것 unlocking
* pay to public: 비트코인은 pay를 위한, 어디에 pay? B의 주소에 이 주소는 public key를 해쉬해서 만듬, 즉 public key 해쉬한 곳에 보내겠다.
* ![[Pasted image 20230925172820.png]]
* unlocking locking 코드를 이어 붙여서 스택에서 실행 
* scriputpubkey인 이유는 publickey를 hash해서 만들기
* ![[Pasted image 20230925172936.png]]
* 2 3은 operand 이를 satck에 푸쉬,2푸쉬 3도 푸쉬, add는 연산자 ->stack의 피연산자 두개 가져옴. 이 결과를 어딘가 저장-> stack에 저장 , 다시 5는 operand -> stack에 푸쉬 -> equal은 연산자 -> 두 피연산자 가져옴
* 이게 스택기반 연산
* ![[Pasted image 20230925173202.png]]
* sig는 피산자 이 sig는 private키로 한것, sig는 밥이니까 서명을 할 수 있다.
* pubk 도 값(output 만드는데 사용된) 즉 bob도 안다
* 연산자 dup(duplicate) 즉 뭘 복제> pubk 즉 pubk가 다시 들어감
* hash160은 publickey를 가지고 address 만드는 것(해쉬를 두번한것, 그 결과가 160비트라)
* 근데 이 operand는 pubk가져오고 이를 해쉬해서 stack의 탑
* ![[Pasted image 20230925173621.png]]
* publkhash는 bob이 아는, 
* equalverify는 (equal과 다르다) 스택에서 두개 가져와 같은 지 검증하고 같으면 그냥 진행, 즉 true를 넣고 그런게 아님, 안같으면 그냥 멈춤
* checksig는 pubk, sig 를 가지고 signature 검증(검증용publickey, 어떤메세지의 signature인가) 결과를 넣는다
*  true이면 성공적
* 즉 카페주인인 밥의 publickey로 해쉬하고 이를 계산한것의 publickeyhash값과 같은 지 체크하여 내가 사용하도 되는지 체크
* ![[Pasted image 20230925174051.png]]
* multisig는 회사에 있는 재무를 내 개인계좌로 넣을 수 있다.이를 막으려고 multisig 적용
* 즉 두명이상의 서명이 필요
* checksig는 리턴값을  스택에 넣는다.
* 계산에는 sig가 있는데 만약 받는 사람만 바꾸면 sig 틀리니까. 
* ![[Pasted image 20230925174525.png]]
* sig, 검증대상, 
* sighash는 transaction 전체는 n으로보고 서명 진행
* 그렇지 않고 일부만 적용 , 이때 sighash flag
* ![[Pasted image 20230925174636.png]]
* 파란색은 서명한 곳
* NONE은 미친놈 고속도로타면서 돈다발 뿌린것. 즉 왼쪽 파란색은 내돈 prove 오른쪽 공백은 누구나 바꿔서 써도 된다.
* 
* ![[Pasted image 20230926170330.png]]
* 클라우딩 펀드, 자금 모집등에 any one can pay 사용
* 즉 오른쪽은 투자대상, 왼쪽은 투자자. 이를 모아서 하나의 트랜잭션 가능
* None: 미친놈, 백지수표
* NONE/ANYONECANPAY: input만 서명,내 계좌에서 끌어와거래할 건데 아무나 가져와. 단 밑도 비어있어. dust collector상황. 즉 내가 가진 액수가 지극히 미미할떄 털어버리고싶어. transaction fee 내기 싫으니 누가 가져가. 그럼 그걸 모아서 가져감. 
* single/anyonecanpay:  트랜잭션을 합쳐 하나의 트랜잭션 만들때.  input, output이 정해졌으므로 다수를 모아 하나로. 즉 다 모아서 하나의 트랜잭션으로 만든다. 그럼 transaction fee 절감 가능
* 
* ![[Pasted image 20230926170946.png]]
* 주소 만드는 방법: ecdse사용해 public키로 주소만듬(해쉬후 또다시 해쉬)-> 160비트 결과(fingerprint)에 checksum 붙임(손상방지), 앞에 00 붙이고 전체 base58로 바꿈
* base58은 01은 외우기 어려워서 사람에게 그나마 친숙하게 변경
* base64 = 영어 대문자 영어소문자 숫자 =, +
* base58 = 영어 대문자(26) 영어소문자(26) 숫자(10)에 헷갈리는 4개 제외(영하고 오, 엘 아이 버림)
* ![[Pasted image 20230926171417.png]]
* 여러 블록체인에 범용으로 쓰임, blockchain.com에서 거래를 모두 볼 수 있다.
* meta mask에서 wallet 사용가
* 
* ![[Pasted image 20230926171812.png]]
* ![[Pasted image 20230926171914.png]]
* transaction을 보낸 게 끝이아니라, 블록체인에 포함 되었는지까지.
* 5비트보낼떄 데이빗이 서명
* 네트워크에 뿌림(broadcast)
* 채굴자가 검