* 비트코인은 p2p 기반이다.
	* 즉 들어가고 나갈 때 승인을 받을 필요없다.
	* TCP를 사용한다.
	* 계급없이 peer끼리 소통한다.
* 각 노드의 행동
	* 1. 한 노드가 자신이 원하는 트랙잭션을 주위 peer에게 뿌린다.
	* 2. 이를 받은 노드들은 유효성을 판단한다.
		* 트랜잭션의 타당성을 판단한다.
		* 트랜잭션이 UTXO인지(즉 STXO가 아닌지) 확인한다.
		* 이미 한번 받아들인 트랜잭션인지 판단한다.
		* 트랜잭션의 script가 받아들일 수 있는 지 판단한다. 즉 네트워크에서 허용되는 스크립트인지 판단한다.
	* 3. 유효하다면 이를 pool(자신의 저장소)에 넣는다. 이 pool에는 아직 블록체인에 포함되지 않은 transaction이 들어가 있다.
* race condition
	* 경우에 따라서는 체인이 둘로 갈라질 수 있다.
		* A가 같은 코인에 대해 두가지 transaction을 동시 전파
		* A,B가 같은 코인 동시채
	* 가장 긴 체인 규칙(Greatest Cumulative Proof of Work)
		* 즉 두 체인 중에서 결국 대세가 존재하고 대세를 따른다.
* ![[Pasted image 20231021190217.png]]
* HEADER
	* 헤더는 메타데이터이다.
	* 즉 블럭에 대한 설명과 이전 블럭에 대한 해쉬포인터를 가지고 있다.
* Timestamp
	* 블록이 만들어진 시간.
* Nonce
	* 채굴자가 임의로 계산하기 위해 넣은 값
* Difficulty
	* 채굴의 난이도
	* 과거 2016블럭을 보며 조절한다.
* merkle root
	* 해당 블록에 포함된 모든 트랜잭션의 데이터를 요약한 값입니다.
![[Pasted image 20231027110307.png]]
* time stamp는 만들어진 시점
* difficulty target: 난도
* nonce: x값 해시퍼즐푸는 
* ![[Pasted image 20231027110455.png]]
* block header hash: 블럭해쉬이다. sha256두번 돌려서 나온 결과
* 32byte의 결과가 블럭 헤더 해쉬
* 왜 두번 돌릴까?
	* 이유는 정확히 없다
* 블럭 식별 방법 
	* 블럭의 하이트를 언급
	* 두 개이상의 같은 블럭하이트를 가진 블럭이 있을 수 있고 결국 이는 수렴할 것
* ![[Pasted image 20231027110711.png]]
* 머크루트의 해시값
* 디피컬티는 어떻게 이런 숫자가 어려움을 표현할까?
	* 난도가 이런 숫자가 나오도록 하는 알고리즘이 있으나 중요하지 않다
* ![[Pasted image 20231027110837.png]]
* 리프노드가 4개인 머클 트리
* HA는 Hash(T A)를 sha256한번 더 돌린 것
* Hash(tx A)는 A를 해쉬한 것
* 두 해쉬값을 더해 해쉬
	* 여기서 더하기는 두 스트링을 이어 붙인 것
	* 256bit + 256bit 로 해쉬를 적용
* 이 최종값이 위의 머클 루트에 들어간다.
* 이를 사용하는 이유는 효율성을 위해, 단순 해쉬들을 테이블로 나열하는 것보다  낫다.
* ![[Pasted image 20231027111156.png]]
* 어떤 트랜잭션이 포함되는 지 확인하려면?
* 만약 채결한 트랜잭션이 Hd라면 이 위로만 따라가면 된다/
* 즉 depth(logn)만큼만 확인하면 이게 포함되는 지 알 수 있다.
* ![[Pasted image 20231027111336.png]]
* Hk를 계산하고 루트까지가는 모든 노드(점선 네모)를 확인
* 이 때 체크를할 때 도움을 받을 수 있는 노드가 파란색
* ![[Pasted image 20231027111642.png]]
* 돈을 벌려고 채굴을 하는 게 비트코인을 견고하게한다.
	* 채굴과정에서 검증과정을 거친다.
* 비트코인의 목적은 탈 중앙화 이 역할을 여러 마이너가 행동한다.
* 채굴보상이 원화가 아니라  코인인 것도 중요
* 원화는 가치가 떨어질 수 있다. 이럴 때는 채굴을 잘 안하려할 수 있다.
* 그럼 btc의 가치가 떨어지면? 비트코인의 신뢰성을 더욱 높일려 할 거고, 안정성이 높아져 교환가치가 다시 높아질 수 있다.
* 비트코인의 총발행량을 정함으로써 화폐가치를 지킨다.
* ![[Pasted image 20231027112224.png]]
* 트랜잭션이 블럭에 포함되었다 = confirm되었다. one confirmation 이후로는 웬만하면 신뢰성을 갖는다.
* 채굴 보상은 coinbase reward, transaction fee
* 작업증명:채굴을 하는 방법은 알려져 있지만, 빨리 푸는 방법은 존재 하지 않는다. 작업증명이라는 것은 short cut이 없다는 것에 기반을 한다. 즉 채굴을 하는 데 굉장한 양의 계산을 했을 것이고 증명으로 nonce제공
* ![[Pasted image 20231027112516.png]]
* transaction fee =input -output
* 현재 기준으로 채굴자가 가져가는 보상의 0.5퍼센트 이내
* 채굴자는 block reword를 보고 하지만, 이는 4년에 반감기를 가지고, 그럼 채굴을 하는 데 드는 비용은 동일하므로 transaction fee를 높이게 된다.
* ![[Pasted image 20231027112714.png]]
* block reward는 21만 비트코인으로 제한
* 지금은 6.25
* ![[Pasted image 20231027112913.png]]
* 마이너가 트랜잭션을 받아서 이를 가지고 블럭을 만들려 함.
* 검증이 끝난 transaction을 머클트리로 구성 후 
* ![[Pasted image 20231027113220.png]]
* 해쉬 퍼즐을 푸는데는 오래걸리지만
* 이를 검증하는 과정은 매우 간단하다.
* 해쉬는 256비트의 0 1 sequence 즉. 각 자리의 확률이 절반이라면 앞의 128비트가 모두 0일 확률이 낮다.
* 이를 통해 난도 조절을 한다.
* ![[Pasted image 20231027113559.png]]
* 마이닝 과정
* nonce는 32비트
* ![[Pasted image 20231027113729.png]]
* 모든 마이너가 같은 퍼즐을 풀고 있을까?
	* 완전 같은 퍼즐을 풀 때 더 빠른 머신을 사용하는 쪽이 이긴다.
	* 답은 모든 마이너가 각기 다른 퍼즐을 푼다!
	* nonce를 제외하고도 해쉬 대상(transaction)을 갖기에 서로 다르다.
	* a,b가 똑같은 트랜잭션들을 가지고 한다하더라고 머클트리의 위치, 즉 순서가 바뀌면 해쉬값이 바뀐다.
	* 즉 x 에 y를 붙여 해쉬하는 것과 y에 x를 붙여 해쉬하는 값은 서로 다르다.
	* 완전히 같은 순서, 같은 트랜잭션을 해도 같지 않다. 결정적으로 자신의 주소로 채굴 보상을 보내니까 다르다.
	* ![[Pasted image 20231027114228.png]]
* ![[Pasted image 20231027114253.png]]
* 2016블럭은 2주
* ![[Pasted image 20231027114449.png]]
* 초록색: 해쉬 파워
	* 해쉬 파워가 커지면, 채굴이 일찍끝난다
	* 그럼 난도를 높인다.
	* 초록색과 빨간선이 만나도록 한다.
* ![[Pasted image 20231027114557.png]]
* 파란색은 채굴 걸리는 시간
	* 난도가 상승하면서 증가한다.
* ![[Pasted image 20231027114648.png]]
* cpu로 가능했던게 cpu(parrell이용)-> Fpga(gpu보다 특화된 장치)-> asic(채굴 공장,sha 256 채굴에 특화됨)
* ![[Pasted image 20231027114810.png]]
* 채굴 공장
