* ![[Pasted image 20230926172825.png]]
* ## p2pkh
	* paytopublickeyhash, 대부분의 script
* ![[Pasted image 20230926172928.png]]
* ## multisignature:
	* 두 사람 이상이 서명을 해야지 옮길 수 있다.
	* m, n은 사람의 수 m <= n
	* 즉 5명중에 3명 이런 느낌
	* N은 사장이 신뢰하는 사람들
	* M은 몇명이 최소 모이면 되는 지
	* 밑은 2 of 3
	* 시그니처니까 값, 스택에 푸쉬, 2푸쉬, 푸쉬푸시퓌쉬, 푸쉬, 이후 checkmultisig
	* ![[Pasted image 20230926173435.png]]
	* 스택 연산에 버그가 있다.
	* bitcoin core(고유명사): reference implementation, 비트코인 코어 개발자가 개발한 코드(계속 코어 개발자가 보수 중), 대부분의 채굴자가 채택(왜? 이거 말고는 검증이 안되어있으니, 내 밥벌이를 병신에 맞길 수 없다.)
	* checkmultisig에 오류가 있었다. -> 근데 그냥 놔두고 회피하자 -> 앞에 0 집어넣는다.
	* 이건  2개만 확인해야하는데 3개를 스택에서 확인해서 문제 -> 아무 숫자 집어넣자
	* 
	* 
* ## pay to script hash
	* ![[Pasted image 20230926173925.png]]
	* 모하메드라는 회사사장. 5명의 믿을 만한 사람 2 of 5, locking 코드이므로, 매번 집어넣어야한다. publickey 5개는 300byte넘는다... transaction fee는 transaction크기에 비례(액수 무관)-> 크기를 줄여야해.
	* 사용될때까지 UTXO(unspend transcaction output)를 가지고 있어야한다. 근데 이건 저장공간 크기가 key만큼 더 든다.
	* 즉 복잡성이 커졌다.
	* 해결: pay to script hash: script hash에 페이, 즉 송금의 목적지에 코드의 해쉬값이 있다., 코드로 페이, 코드를 제시
	* 즉 코드를 해쉬해서 확 줄어듬. redeem할떄는 이코드를 한번만 제시(즉 꺼내서 확일할떄, 소유자 확인 할떄, 제시한 스크립트를 해쉬해서 일치하는지 확인)
	* 사
	* 위의 2---는 코드 이를 해쉬한 값을 목적지로, 그리고 여기로 돈을 보내라. 
	* 크기는 20byte, 32byte 중하나
	* 원래 key하나는 512bit 즉 훨씬 많이 줄어들었다.
	* ![[Pasted image 20231010171228.png]]
	* 즉 돈을 스크립트 해쉬로 보내고, 이에 대해 정보를 마이너가 가지고 있어도 부담이 없다.
	* 돈을 쓸려할떄 redeemcode(2<Mohammed ---)를 제시.
	* ![[Pasted image 20231010171524.png]]
	* Locking Script는 목적지, Unlocking은 출발지에
	* 프로그램 문제가 있어서 3개를 보게 되므로, 처음에 0을 하나 넣어준다. 아무 값이든 무관
	* Table1는 기존의 복잡한 방법.  마이너가 많은 정보를 저장해야함
	* Table2는 해쉬를 이용한 것.
		* 0은 버그값
		* locking과 unloacking을 이어붙여 확인, 20byte hash갑이 redeem스크립트 해쉬한 값이 들어간ㄷ.
		* redeem script를 unlocking에 넣어 제시, Hash160이 이를 해쉬하여 스택에 넣고 두 해시값이 일치하는지 확인
		* -
	* ![[Pasted image 20231010172235.png]]
	* chekmultisig는 한바이
	* ![[Pasted image 20231010172306.png]]
* ![[Pasted image 20231010172608.png]]
* 
* ## seqwit:
	* 거래 블록 사이즈를 늘리는방법, 이건 큰 변경
	* (1)에서 <2 tisig>를 HASH160으로 해쉬. 다시 스택 푸쉬
	* redeem 푸쉬
	* Equal로 확인
* ![[Pasted image 20231010173123.png]]
* p2sh에 또 p2sh를 넣는 것은 허용 안한다.(해쉬값 다시 해쉬)
* 반대로 검증이 사용할 때까지 미뤄지는 것.
* 만약 키를 해쉬한 값을 잘 못해서 목적지에 넣는다면.. 다시는 찾지 못해.
* ![[Pasted image 20231010173613.png]]
* 특허용 비트코인
* 파일을 해쉬해서, 목적지 인척 목적지에 넣어주면 된다. 
* 그럼 내가 이 파일을 만들었다는 것을 검증 가능
* 만약 비트코인 transaction을 payment용도로 사용할려한다면 발생하는 문제점
	* UTXO 즉 output을 리딤해서 사용할 수 없다.
	* 즉 마이너는 언젠가 쓸 수 있는 utxo일것이다.라고 생각하고 끌고 간다.
	* 근데 이 transacition output은 사용되지 않아 없어질 수가 없다.
	* 사용이 되면 그 utxo는 가지고 갈 필요없지만 사용이 안되었으면 utxoㄹ,ㄹ 지울수 없다.
* ![[Pasted image 20231010174331.png]]
* 따라서 저정용으로 쓰고 싶으면 이걸 사용하라고 권장
* 이는 마이너들이 저장을 하지 않는다.
* return이 포함되면 마이너가 신경 안쓴다.
* ![[Pasted image 20231010174521.png]]
* 기록해주는 회사가 생김.
* RETURN data 에 data에 타입을 넣고 이 뒤에 해쉬값 넣는다
* ![[Pasted image 20231010174927.png]]
* ![[Pasted image 20231013110221.png]]
* Verify가 붙은 것과 붙지않은것, 
	* 붙었으면 operation결과를 스택에 푸쉬x, 결과 문제생기면 멈춤, 즉 가드 클로져
* 스크립트가 밥의 서명과 프리 이미지를 요구한다( 이건 h(x) = y에서 x를 의미, 즉 y계산이 나라는 것을 증명하는 것)
* equalverify = equl + verify
* ![[Pasted image 20231013111106.png]]
	* 이건 locking
* ![[Pasted image 20231013110512.png]]
	* 이건 unlocking
	* 이게 필요, 
	* 스택에 푸쉬하면 맨위에 hash pre-image 존재
	* Hash 160은 피연산자 필요, 즉 스택에서 프리이미지를 가져온다. 이를 해쉬한다. 그리고 다시 스택에 넣는다.
	* 그 위 expected hash는 피연산자니 스택에 넣음
	* equal을통해 스택에서 두개 꺼냄 즉 해쉬된 값과, expedcted hash를 꺼내 같은지 확인하고 스택에 넣지는 않는다. 다르면 그냥 멈춤
	* 이후 스택에는 bob의 signature만 있는데
	* 이후 스택에 bob의 public key를 넣고
	* check sig후 verify없으니 스택에 true등 푸쉬
	* ![[Pasted image 20231013110927.png]]
	* expression은 평가되고 state는 실행된다.
	* ![[Pasted image 20231013111011.png]]
	* 결과가 true false로 stack에 들어가고 if가 스택에서 꺼내 확인
	* 만약 false면 if안에 실행 x
	* ![[Pasted image 20231013111158.png]]
	* 근데 if가 무조건 좋을까? 언제 verify?
		* 가드가 필요하면 verify
		* 둘 이상의 경로를 따라가면(if ,else)등이면 if가 낫다.
	* ![[Pasted image 20231013111336.png]]
	* 엘리스 혹은 밥이 redeem할수있는 utxo
	* 엘리스도 사장, 밥도 사장이라, 아무나 돈을 가져갈 있다 -> multi signature 이용하면됨. -> 1 of 2
	* 다른 방법으로 if를 사용할 수 도있다.
	* ![[Pasted image 20231013111609.png]]
	* 1은 true, 0은 false
	* ![[Pasted image 20231013111749.png]]
	* 중첩, 사실은 tab은 없음.
	* 