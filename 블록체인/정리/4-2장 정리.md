# 머클 트리
----
![[Pasted image 20231027110837.png]]
HA는 Hash(TxA)를 sha256으로 해쉬한 것, 결과는 256bit이다.
즉 TxA를 해쉬한 값을 한번 더 해쉬한 게 HA이다.
HA+HB는 두 스트링을 이어 붙인 것이다.

이를 통해 아래 Tx를 임의로 바꾸면 해시값이 달라지므로 머클트리에서 끊어지게 된다.
또한 HB 트랜잭션이 변경되었는 지 확인하려면 depth만큼만 확인하면 된다.
![[Pasted image 20231027111336.png]]
예를 들면 이와 같이 HK를 확인하려면 HL, HIJ, HMNOF, HABCDEFGH의 도움만 받으면 된다.

# Mining
* 채굴은 비트코인을 견고하게 만든다.
* 또한 채굴은 비트코인을 견고하게 만들며, 중앙 권력없이 네트워크 합의를 가능하게 한다.
* 채굴 보상과, transaction fee는 채굴자가 채굴을 하는 동기를 제공한다.
* 트랜잭션이 블록체인에 포함되었다 == confirm되었다.
* 시작이 지날수록 block reward는 감소하고 있고, 이를 transaction fee가 대체하게 될 것이다.

## finding valid blocks
* 보류된 transaction pool에서 타당한 transaction들을 골라 merkle tree로 구성한다.
* 이전 블럭을 가리키는 header와 함께 block을 만든다.
* 문제를 푸는 nonce를 찾는다.

	## mining과정에서 nonce를 푸는 과정은 모두 똑같은 퍼즐을 푸는 거 아니야?
	아니다. 왜냐하면 어떤 트랜잭션을 포함시키는 지, 트랜잭션의 순서에 따라 hash값이 달라지므로 모두 다른 퍼즐을 푸는 것이다.
	또한 transaction에 코인을 받을 주소를 명시하기에 달라진다.
	![[Pasted image 20231204205741.png]]
	참고로 돈을 받을 마이너의 주소는 머클트리 가장 왼쪽에 기입한다.
	이를 coinbaseTransaction이라고 한다.
	이 트랜잭션은 기존에 존재하던 코인을 사용하는 것이 아니므로 input이 필요없다.
## Determining the difficulty
![[Pasted image 20231204205902.png]]
채굴 난이도는 매 2016블럭마다 다시 설정된다.
참고로 2016블럭은 대략 2주이다.
위는 새로운 난이도를 결정하는 식이다.
최근 2016블럭을 채굴하는 데 적은 시간이 걸렸다면 난도는 올라가며
최근 2016블럭을 채굴하는 데 많은 시간이 걸렸다면 난도는 감소한다.


# Decentralized Consensus
* 비트코인에는 중앙권력은 없지만, 각각의 모든 노드는 완전한 레코드라고 신뢰되는 장부에 대한 카피본을 가지고 있다.
* 블록체인은 중앙 권력에 의하여 만들어 지는 것은 아니지만, 모든 노드에 의하여 만들어진다.
* 탈중앙화된 합의는 네트워크 전역의 노드에 의하여 독립적으로 발생하느 4가지의 상호 작용으로 발생한다.
1. 모든 노드는 각각의 transaction에 대하여 verification을 한다.
2. 이러한 트랜잭션을 새 블럭에 넣어 채굴을 시도한다.
3. 모든 노드들은 새로운 블록에 대하여 verfication을 거쳐, 자신의 체인에 포함시킨다.
4. 어떤 블록 위에 내가 연결시킬지는 각자 판단한다.


# Independent Verification of Transactions
트랜잭션을 받은 노드는, 이 트랜잭션을 주변에 뿌리기 전에 트랜잭션을 verification한다. 만약 valid하면 주변으로 뿌리지만, invalid하면 노드는 transaction을 버린다.

각각의 노드는 트랜잭션에 대하여 다음을 확인한다.
* 트랜잭션의 syntax하고 data structure가 타당한지
* 트랜잭션 스크립트는 튜링 완전 허용하지 않는데, 이에 대해 적혀있는 스크립트가 타당한지
* 트랜잭션이 채굴된 블록에 없고, 트랜잭션이 utxo를 언급하고, 그것들이 사용되지 않았는 지
* 트랜잭션 사이즈가 최대 사이즈 이하인지(지금은 witness data 제외하고 1mb이다.)




# Coinbase transaction
![[Pasted image 20231030170958.png]]
vin 안의 coinbase값은 2^32개의 nonse를 다 넣어봐도 답이 안 나올 경우 트랜잭션의 위치를 바꾸는 것은 시간이 오래걸리므로, 간단하게 coinbase Transaciton안의 coinbase값을 변경하는 것이다.

여기서 value는 보낼 코인 이는 채굴 비 하고  transaction fee를 합친 것이다.
address는 miner의 주소

# Extra Nonce Solution for Mining Hash Puzzles
기존에는 4byte의 nonce값을 바꾸는 것만 하더라도 충분히 답을 구할 수 있었으나, 채굴 난도가 올라가면서 4byte nonce를 모두 바꿔도 정답이 안나오는 경우가 생겼다.
따라서 이를 위하여 valid한 block을 찾기 위해 nonce 값을 위한 추가 공간이 마이너는 필요해졌다.

이러한 nonce값을 넣기 위하여 coinbase transaction을 이용하였다.
이러한 2byte이상 100byte이하의 공간을 이용하여 마이너들은 추가적인 nonce값을 사용할 수 있다.


# Consensus Attack
비트코인의 consensus 메커니즘은 이론적으로 공격자가 매우 큰 해시파워를 갖게 된다면 취약해질 수 있다.

그럼에도 불구하고 이러한 해시파워를 가지만 마이너는 미래 혹은 매우 최신의 몇 블락에만 영향을 끼칠 수 있다. 왜냐하면 체인이 길어질 수록 더욱더 견고해지기 때문이다.

아무리 강한 miner라 하더라도 비트코인 훔치거나, 서명없이 비트코인을 사용하거나, 과거의 트랜잭션을 바꿀 수는 없다.

만약 특정노드가 51프로 정도의 power를 갖게 된다면
forks를 유발하거나 double-spend, dos공격을 야기할 수있다.

forks, double-spend는 첫번째로 기존의 블럭들을 새로운 fork가 더 길게 만들어 invalid하게 만들 수 있고, 두번째로 특정 거래에 대해 double-spend를 하여 이득을 취할 수 있다.

참고로 double-spend는 confirm되기 전에 시도할 수 있고,
fork는 confirm 된 후에 시도할 수 있다.

공격자는 특정 transaction을 무시할 수 있으며, 만약 이 트랜잭션이 다른 블럭에 포함된다면 fork를 통해 다시 포함안되게 만들 수 있다.

어떤 연구결과에 따르면 실질적으로 30프로의 해시파워를 가지면 공격이 가능하다고 한다.


# Changing Consensus Rules
consensus rule은 모든 노드가 합의를 하는 데 사용되는 알고리즘이지만.
시대의 변화에 맞추어 consensus규칙 또한 바뀔 수 있다.

## Hard Forks
consensus rule의 변화는 하드 포크를 야기할 수 있다. 이 때 하드포크로 인하여 갈라진 두 체인은 수렴되지 않고 독립적으로 진행된다.
이렇게 분리된 두 체인은 완벽하게 서로 다른 규칙에 따라 네트워크가 운영된다.

하드포크가 된다면, 이에 대해 업그레이드 하지 않은 노드는 새롭게 만들어진 체인에 참여할 수 없게 된다.

참고로 절대다수의 인정없이 하드포크를 하는 것은 위험하다. 이럴 경우에는 소프트 포크를 하는 것이 낫다. 왜냐하면 하드포크를 통해 유저들이 갈라지면, 그만큼 해시파워가 약해지기 떄문이다.

# Changing Consensus Rules
하드포크를 하는 것은 위험하다.
절대 다수의 동의가 없는 한 하드포크를 하지 말아야 한다.

이를 위해 soft fork가 존재한다.
### soft fork
만약 새로운 규칙을 적용하여도, 기존의 노드들이 새로운 규칙에 대해 valid하다고 판단할 수 있다면 soft fork를 적용할 수 있다.

참고로 소프트포크는 하드포크처럼 실제로 포크하는 것이 아니다. 즉 기존 규칙을 유지하면서도 새로운 규칙과도 합의를 이뤄 운영할 수 있는 규칙의 변경을 의미한다.

이렇게 소프트포크를 하기 위해서는 기존의 규칙을 확장하는 게 아니라 기존의 규칙을 제한하는 방식으로 이루어져야 한다. 즉 기존의 규칙을 완화하는 것은 안된다.

소프트 포크 구현은 모든 노드가 업그레이드 해야하는 것은 아니고, 업그레이드 안한 노드도 합의에 참여할 수 있다.

소프트 포크는 이를 구현하기 위해 기존에 비트코인에 존재하는 NOP opcode를 재해석하여 사용하기도 한다.
실제로 NOP opcode는 아무 역할도, 행동도 하지 않으며, 이를 실행하는 스크립트가 무시한 거처럼 보인다.

즉 오직 새로운 rule을 적용한 사람만 이 NOP에 대해 이해하고 실행하며, 나머지 노드들은 그냥 무시한다.

## Criticisms of Soft forks
* 소프트 포크는 코드의 양이 증가하고, 복잡성이 증가하기에  미래에 유지 보수 비용이 증가한다. 
* 한번 업그레이드한 soft fork는 되돌릴 수 없다. 만약에 업그레이드를 취소하면 기존까지 업그레이드한 노드들이 손해를 볼 수 있기 때문이다.