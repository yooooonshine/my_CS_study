* ## 릴레이션
	* 릴레이션 스카마:  필드(열, 에트리뷰트)와 릴레이션 이름, 도메인을 명시한 것
		* 필드의 순서는 중요(인덱스로 1, 2, 3등으로 붙이기에)
		* sql에서 필드의 이름은 검색하는 문장에서 사용하고, 순서는 투플을 삽입하는데 사용
		* 도메인 제약조건(domain constraints): 그 릴레이션의 각 인스턴스가 만족해야하는 조건을 명시.
		* degree,arity(차수): 릴레이션의 필드 수
		* cardinality(카디날리티): 릴레이션인스턴스의 행의
	* 릴레이션 인스턴스: 테이블, 레코드(튜플)의 집합.
* ## 관계 데이터베이스
	* 관계 데이터베이스:  다른 이름의 릴레이션들의 모임
	* 관계 데이터베이스 스키마: 릴레이션들을 위한 스키마의 모임
	* 관계 데이터베이스 인스턴스:  릴레이션 인스턴스의 집합
* ## SQL
	* DDL:
		* ![[Pasted image 20231003150749.png]]
		* UNIQUE (name, age) 등으로 키를 선언할 수 있다(primary key라는 것은 아니다). 즉 이 키는 후보 키이고, name과 age가 같은 사람은 없다라고 선언하는 것과 동일하다.
		* PRIMARY  KEY (sid) 등을 통해 기본키 설정이 가능하다.
		* 
	* DML:
		* Insert문
			* ![[Pasted image 20231003150601.png]]
			* into절의 열이름은 생략가능하나, 명확히하는 게 좋고, emp_table은 테이블이름
			* emp_table에 추가하는 
		* delete문
			* ![[Pasted image 20231003150904.png]]
			* from 옆에 사용항 테이블 명시가능, student S 라고하면 student를 S로 가져와서 where에서 S.name = 'smith' 등으로 사용가는
	* 제약조건:


* ## 무결성 제약조건
	* 주로 기본키 제약조건, 외래키 제약조건, 도메인 제약조건, 일반 제약조건이 있다.
	* DBMS는 무결성제약조건(integrity constraint, ic)를 만족하는 인스턴스만 db에 저장하도록 허락한다.
	* 제약조건은 릴레이션이 생성될 때 명시되고, 릴레이션이 수정될 때 집행된다.
	* SQL
		* ![[Pasted image 20231003204730.png]]
		* ![[Pasted image 20231003204809.png]]
			* NOT NULL은 null 값이 들어가면 안된다는 제약조건, 
			* 반대로 NULL은 null값 허용, 즉 컬럼명3와 동일하다.
		* ![[Pasted image 20231003204928.png]]
			* UNIQUE를 걸면 이 속성(들)을 key로 사용하겠다는 뜻. 
			* 다만 null값은 빈값이기에 여러개 중복가능.
			* CONSTRAINTS를 통해 제약조건의 이름 지정가능
		* ![[Pasted image 20231003205229.png]]
			* 기본키는 테이블당 하나만 존재가능
			* PRIMARY KEY == UNIQUE + NOT NULL
			* CONSTRAINTS 를 통해 기본키의 이름을 지정해줄 수 있다
		* ![[Pasted image 20231003205357.png]]
			*  1. 참조하는 릴레이션에 해당 행도 모두 삭제
				* REFERences 밑에 ON DELETE CASCADE 라고 넣어준다
			* 2. 삭제 거부
				* ON DELETE NO ACTION
			* 3. 참조하는 릴레이션에 해당하는 행의 외래키를 디폴트로 변경(실제 존재하는 외래키지만 99999등의 사용 안하는 기본키)
				* ON DELETE SET DEFAULT
				* 단 이때 DEFAULT는 릴레이션 생성때 sid CHAR(20) DEFAULT '114' 등으로 명시
			* 4. 참조하는 릴레이션의 해당하는 행의 외래키를 null값으로 준다(이는 기본키를 이루는 한 부분이기에 null이 오면 안되지만 사용되기도 한다)
				* ON DELETE SET NULL
			* UPDATE도 위와 유사
		* ![[Pasted image 20231003205503.png]]
	* ### 키 제약조건
		* 기본키는 반드시 하나, null 값을 포함하지 않는다.
		* 키를 구성하는 속성하나는 튜플을 유일하게 구분할 수 없다. 즉 키는 최소 부분집합이어야 한다.
	* ### 외래키 제약조건
		* 두 릴레이션이 링크되어 있다면 , 하나의 릴레이션이 변경되었을 때, 다른 릴레이션도 반영되어야 한다.
		* 이를 위해 하나의 IC(제약조건)이 명시되어야 하는데
		* 이것이 외래키 제약조건(foreign key constraint)
		* 외래키는 null이 아니다.
		* A릴레이션(학생)이어야만 B릴레이션(강의)를 가질 수 있다면, 즉 B릴레이션은 외래키를 가져야하며, 이 외래키는 A릴레이션의 기본키이어야 한다.
		* 즉 모든 B릴레이션의 외래키는 A릴레이션 기본키에 포함되어야하며, A릴레이션의 기본키 중 하나는 B릴레이션에 없어도 된다.
		* 만약 A에 있는 행을 삭제하려 한다면, 해당하는 B또한 삭제하거나, A삭제가 거절당해야하며, B에 뭔가를 추가하려했는데, A에 존재하지 않는다면 추가가 거절당해야 한다.
		* \# 외래키는 동일한 릴레이션을 참조할 수 도 있다. 예로 학생이라는 릴레이션에 단짝 열을 추가한다면, 이 단짝은 학생 id값을 포함할 것이다.
		* 외래키 제약조건에서 만약 참조당하는 릴레이션의 튜플이 삭제된다면 문제가 될 수 있다
			* 1. 참조하는 릴레이션에 해당 행도 모두 삭제
			* 2. 삭제 거부
			* 3. 참조하는 릴레이션에 해당하는 행의 외래키를 디폴트로 변경(실제 존재하는 외래키지만 99999등의 사용 안하는 기본키)
			* 4. 참조하는 릴레이션의 해당하는 행의 외래키를 null값으로 준다(이는 기본키를 이루는 한 부분이기에 null이 오면 안되지만 사용되기도 한다)
	* ### 테이블 제약조건(table constraint), 단언(assertion)
		* 테이블 제약조건은 단일테이블에 관한 것으로 해당 테이블이 수정될 떄만 검사
		* 단언은 여러 테이블을 포함하며, 한 테이블이 수정될 때 전체 검사
	* ### 일반 제약조건(general constraint)
		* 내가선선하는?
	* ### 관계 데이터의 질의(relational database query)
		* 질의어(query languege)는 질의를 위한 언어 ex. SQL
		* 질의의 결과는 그 결과를 포함하는 새 릴레이션
		* ![[Pasted image 20231003220602.png]]
			* 위와 같은 경우에 컬럼명에 *를 쓰면 모든 필드를 가져온다는 뜻
	* ### ER을 관계모델로
		* 하나의 entity-set은 하나의 릴레이션이 된다.
			* \# 이때 릴레이션은 er모델의 relation과 다른 거다. 이 릴레이션은 테이블!
		* #### 키 제약조건이 없는 관계집합의 변환
			* 다대다 관계의 경우(일대다는 키제약조건) 각 entityset의 기본키를 외래키로 포함하면서, 이 외래키의 집합이 슈퍼키가 된다.
		* #### 키 제약조건이 있는 관계집합의 변환
			* n개의 개체집합을 포함하는 관계집합에서 m개가 화살표로 연결 된다면 이는 키 제약조건이 존재(다대일 일대다 일대일)
			* 이 때 m개의 집합의 키 중 어느 키도 이 릴레이션의 키가 될 수 있다. 따라서 m개의 키는 후보키이다
			*  ![[Pasted image 20231003203511.png]]
			* 이와 같은 경우 한 강사가 가르치는 학생이 한명이므로 이 릴레이션에서 한 학생에게는 여러 강사가 있을  수 있으므로 sid, iid라는 advisor의 속성중 sid는 기본키가 될수 없다 왜냐하면, sid당 여러 iid가 존재하므로 같은 sid가 튜플에 여러번 등장하게 된다. 즉 (iid, sid)라는 집합에서 무조건 한번만 나오는 iid가 기본키
			* 1. adivsor의 기술적인 속성과 두 개체집합의 기본키로 릴레이션을 만든다.
			* 2. insturctor 릴레이션에 advisor의 기술적인 속성과 sid을 포함시킨다(이는 릴레이션이 하나 줄어들어 효율적.)
		* #### 참여 제약조건이 있는 관계집합의 변환
			* ![[Pasted image 20231003203511.png]]
			* 전체 참여 제약조건이 있는 경우(모든 강사는 한명의 학생이 있어야한다)
			* 2. insturctor 릴레이션에 advisor의 기술적인 속성을 포함시킨다(이는 릴레이션이 하나 줄어들어 효율적.) 이 방식을 사용해야한다. (만약 1번째방식을 사용하면, 초기 세팅때 학생이 없을수도 있다.)
			* sql문에서 sid의 값은 NOT NULL을 설정한다. 그럼 한 강사는 반드시 학생을 가져야한다.
			* 만약 다대다관계에서 두 개체집합 모두 전체 참여라면,  관계에서 한 개체집합(B)이 모두 참여할 수 있게 하려면 이 릴레이션에 모든 B개체 id가 있음을 보장해야한다. 이 떄 단언(assertions)를 사용하고 A개체집합 id는 NOT NULL을 사용한다.
			* 만약 모든 개체집합이 키 제약조건을 가지고 모두 전체 참여라면, 이는 단일 테이블로 만들 수 있다. 왜나하면 모든 개체집합이 키 제약조건(화살표)를 가지면 일대일로 매칭되므로 
		* #### 약개체집합의 변환
			* ![[Pasted image 20231004163846.png]]
			* 약개체집합은 반드시 키 제약조건과 전체 참여를 수반한다.  또한 약개체는 부분키만 가지고 있다. 그래서 Employees가 삭제되면 Dependents도 삭제되어야 한다.

			* CREATE TABLE Dep_Policy (ssn CHAR
								pname CHAR
								cost CHAR
								ssn CHAR
								PRIMARY KEY (pname, ssn),
								FOREIGN KEY (ssn) REFERENCES Employees ON DELETE CASCADE
								)
			* ssn이 NULL이 아님으로써 전체 참여제약조건이 달성된다
			* cascade를 통해 같이 삭제되는 것을 달성한다.
		* #### 클래스 계층구조의 변환
			* ![[Pasted image 20231004170651.png]]
			* 1. 직원 , 정규직, 알바 릴레이션이 존재하는데, 정규직은(알바도 동일) 연봉, 직원번호를 속성으로 갖는다. 직원번호은 정규직의 기본키이자, 직원에 대한 외래키이다.
			* 2. 혹은 정규직, 알바 릴레이션만 있는데 정규직에는 연봉,직원번호,이름,파트가 모두 속성으로 들어간다(이는 정규직, 알바가 아닌 직원이 있다면 사용할 수 없다.)
			* \# 중첩제약조건과 포괄제약조건은 단언을 사용하여 sql로 표현할 수 있다.
	* 
		
		

