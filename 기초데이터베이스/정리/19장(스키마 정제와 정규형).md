# 19.1.1 중복성으로 야기되는 문제점들
---
동일한 정보를 데이터베이스의 여러 곳에 저장하면 다음과 같은 문제점들이 야기될 수 있다.
* 중복저장(redundant storage)
* 갱신이상(update anomaly): 반복되어 저장된 데이터 중 한 사본만을 갱신하는 경우, 모든 사본이 함께 갱신되지 않으면 데이터간의 불일치가 발생된다.
* 삽입이상(insertion anomaly): 새로운 정보를 저장하기 위해, 이와 관련없는 다른 정보도 함께 저장
* 삭제이상(deletion anomaly): 어떤 정보를 삭제하는 경우 이와 관계없는 다른 정보도 함께 상실
# 19.1.2 분해
---
중복성을 제거하기 위하여 하나의 릴레이션을 여러 개의  더 작은 릴레이션들로 대체함으로써 중복성으로 야기되는 많은 문제점을 처리할 수 있다.

다만 분해를 할 때에느 두가지 질문을 항상 고려해야 한다.
1. 릴레이션을 분해할 필요가 있는가
2. 분해하고 난 후 발생할 수 있는 문제점들은 무엇인가

## 릴레이션을 분해할 필요가 있는가?
이에 대해 도움이 되는 것이 정규형이다. 즉 특정 릴레이션이 한 정규형에 속한다면 특정 유형의 문제점들이 발생하지 않음을 알 수 있다.
## 분해하고 난 후 발생할 수 있는 문제점들은 무엇인가
이에 관해서는 분해와 관련된 두 가지 성질들을 고려해야한다.
* 무손실 조인(lossless join): 릴레이션을 두 개의 릴레이션으로 분해하였어도 join을 통해 복구할 수 있다.
* 종속성 유지(dependency preservation): 릴레이션에 대한 제약조건이 위배되었는 가를 확인하기 위해 조인하지 않아도 확인할 수 있다.
예를 들어 ABC라는 테이블이 있고, A->C라는 FD가 존재할 경우
이 테이블을 AB, BC로 쪼개면 A->C라는 조건은 join을 하지 않는 한 알 수없다.
이떄 dependency preservation이 깨졌음을 알 수 있다.

# 19.2 함수 종속성(functional dependency)
---
X-> Y
즉 X 애트리뷰트들의 값이 일치한다면 Y 애트리뷰트들의 값도 일치해야 한다는 것.
일종의 무결성 조건
여기서 X는 key가 될 수도있고 super key가 될 수도 있다.
# 19.3.1 FD 집합에 대한 폐포(closure)
FD들의 집합 F에 의해 추론되는 모든 FD들의 집합을 F+,F의 closure, F의 페포 라고한다.

이를 추론해 내기 위해서는 암스트롱의 공리를 반복 적용하여 모든 FD들을 추론해 낼 수 있다

Armstong's Axioms
* 재귀(Reflexivity): Y가 X의 부분 집합이면 X-> Y이다.
* 부가(Augmentation): X->Y 이면 XZ -> YZ이다.
* 이행(Transitivity): X->Y이고 Y->Z이면 X->Z이다.
또한 
추가로 두가지 법칙을 알아두면 좋다.
* 결합(Union): X->Y이고 X->Z이면 X->YZ이다.
* 분해(Decomposition): X->YZ이면, X->Y이고 X->Z이다.

\# 참고로 SDJ -> CSJDPQV 일 경우 SD-> CSDPQV는 성립되지 않는다.

# 19.3.2 에트리뷰트 폐포
만약 X->Y와 같은 함수 종속성이 주어졌을 때, 이 종속성이 FD들의 집합인 F의 폐포에 속하는 지 여부를 검사하고 싶으면 F+를 모두 구할 필요없이 효율적으로 검사하는 방법이 있다.
이는 X+, 에트리뷰트 폐포를 구하는 것이다.
즉 X+는 X에 의해 결정되는 모든 에트리뷰트들의 집합을 의미한다.

## 에트리뷰트 폐포를 구하는 알고리즘
![[Pasted image 20231203210859.png]]
즉 FD 집합에 속하는 모든 U->V중 U가 closure에 속하면 closure에 V를 합치는 것
예를 들어
R(A,B,C,D,E,F)와 함수 종 F={A->B, A->C, CD->E, CF-> D}가 있을 때
AD+를 구해보자
초기의 AD+ = AD+이다.
1. A->B를 적용하며 A은 AD에 속하므로 closure = AD 와 B를 합친 ABD
2. A->C를 적용하면 A는 ABD에 속하므로 closure = ABCD
3. CD->E를 적용하면 CD는 ABCD에 속하므로 closure = ABCDE
4. CF->D를 적용하면 CF는 ABCDE에 속하지 않으므로 넘어간다.
5. change가 있었으므로 위과정한번더 진행
6. 변화가 없으므로 AD+ = ABCDE 이다.
이를 통해 AD-> E인가를 알고 싶으면 AD+에 E가 속하는 지만 보면된다. 
AD+는 ABCDE므로 E가 속한다.
여기서 AD -> ABCDEF가 아니므로 AD는 ABCDEF의 슈퍼키가 될 수 없다.

# 19.4 정규형
---
## 제 1 정규형
각 에트리튜트에 원자 값만 허용되는 경우(즉 리스트, 집합 값들과 같이 여러 개의 값들이 허용 안되는 경우)
## 보이스-코드 정규형
어떤 릴레이션 스키마를 R이라 하고, R에 속하는 애트리뷰트들의 부분 집합을 X라고 하고, R에 속하는 어떤 애트리뷰트가 A라고 하자.
X->A에 대해 X가 후보키(유일성, 최소성)이면 이는 보이스코드 정규형이라고 한다.
![[Pasted image 20231203212700.png]]
예를 들어 그림과 같은 상황에서 X->A를 만족한다고 가정하자. 그럼 명백히 ? 값도 a임을 알 수 있다.
이게 보이스 코드 정규형이라면 X는 키가 되어야 한다. 그럼 X->Y이므로 y1 = y2인데, 
릴레이션에서 두 투플은 같을 수 없으므로, BCNF가 될 수 없다.

# 19.5 분해의 성질
---
## 무손실 조인
릴레이션 R을 A,B로 쪼갰을 때 A조인 B 가 R이 나온다면 이건 무손실 조인이다.

즉 어던 릴레이션 R에 FD X->Y가 존재하고 X교집합 Y가 공집합이면, R을 R-Y와 XY로 분해하면 이 분해는 무손실 조인이다.
예를 들어 X->X인 경우 X교집합 X는 공집합이 아니다. 

## 종속성 유지

# 19.6 정규
---
어떤 스키마를 3NF 릴레이션 스키마들로, 종속성 유지와 무손실 조인을 모두 유지하면서 분해하는 것은 항상 가능하다.
어떤 스키마를 BCNF 스키마들로, 무손실 조인을 유지하면서 분해하는 것은 항상 가능하지만, 종속성 유지를 유지하면서 분해하는 방법은 가능하지 않다.
