데이터 베이스의 물리적 설계는 데이터의 성질과 사용 용도에 따라 만들어져야 한다.
여기서에서는 질의와 갱신으로 이루어진 작업 부하에 대한 이해가 중요하다.
즉 사용자가 특정 질의/갱신을 얼마나 많이 요구하고, 얼마나 빨리 응답해야 하는 지에 따라 물리적 설계는 변경될 수 있다.

작업부하의 각 질의에 대해서는 다음 사항들을 확인하여야 한다.
* 어떤 릴레이션들을 접근하는가
* select절에 어떤 에트리뷰트들을 주로 포함하는지
* 어떤 에트리뷰트들이 셀렉션 혹은 조인에 자주 포함되는 지.

# 인덱스
---
인덱스란 책의 색인과도 같다.
예를 들어 특정 내용을 찾으려고 모든 데이터베이스를 찾는 것은 많은 시간을 낭비하게 하므로 따라서, 데이터와 데이터의 위치를 포함하는 자료구조를 생성하여 빠르게 조회할 수 있도록 돕는다.
![[Pasted image 20231205162142.png]]
### 장점
* SELECT, UPDATE, DELETE 성능이 향상된다. 이들은 모두 찾는 작업이 필요하기에
### 단점
* 인덱스를 위한 추가의 저장공간이 필요하다.
* 인덱스를 관리해야 하므로 update, delete, insert의 경우 추가의 연산이 필요하다.

## 인덱스의 자료구조
* 해시 테이블: key값을 해시하여 index를 만들고 index에 자료를 저장한다. 다만 이는 = 를 찾는 데에는 효율적이지만 > 를 찾으려면 비효율적이다. 이럴 때는 B+Tree를 사용!
* B+Tree: 

# 물리적 설계와 튜닝 결정사항
---
## 생성할 인덱스의 선택
* 어느 릴레이션에 인덱스를 만들것인지, 또한 어떤 필드들을 인덱스의 탐색키로 만들것인지
## 개념 스키마의 튜닝
* 반정규화(denormalization):질의의 성능을 향상시키기 위해 분해되었던 릴레이션을 다시 합칠 수 있다.
* 수직분할(vertical partitioning):릴레이션을 에트리뷰트로 추가로 분해
* 뷰: 개념스키마의 변경사항을 사용자에게 감추기 위하여 뷰를 추가할 수 있다.
## 질의와 트랜잭션 튜닝
자주 수행되는 질의, 트랜잭션을 재작성하여 성능을 높일 수있다.






## 수평 분할
동일한 스키마를 갖는 두 개의 릴레이션을 만들어내는 것
이는 두 릴레이션이 제약조건과 인덱스를 다르게 할 수있다.

다만 이렇게 스키마를 변경하였을 때 유저는 이ㅇ에 대해  부자연스럽다고 느낄 수 있다 이를 위하여 뷰가 존재한다.

## 뷰
뷰는 사용자에게 접근이 허락된 자료만을 제한되게 보여주기 위하여, 하나 이상의 기본테이블로 부터 유도된 가상 테이블이다.
뷰는 저장장치 내에는 존재하지 않지만 사용자에게는 있는 것 처럼 간주된다. 