## 트랜잭션이란
기능을 수행하기 위해 필요한 논리적 작업 단위
* 서로 분리 될  수없다.
* 한꺼번에 실행되어야 한다.

## 트랜잭션의 특성(ACID)
* atomicity
* consistency
* isolation
* darability

### atomicity
더 이상 쪼갤 수 없다.
즉 All or Nothing, 즉 모두 실행되거나 하나도 실행되지 않아야 한다.

수행 도중에 장애가 발생하는 경우
* 장애 발생전 상태로 돌아간다.
### consistency
트랜잭션이 성공적으로 수행딘 후에도 데이터베이스가 일관된 상태를 유지해야 함
즉 데이터베이스가 오류가 없고 내용에 모순이 없어야 한다.
### isolation(격리성)
수행 중인 트랜잭션이 완료될 때까지 다른 트랜잭션들이 중간 연산 결과에 접근할 수 없음

여러 트랜잭션이 들어오면 번갈아 하면서 성능을 높임(멀티 프로세싱) 근데 이 상황에서는 문제가 생길 수 있다.(멀티 스레딩하고는 다른 게 완전히 다른 두 트랜잭션을 번갈아 실행하면서 결과가 잘 못나오는 것을 의미)
그래서 이러한 오류 없이 순서대로 하나씩 수행된 결과와 동일해야 한다.
### durability(지속성)
데이터베이스에 반영한 수행 결과는 영구적이어야 한다.
즉 뒤집히는 일이 없다.


## DBMS의 보장
이 네가지 특성을 DBMS가 보장해준다.
![[Pasted image 20231130162109.png]]

## 트랜잭션의 주요 연산
* commit연산: 트랜잭션이 성공적으로 수행되었음을 선언, 그럼 결과가 지속적으로 유지
* rollback연산: 트랜잭션을 수행하는 데 실패했음을 선언(nothing)하고 데이터베이스가 트랜잭션 수행  전의 일관된 상태로 돌아간다.???

## 트랜잭션의 상태
![[Pasted image 20231130162527.png]]
* 부분완료: 트랜잭션의 마지막연산이 끝난 직후의 상태(즉 디스크에 아직 반영이 안된 상태)
* 부분완료 상태에서도 실패가 될 수 있다. 즉 커밋하기 전에는 언제나 실패가 될 수 있다.
* 철회 상태가 되면 다시 수행하거나, 폐기하거나 한다.

## 장애
#### 트랜잭션 장애(소프트웨어적 오류)
예를 들어 sql문이 잘 못되거나, 데이터를 잘 못 입력하거나, 시스템 과다 사용을 요구하거나, 처리할 데이터가 없거나
#### 시스템 장애
하드웨어의 결함으로 수행을 계속할 수 없는 상태
예로  메인 메모리의 저장된 정보가 손상되거나
#### 미디어 장애
디스크 장치의 결함
디스크 암이 고장나거나, 하튼 장치의 고장, 혹은 power off(정전)

### 회복(recovery)
장애가 발생했을 때 장애가 발생하기 전의 일관된 상태로 복구시키는 것
#### 회복 관리자(recovery manager)
이는 DBMS의 서브 시스템이며, 전체 DBMS의 10퍼센트를 차지한다.
장애를 발견(탐지)하면 복구하는 기능을 제공한다.
* 손상된 부분만을 포함하는 최소의 범위
* 최단시간 내
* 트랜잭션 기반 회복(트랜잭션 단위로 처리한다)
* 시스템레벨의 자동조치

회복 관리자는 상당히 heavy하므로 쉽게 사용하려 하면 안된다. 즉 신중하게 해야한다.

### 장애와 회복
저장 장치의 종류
* 휘발성 저장 장치: 장애가발생하면 데이터가 손실됨(메모리등)
* 비휘발성 저장 장치: 장애가 발생해도 데이터가 손실되지 않는다.(다만 디스크 헤더 손상 같은 저장 장치 이상은 데이터 손실 가능, 하드 디스크 ,ssd등)
* 안정 저장장치: 어떤 장애가 발생해도 손실되어도 데이터를 영구적으로 저장가능, 즉 복사본을 여러 개를 만드는 방법. RAID를 쓸거다.

### RAID
* redundant(중복)
* arrays of
* inexpensive(independent)
* disks
디스크들을 array처럼 저장하는데, 중복해서 저장
즉 하드 디스크를 여러개를 묶어서 같이 동작시키는 것
즉 중복해서 저장하여 손실이 일어나지 않도록한다.

예를 들어 여러 디스크의 같은 자리에 있는 비트에 대해
1 exclusiveor 0 exclusiveor 1
1 exclusiceor 1 = 0을 제일 마지막에 디스크에 적는다.
따라서 디스크 중 하나가 고장나면 exclusiveor를 통해 복구해낼 수 있다.
다만 이는 두개가 동시에 고장나면 복구 불가능
이러한 redundant 디스크를 늘리면 stable해진다.

## DBMS의 저장 구조
![[Pasted image 20231130170358.png]]
로그 버퍼는 로그만 버퍼링하고 디스크에 쓰고 가져온다.
DB 버퍼는 레코드만 기록해두고 디스크에 쓰고, 가져온다.
## 트랜잭션 수행을 위해 필요한 데이터 이동 연산
![[Pasted image 20231130170454.png]]
보통 한바이트만 읽고 싶어도 블럭 단위로 가져와야 한다. 
B는 블럭
DBMS는 메인 메모리에 있고, 데이터를 디스크에 쓰고 가져옴
#### read()
DB버퍼에 있는 데이터를 읽어오는 것, 예로 디스크에서 DB버퍼로 데이터를 가져오면 파이썬이 커서로 가져오는 것
#### write()
프로그램의 변수 값을 메인 메모리 버퍼 블록에 기록하는 연산이는 즉시 하지 않고 딜레이가 있다. 성능 때문이다. 즉시 쓰면 너무 디스크io가 많아진다.(이로 인하여 리커버리 방식이 복잡해진다.)

## 디스크와 메인 메모리 간 데이터 이동 연산
![[Pasted image 20231130170848.png]]
#### input()
input은 디스크에 있는 데이터를 버퍼로 가져오는 것
요청이 있으면 즉시 실행된다. (on demand)
내가 필요한 것이 버퍼에 캐시되있는 것이 가장 좋으나 캐싱이 안되어있으면 input을 즉시해야한다. 
#### output()
output은 메모리에 있는 것을 디스크로 저장
output은 언제 할 지 모른다. 이 때 버퍼랑 디스크의 상태가 달라지는 inconsistent상태가 될 수 있다.

output을 언제 할 지 모르므로 버퍼에 저장되어 있는 x가 정전이 일어나면 모두 날라간다.

## 회복의 기본 원리
기본원리는 redundancy(즉 데이터를 중복저장하는 것)
방법
* Dump: 데이터베이스 전체를 다른 저장 장치에 복사하는 방법, 주로 백업용으로 쓰인다.(snapshot을 tape에 복사한다)
* Log: 데이터베이스에서 변경 연산이 실행될 때, 변경 이전 값과 변경한 이후의 값을 별도의 파일에 기록(select는 x, insert등 write할 때만 logging한다.)

## 회복을 위한 연산
### redo(재실행)
로그를 이용하여 복사본이 만들어진 이후에 실행된 모든 변경 연산을 재실행
### undo(취소)
모든 변경 연산을 취소하여 데이터베이스를 원래의 상태로 복구

### 로그 파일
![[Pasted image 20231130173059.png]]
write를 하면 로깅을 해야 한다.

## 회복 기법
![[Pasted image 20231130173502.png]]
### 로그 회복 기법(지연 갱신 회복 기법)
지연은 output연산을 지연시켰다는 뜻. 
로그 회복 기법이란 트랜잭션이 부분 완료 상태가 될 떄까지 모든 output()연산을 지연시키는 것
트랜잭션이 활동 상태 중에는 변경 결과를 로그 파일에만 기록한다.
장애가 발생하면 로그 레코드만 삭제하면 데이터베이스가 원래 상태가 된다.(output을 안했기에)

![[Pasted image 20231130173750.png]]
예로 위 write 하면 output을 요청을 한다.
commit을 쓸 때까지 output을 지연 시킨다.
즉 commit을 하면 이후에 output을 한다.

\# 부분완료란
write까지 한 것도 부분완료, \<T, commit>도 된 것

그럼 로그는 디스크에 바로바로 저장되나?
commit이 되었을 때 db에 반영되었는가? 몰라요 요청을 한 거기에
하지만 한번더 덮어쓰는 것에는 문제가 없기에 다시 한다.

즉 commit까지 된 것은 redo, commit안된 것은 undo