* ## 빈 스코프란?
	* 스프링 빈이 컨테이너의 시작과 함께 종료될때까지 유지되는 것은 기본적으로 스프링 빈이 싱글톤 스코프이기에
	* 스코프에는
		* 싱글톤: 가장 넓은 범위 스코프
		* 프로토타입: 빈을 만들어서 주고, 의존관계 주입하고, 초기화까지 해주는데 클라이언트엑게 반환 후 더이상 관리 x, 즉 종료메서드 호출 x, 또한 계속 객체를 새로 생성해서 반환
		* 웹 관련 스코프
			* request: 웹 요청이 들어오고 나갈때까지
			* session: 웹 세션이 생성, 종료 까지
			* application: 서블릿 컨텍스와 같은 범위
* 싱글톤 빈은 스프링 컨테이너 생성 시점에 빈이 생성되고 초기화 되지만, 프로토 타입은 빈을 조회할 때(getBean) 빈이 생성되며, 이때 초기화 메서드도 실행된다
* ## DEPENDENCY LOOKUP(DL)
	* 의존관계를 외부에서 주입받는게 아니라 이렇게 직접 필요한 의존 관계를 찾는 것을 DL 이라고 한다.
	* 애플리케이션 컨텍스트 전체를 주입받게 되면, 컨테이너에 종속적인 코드가 되어서 안 좋다
	* 이를 해결하고 DL 정도 기능만 해주는 것
* ## ObjectFactory, ObjectProvider
		* 싱글톤 내에서 프로토타입 빈을 생성한다면, 사용할 떄마다 생성되는 게아니라, 처음 생성하고 생성한 것을 계속 사용, 이를 해결하기 위해 호출 시점에 컨테이너를 찾아 주입해주는 게 필요.
	* prototypeBeanProvider.getObject는 이 때서야 컨테이너에서 프로토타입 빈을 찾아서 반환. ApplicationContext에서 직접 찾는 게 아니다.
	* ObjectFactory를 확장시킨 게 ObjectProvider
	* 스프링 컨테이너를 직접 찔러서 알아보는게 아닌 objectFactory로 대리해서 확인하는 것.
	* 즉 필요할 때마다 그떄그떄 생성을 해서 사용한다.
	* 다만 objectFactory, ObjectProvider 모두 spring에 의존적이다.
* ## Provider
	* 'javax.inject.Provider'라는 자바 표준을 사용하면 위의 spring 의존성을 없앨 수 있다.
	* 다만 이것은 라이브러리라서 추가해줘야한다.
	* 사용방법은 주입에서
	* @Autowirder
	* private Provider<클래스명> 이름;  으로 사용하면 된다
	* 또한 get으로 가져오면 된다.
* 다만 스프링 자체 제공하는 것이 기능이 더 많고 편리하기에 그냥 스프링꺼 쓰자.
* 기능이 비슷한 경우만 표준을 사용


* ## 웹스코프
	* 웹스코프는 스프링이 해당 스코프의 종료 시점까지 관리해준다. 따라서 종료 메서드가 호출된다.
	* request:
		* http요청하나가 들어오고 나갈 때까지(즉 요청 빈 인스턴스가 생성되고 관리된다.)
		* 동시 요청되어도 각 요청마다 다른 빈 인스턴스를 생성
	* session:
		* http session과 동일한 생명주기
	* application:
		* 서블릿 컨텍스트와 동일한 생명주기
	* websocket:
		* 웹소켓과 동일한 생명주기
* ## REQUEST 스코프
	* 이 스코프를 사용하는 근본적인 이유는 서비스 계층과 웹 관련 정보를 분리하기 위해서, 즉 서비스에서 필요없는 파라미터,변수등이 사용될 수있는 것을 막을 수 있다. 
	* 공통 포멧: UUID  requestURL  message
	* 즉 UUID는 unique id라고 전세계에 단 하나 뿐인 id로 즉 요청이 왔을 때 어느 고객에게서 왔는지 알 수 있다.
	* requestURL은 어느 요청에서 왔는지 알 수 있다
	* 이 요청에서 어떤 method등을 호출했는지가 message에 들어간다.
	* 
* ## 프록시
	* 실제 객체 대신에 cglib라는 라이브러리로 가짜 프록시 객체를 만들어서 주입해준다.
	* 즉 가짜 프록시 객체는 요청이 오면 그 때 내부에서 진짜 빈을 요청하는 로직이 들어있어서
	* request 같은 scope라면 요청올 때 만들어주기에 적합하다
	* 즉 진짜 객체 조회를 꼭 필요한 시점까지 지연처리 할 수 있다.
	* @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
		* 적용하는 객체가 class이면 TARGET_CLASS 사용하며
		* 적용하는 객체가 인터페이스면  INTERFACES
	* 이 프록시는 실제 싱글톤이 아니므로 조심해야하고, 꼭 필요한 곳에 최소한으로만 사용하자.