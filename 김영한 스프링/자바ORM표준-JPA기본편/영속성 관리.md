# 영속성 관리
---
단 하나의 엔티티매니저 팩토리는 엔티티 매니저를 여러개 만들면서, 클라이언트의 요청을 처리한다.

여기서 엔티티를 저장하는 환경이 영속성 컨텍스트이다.
## 영속성 컨텍스트란?
엔티티를 영구 저장하는 환경을 의미한다.
`em.persist(entity)`를 실행하면, 바로 db에 저장되는 것이 아니라, 컨텍스트로 들어가서 관리가 되며, db에는 추후에 한번에 저장된다. 즉 캐시같은 존재이다.
즉 persist는 db에 저장하는 것이 아니라, 영속한다는 것이다. 

## 엔티티메니저를 만들면 그에 해당하는 영속성 컨텍스트가 만들어진다.
엔티티메니저를 만들면 그에 해당하는 영속성 컨텍스트가 만들어진다.
즉 각 엔티티 매니저는 자신의 영속성 컨텍스트를 관리한다.

하지만 반드시 엔티티매니저가 서로 다른 영속성 컨텍스트를 관리하는 것은 아니며, 여러 엔티티 매니저가 한 영속성 컨텍스트를 관리하기도 한다.




# 엔티티의 생명주기
---
엔티티는 다음과 같은 4가지 중 하나의 상태를 가진다.
* 비영속
* 영속
* 준영속
* 삭제
### 비영속
영속성 컨텍스트와 관계없는 , 새로 만들어진 엔티티
### 영속
영속성 컨텍스트가 관리하는 상태
### 준영속
영속성 컨텍스트가 관리하다가, 더 이상 관리하지 않는 상태

`em.detach(entity)`를 한다면 더 이상 엔티티를 영속성 컨텍스트가 관리하지 않는다.
### 삭제
엔티티가 삭제된 상태

`em.remove(entity)`를 한다면 엔티티가 삭제된다.





# 영속성 컨텍스트의 이점
---
* 1차 캐시
* 동일성 보장
* 트랜잭션을 지원하는 쓰기 지연
* 변경 감지
* 지연 로딩
## 1차 캐시
1차 캐시에는 key, value형식으로 정보를 저장해둔다.
여기서 key는 primary key이며, value는 엔티티자체이다.

즉 1차 캐시에 저장을 해둠으로써, db에 접근하지 않아도 정보를 빠르게 가져올 수 있는 이점을 누릴 수 있다.

```java
//1차 캐시에 저장
em.persist(member);

//1차 캐시에 member1이 존재하면, 1차캐시에서 조회된다. 없으면 db에서 조회한다. 그리고 1차캐시에 저장해둔다.
Member findMember = em.find(Member.clas, "member"); //여기서 member1은 key이다.
```
## 영속 엔티티의 동일성 보장
만약 영속성 컨텍스트가 존재하지 않는다면 다음과 같은 코드의 결과는 어떻게 될까?
```java
Member findMember1 = em.find(Member.class, 1L);
Member findMember2 = em.find(Member.class, 1L);
System.out.println(findMember1 == findMember2);
```
false가 출력될 것이다. 왜냐하면 `em.find`에서 각각 쿼리문을 날려서 데이터를 가져와 저장하므로, `findMember1`과 `findMember2`의 참조값은 다를 것이다.

여기서 영속성 컨텍스트는 같은 데이터는 동일성을 보장해준다. 왜냐하면 한번 sql을 통해 가져와, 1차캐시에 존재하는 데이터 같은 경우 다시 쿼리문을 날리지 않고, 영속성 컨텍스트에서 가져오기 때문이다.

단 이는 같은 트랜잭션 내에서만, 의미가 있다. 한 트랜잭션이 종료되면, 엔티티매니저, 영속성 컨텍스트도 같이 종료되기 때문이다.
## 트랜잭션을 지원하는 쓰기 지연
영속성 컨텍스트는 `persist`마다 db에 저장하지 않는다. `commit`이 될 경우에만 한번에 모든 정보를 db에 반영한다. 이런 이유는 매 `persist`마다 쓰기를 하면, 성능에 이슈가 되기 때문이다. db와 연결하는 작업은 많은 시간을 필요로 하며, 매 `persist`마다 연결 후 쓰기를 하면 너무 많은 시간이 필요하다.

따라서 영속성 컨텍스트에 저장해두었다가 commit이 일어나면 한번에 저장된다.

참고로 이는 1차캐시에서 일어나는 게 아니라, 쓰기 지연 SQL 저장소에서 일어난다.

참고로 쓰기 지연 SQL 저장소에 저장시키는 최대사이즈를 지정할 수 있으며, 이를 넘어가면 자동으로 commit되게 할 수 있다.
이는 `persistence.xml`에 다음과 같이 `property`를 추가하면 된다.
```java
<property name="hibernate.jdbc.batch_size" value="10"/>
```

## 변경 감지
 데이터를 찾아와서 변경하기만 하면 따로 저장할 필요없이, 알아서 저장된다.

이는 엔티티를 가져왔을 때, 최초의 상태를 스냅샷을 저장해두며,
추후에 `em.commit`이 되면 `flush`가 이루어지고, 그럼 엔티티와 스냅샷을 비교하여, 같지 않으면 데이터베이스에 덮어쓴다.






# 플러시
---
영속성 컨텍스트의 변경내용을 데이터베이스에 반영하는 것

즉 플러시가 일어나면
* 변경 감지
* 수정된 엔티티를 쓰기 지연 SQL 저장소에 등록
* 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송
등이 일어난다.
## 플러시 모드 옵션
* FlushModeType.AUTO
* FlushModeType.COMMIT
기본적으로 AUTO를 쓰며, COMMIT은 Commit할 때만 플러시되는데 웬만하면 사용하지 말자
설정은 `em.flushMode()`로 할 수 있다.
## 그럼 영속성 컨텍스트는 어떻게 플러시 할까
* em.flush(): 사용자가 직접 `flush`를 호출한다.
* 트랜잭션 커밋: 트랜잭션 `commit`하면 플러시도 일어난다.
* JPQL 쿼리 실행: JPQL 쿼리를 실행하면 자동으로 플러시 된다. 이러한 이유는 JPQL은 데이터베이스와 연결이 되므로, 쿼리문 날리는 겸에 한번에 처리하는 것이다. 또한 memberA를 persist한 상태에서 memberA에 대한 jpql 쿼리를 날리면 문제가 생길 수 있기에 쿼리를 날리기전에 먼저 플러시하는 것이다.

참고로 플러시를 해도 1차캐시가 지워지지는 않는다. 오직 쓰기지연 저장소를 데이터베이스에 반영할 뿐이다.




# 준영속 상태
---
영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것.

준영속 상태에서는 엔티티를 변경하여도 update되지 않는다.

## 준영속 상태로 만드는 법
* `em.detach(entity)`: 특정 엔티티만 준영속 상태로 변환 
* `em.clear()`: 영속성 컨텍스트를 초기화
* `em.close()`: 영속성 컨텍스트를 종료
